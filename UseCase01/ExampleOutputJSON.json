{
  "Java": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of vulnerability that occurs when an attacker is able to inject malicious scripts into a web page, allowing them to gain access to confidential information or to take control of the page. These scripts can be injected into a web page through user input, such as by entering malicious code into a text box or URL. When a user visits the page, the malicious script is executed and can access user data or perform other malicious activities. XSS vulnerabilities can lead to serious security breaches and should always be taken seriously.",
      "vulnerable_code": "String userInput = request.getParameter(\"userInput\");\nString output = \"<h1>Welcome, \" + userInput + \"</h1>\";\nresponse.getWriter().write(output);\n\n// This code is vulnerable to cross-site scripting (XSS) attacks because it does not properly sanitize the user input before it is included in the generated output. An attacker could inject malicious JavaScript code which would be executed in the user's browser when the output is rendered.",
      "remediation": "The following code example is a remediation for Cross-site Scripting (CWE-079):\n\n// Before\nString input = request.getParameter(\"input\");\nresponse.getWriter().println(\"<p>\" + input + \"</p>\");\n\n// After\nString input = request.getParameter(\"input\");\ninput = input.replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\");\nresponse.getWriter().println(\"<p>\" + input + \"</p>\");",
      "semgrep_rule": "rule = dot.cwe_079:\n    patterns:\n    - pattern: |\n        \"<\\s*[^>]*[^/]\\s*(on\\w+\\s*=\\s*(\"[^\"]*\"|'[^']*'))\n      message: \"Potential cross-site scripting issue detected.\"\n      severity: WARNING\n      languages: [java]",
      "codeql_rule": "import cwe089\n\nclass CrossSiteScriptingVulnerability implements Rule {\n   \n    // Query to detect the vulnerability\n    Query<Node> vulnerableNodes =\n        // Find any HTML \u2018<\u2019 tags\n        (HtmlElement h) =>\n            h.getTextContent()\n\n        // Which contain any untrusted input\n        // i.e. input which is not properly sanitized\n        & exists(Variable v, MethodInvocation m |\n            h.getTextContent().contains(m)\n            & m.getTarget().matches(v)\n            & not cwe089.sanitizationFunction(m)\n        )\n\n    // Issue a finding for each vulnerable node\n    @Override\n    test() {\n        for (Node n : vulnerableNodes) {\n            report(n);\n        }\n    }\n\n}"
    },
    "CWE-020: Improper Input Validation": {
      "description": "CWE-020 is an Improper Input Validation vulnerability that occurs when an application fails to validate user input, allowing malicious or malformed data to be entered into the system. This can lead to security issues such as buffer overflows, SQL injection, and other attacks. In Java, this can be caused by not validating user input when using methods such as getParameter, readLine, and readBytes. This can allow an attacker to enter malicious data and manipulate the system.",
      "vulnerable_code": "public void processInput(String input) {\n  // do something with the input\n  // ...\n  System.out.println(\"Input is: \" + input);\n}\n\nIn this code, the input is not being properly validated, which can lead to potential security vulnerabilities. An attacker could pass malicious input that would be executed by the system, potentially leading to malicious code execution.",
      "remediation": "The following is an example of a method for performing proper input validation in Java:\n\npublic boolean validateInput(String input) {\n    if (input == null || input.trim().length() == 0) {\n        return false;\n    }\n    // Perform other validation checks as necessary\n    return true;\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detect improper input validation\"\n    author = \"Author\"\n    date = \"2020-08-05\"\n  source:\n    lang = \"java\"\n  detection:\n    input_validation:\n      patterns:\n       - pattern: '.*receive.*input.*'\n         message: 'Improper input validation may lead to vulnerabilities'\n         confidence: high\n}",
      "codeql_rule": "import cwe020\n\nclass ImproperInputValidationVulnerability implements Vulnerability {\n  // Check if the vulnerable code is present\n  Boolean isVulnerable(Cwe020 cwe020) {\n    return exists(Method m,\n      m.getName().matches(\"(?i).*validat.*\") and\n      cwe020.getInputValidation(m)\n    );\n  }\n}"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of security vulnerability that occurs when a user is able to inject malicious code into an OS command. This can be done by inputting special characters, such as semicolons or quotation marks, which can be interpreted as part of a command and then executed by the system. This can be dangerous, as it can allow for malicious code to be executed on the system. In Java, this vulnerability can occur if user input is passed directly to an OS command without being properly sanitized.",
      "vulnerable_code": "String command = \"ping -c 1 \" + ipAddr;\nRuntime.getRuntime().exec(command);\n\nIn the above example, the code creates a command string that includes an IP address specified by the user. This could allow an attacker to inject malicious code into the command string, which would then execute on the system when the Runtime.getRuntime().exec() method is called.",
      "remediation": "Original vulnerable code:\n\nString command = \"ping -t \" + userInput;\nRuntime.getRuntime().exec(command);\n\nRemediated code:\n\nString[] command = {\"ping\", \"-t\", userInput};\nProcess proc = new ProcessBuilder(command).start();",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detect CWE-078: Improper Neutralization of Special Elements used in an OS Command\"\n    severity = \"High\"\n  strings:\n    $input = \"*\"\n  condition:\n    all of them\n}\n\n---\n\nrule = {\n  meta:\n    description = \"Detect CWE-078: Improper Neutralization of Special Elements used in an OS Command\"\n    severity = \"High\"\n  strings:\n    $input = \"/*\"\n  condition:\n    all of them\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass CommandInjectionVulnerability extends SecurityCodeQL {\n  // Create a query to detect the vulnerable code\n  query vulnerableCode() {\n    // Find any Java method which takes a string as an argument\n    Method m = method(\"java.lang.String\", _, _)\n    // Find any command execution in the method\n    Process p = Process.create(m)\n    // Find any string concatenation in the method\n    StringConcatenation sc = StringConcatenation.inMethod(m)\n    // Find any string concatenation used as an argument for a command execution\n    select sc, p \n    such that sc.isArgumentTo(p)\n  }\n\n  // Create a query to generate an alert for vulnerable code\n  query alertVulnerableCode() {\n    // Find any vulnerable code\n    vulnerableCode()\n    //"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089 is a type of vulnerability where an attacker is able to inject malicious SQL code into an application. This can be done by sending malicious user input to the application that is not properly sanitized and then used in an SQL query. The attacker can then use this query to gain access to the application's data or even execute code on the server. This vulnerability can cause data leakage, information disclosure, and even system compromise.",
      "vulnerable_code": "String query = \"SELECT user_name FROM users WHERE user_id=\" + request.getParameter(\"user_id\");\nStatement stmt = connection.createStatement();\nResultSet result = stmt.executeQuery(query);\n\nIn this example, the application is building an SQL query using a parameter from an HTTP request without properly validating or escaping it. This could allow an attacker to inject malicious SQL code into the query and potentially gain access to sensitive data or execute malicious commands on the database.",
      "remediation": "// Before\nString query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n\n// After\nString query = \"SELECT * FROM users WHERE username = ?\";\nPreparedStatement pstmt = conn.prepareStatement(query);\npstmt.setString(1, username);",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects SQL Injection vulnerability\"\n    severity = \"CRITICAL\"\n  source:\n    language = \"Java\"\n  patterns:\n    - pattern: 'String query = .*?;'\n      name: \"sql_query\"\n    - pattern: 'query.+?(\".*?|'.*?')'\n      name: \"sql_injection\"\n      within: sql_query\n  filters:\n    - sql_injection\n}",
      "codeql_rule": "import cwe089\n\nclass Cwe089Rule extends Rule {\n    Cwe089Rule() {\n        super(\"Cwe089\")\n    }\n\n    @Override\n    query {\n        // Find all SQL queries\n        QSqlQuery qQuery | \n        // Find all uses of user-controlled data\n        QSqlQuery.prepare(string userInput)\n        // Find any instances of the user-controlled data being used without proper sanitization\n        qQuery.exec(string userInput)\n    }\n}"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "This vulnerability occurs when an application fails to properly restrict the paths a user can access, allowing a user to traverse directories outside the intended path. This vulnerability can be exploited by malicious users to access sensitive data and files, as well as to gain unauthorized access to system resources. This vulnerability is especially dangerous when user-supplied input is used as part of the path, as attackers can manipulate the input to traverse directories outside of the intended path.",
      "vulnerable_code": "public void copyFile(String sourceFile, String destinationFile) { \n   Path sourcePath = Paths.get(sourceFile);\n   Path destinationPath = Paths.get(\"/home/user/destination/\" + destinationFile);\n   try {\n    Files.copy(sourcePath, destinationPath);\n   } catch (IOException e) {\n    e.printStackTrace();\n   }\n}\n\nThe above code is vulnerable to Path Traversal because it fails to properly validate the source path, allowing a malicious user to craft a source path traversing up the directory tree. For example, an attacker can pass in a source file path like \"../../../etc/passwd\" to access sensitive system files.",
      "remediation": "One way of remediating CWE-022 is to disallow directory traversal by validating user input. For example, in Java, a developer can use the Paths.get() method to validate user input and restrict it to a predetermined list of directories.\n\nString userInput = \"../../../unauthorized/file.txt\";\n\n//Validate user input against predetermined list of directories\ntry {\n    Paths.get(userInput);\n} catch (InvalidPathException e) {\n    //Handle exception\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Path Traversal Vulnerability\"\n    severity = \"CRITICAL\"\n    author = \"Security Team\"\n  strings:\n    $st1 = /(\\.\\.\\/)/\n    $st2 = /(\\.\\.\\\\)/\n    $st3 = /(\\/\\*)/\n    $st4 = /(\\\\\\*)/\n  condition:\n    $st1 or $st2 or $st3 or $st4\n}",
      "codeql_rule": "import java\n\nclass PathTraversalVulnerability extends Rule {\n  // Search for a File object being created with a user-provided path\n  File(String path) {\n    // Check if the path contains an 'upwards directory traversal' \n    // character (../)\n    contains(path, \"../\")\n  }\n  \n  // Check if the file object is being used to read or write to a file \n  // outside the current working directory\n  File.read() {\n    // Check if the path of the file object is not within the \n    // current working directory\n    not within(this.path, cwd())\n  }\n  \n  File.write() {\n    not within(this.path, cwd())\n  }\n  \n  // Generate an alert when the vulnerability is found\n  alert Path Traversal Vulnerability detected {"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site request forgery (CSRF) is a type of attack that occurs when a malicious web site, email, blog, instant message, or program causes a user's web browser to perform an unwanted action on a trusted site when the user is authenticated. This attack exploits the trust a web site has for a user. In a CSRF attack, the attacker tricks the user's browser into sending a forged HTTP request, including the user's session cookie and any other authentication information, to a vulnerable web site. The forged request may contain malicious commands, such as changing the user's password or transferring money out of their account. This attack can be used to gain access to the user's account, steal data, or perform other malicious actions without the user's knowledge or consent.",
      "vulnerable_code": "The following code sample is vulnerable to Cross-Site Request Forgery (CSRF) attacks:\n\n//Retrieve the user's session ID\nString sessionId = request.getParameter(\"sessionId\");\n\n//Retrieve user data from the request\nString userName = request.getParameter(\"userName\");\nString password = request.getParameter(\"password\");\n\n//Create a URL to access the user's account\nString url = \"http://example.com/account?sessionId=\" + sessionId + \"&userName=\" + userName + \"&password=\" + password;\n\n//Send a request to the URL\nHttpClient client = new DefaultHttpClient();\nHttpGet get = new HttpGet(url);\nHttpResponse response = client.execute(get);",
      "remediation": "One way to remediate a Cross-Site Request Forgery (CSRF) vulnerability is to implement a unique token system in all requests. This can be done by generating a unique token for each user session and adding it to all requests. Then, when the server receives the request, it can check for the presence of the token and verify it is valid before processing the request. \n\nFor example, each time a client requests a protected resource, the server can generate a unique token and store it in the user's session. Then, the server can add the token to the response and include it in all subsequent requests. The server can then verify that the token is valid before processing the request.",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects Cross-Site Request Forgery (CSRF) vulnerability\"\n    strings:\n      $request_csrf = /.*sendRedirect.*/\n      $csrf_token = /.*(csrf|CSRF).*/\n    condition:\n      $request_csrf and not $csrf_token\n}",
      "codeql_rule": "import java\n\nclass CWE352_Cross_Site_Request_Forgery_CSRF {\n    // Get all HTTP requests\n    private HttpRequest reqs  =  select  distinct t \n                                from HttpRequest t \n                                where t instanceof HttpRequest;\n    \n    // Get all HTTP responses\n    private HttpResponse resps = select distinct t \n                                from HttpResponse t \n                                where t instanceof HttpResponse;\n    \n    // Get all requests that are sent without a CSRF token\n    private HttpRequest noTokenReqs = select t\n                                    from HttpRequest t\n                                    where not exists(t.getHeaders(\"CSRF-Token\"));\n    \n    // Get all responses to requests sent without a CSRF token\n    private HttpResponse noTokenResps = select t\n                                        from HttpResponse"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability that occurs when an application allows a user to upload a file of any type, without restrictions or validation. This can lead to malicious files being uploaded, such as scripts or executables, which can then be used to compromise the system or gain access to sensitive data. The application should always validate the type of file being uploaded and restrict it to only those types that are safe and necessary.",
      "vulnerable_code": "public void uploadFile(String fileName)\n{\n    // Get the file from the client\n    File uploadedFile = getFileFromHttpRequest();\n\n    // Create the path to the file\n    String filePath = \"/upload/\" + fileName;\n\n    // Save the file to the server\n    try {\n        FileOutputStream fos = new FileOutputStream(filePath);\n        fos.write(uploadedFile);\n        fos.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\nThis code is vulnerable because it does not check the file type of the uploaded file before writing it to the server. This could lead to malicious files, such as executable files, being uploaded to the server and potentially causing damage.",
      "remediation": "Remediation for this vulnerability could include ensuring that any files uploaded to the server are checked for dangerous types or content prior to allowing them to be stored on the server. This could be done by either implementing an antivirus scanner on the server or by performing a file extension check on the uploaded file to ensure it is not one of the types that should not be allowed. Additionally, the server should be configured to restrict the maximum size of files that can be uploaded and only allow certain types of files that are deemed safe.",
      "semgrep_rule": "rules:\n  - id: cwe-434\n    patterns:\n      - pattern: |\n          (\n            command: \"upload\"\n            and param[*].value: /.*\\.(php|asp|csh|pl|cgi|exe|bash|sh|py|js)$/\n          )\n    message: \"Unrestricted upload of file with dangerous type detected\"\n    severity: error",
      "codeql_rule": "import java\n\nclass UnrestrictedUploadOfFileWithDangerousType extends SecurityCodeScanRule {\n  // Checks for code which allows the unrestricted upload of a file with a dangerous type\n \n  // Define the query\n  Query dangerousTypeUpload = \n    find Method m, Class c, StringLiteral sl\n    where sl.value =~ /.*\\.(exe|bat|bin|cmd|reg|pif|scr|dll|vbs|vbe|wsf|wsh|shs|com|cpl|jar|js|jse|msi|msp|mst|pcd|scf|lnk|inf|ocx|sys)$/\n    and c.hasMethod(m)\n    and m.name = \"upload\"\n    and m.hasAnnotation(\"RequestMapping\")\n    and m.getAnnotation(\"RequestM"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306 is a vulnerability that occurs when an application fails to properly authenticate a user before allowing them access to a critical function. This can lead to malicious actors gaining access to sensitive data or functions that should only be accessible to authorized users. Without proper authentication, there is no way to verify that the user is actually who they claim to be. As a result, this vulnerability can lead to a wide range of security risks.",
      "vulnerable_code": "// vulnerable code\npublic class AuthenticationCheck {\n    public void doSomething() {\n        // code to do something\n    }\n    \n    public void doSomethingCritical() {\n        // code to do something critical\n    }\n}\n\n// vulnerable code can be fixed by adding an authentication check\npublic class AuthenticationCheck {\n    public void doSomething() {\n        // code to do something\n    }\n    \n    public void doSomethingCritical() {\n        // check if user is authenticated\n        if (isAuthenticated()) {\n            // code to do something critical\n        } else {\n            // throw an error\n            throw new SecurityException(\"User is not authenticated\");\n        }\n    }\n    \n    private boolean isAuthenticated() {\n        // code to check if user is authenticated\n    }\n}",
      "remediation": "The following code snippet shows an example of how to remediate a vulnerability of missing authentication for a critical function in Java code:\n\n// Create a user authentication object\nUserAuthentication auth = new UserAuthentication();\n\n// Check if user is authenticated\nif (auth.isAuthenticated()) {\n    // Execute the critical function\n    executeCriticalFunction();\n}\nelse {\n    // Throw an exception\n    throw new AccessDeniedException(\"User not authenticated!\");\n}",
      "semgrep_rule": "rule = {\n        strings:\n            $function_name = /.*authentication.*/\n        condition:\n            all\n    }\n\n    not (\n        exists(p.CallExpr[f.id == $function_name]\n            and p.CallExpr.callee.Object.property.name == \"authenticate\"\n    )",
      "codeql_rule": "import java\n\nclass CWE306MissingAuthenticationForCriticalFunction extends Security {\n    /**\n     * Vulnerability: CWE-306: Missing Authentication for Critical Function\n     * \n     * This query finds instances of missing authentication for critical functions\n     * by looking for methods that are marked as critical but are not using authentication.\n     */\n    vulnerable_methods() {\n        Method m\n        m.getAnnotation(java.security.Critical)\n        not m.isProtectedByAuthentication()\n    }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a common vulnerability that occurs when an application deserializes untrusted data. This vulnerability can be exploited by malicious actors to inject malicious code into the application and gain access to confidential data. When an application deserializes data, it is assumed that the data is valid and safe, however, if the data is not properly validated, attackers can inject malicious code and take control of the application. This can lead to data leakage, system compromise, and other malicious activities.",
      "vulnerable_code": "public class DeserializeUntrustedData {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        // Create an input stream to read the object\n        FileInputStream fis = new FileInputStream(\"data.ser\");\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        // Read the object\n        Object o = ois.readObject();\n        ois.close();\n \n        // Cast the object to a known type and use it\n        String s = (String) o;\n        System.out.println(s);\n    }\n}",
      "remediation": "// Before\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));\nObject obj = ois.readObject();\n\n// After\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));\nObject obj = null;\ntry {\n    obj = ois.readObject();\n} catch (ClassNotFoundException e) {\n    throw new RuntimeException(\"ClassNotFoundException encountered while deserializing untrusted data\");\n} catch (InvalidClassException e) {\n    throw new RuntimeException(\"InvalidClassException encountered while deserializing untrusted data\");\n}",
      "semgrep_rule": "rule = {\n    meta:\n        id = \"CWE-502\"\n        description = \"Detects deserialization of untrusted data\"\n        author = \"Your name here\"\n    patterns:\n        - pattern: \"(ObjectInputStream.readObject\\( *\\)|ObjectInputStream.readUnshared\\( *\\)|ObjectInputStream.readFields\\( *\\))\"\n        message: \"Deserialization of untrusted data may lead to CWE-502\"\n        severity: WARNING\n    }",
      "codeql_rule": "import cwe502\n\nclass DeserializationUntrustedDataVulnerability implements CodeQLSearch {\n  // Find calls to deserialize methods that use untrusted data\n  @Cwe502\n  Query<Invocation> deserializationVuln() {\n    Invocation.find(\n      // find any method calls\n      _, \n      // that involve deserialization\n      Method.named(\"deserialize\")\n    )\n    // where the argument is untrusted data\n    .where(\n      Invocation.argument(0).hasSource(\"UntrustedData\")\n    )\n  }\n}"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability in which a system does not adequately verify the identity of a user before granting them access. This could be due to a lack of authentication protocols, weak or nonexistent passwords, or a lack of multi-factor authentication. This type of vulnerability can allow an attacker to gain access to a system, data, or accounts they should not have access to.",
      "vulnerable_code": "String username = request.getParameter(\"username\");\nString password = request.getParameter(\"password\");\n\nif (username.equals(\"admin\") && password.equals(\"admin\")) {\n    // Allow user to authenticate\n}",
      "remediation": "The most effective way to remediate CWE-287: Improper Authentication is to implement multi-factor authentication (MFA). This involves using two or more authentication factors to verify the identity of a user. The factors can include something the user knows (such as a password or PIN), something the user has (such as a security token or key fob), and something the user is (such as a biometric). By requiring the user to provide multiple forms of authentication, it makes it much more difficult for an attacker to gain unauthorized access.",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects improper authentication\"\n      author = \"security@example.com\"\n      id = \"CWE-287\"\n    strings:\n      $loginString = /login|authenticate/\n    condition:\n      $loginString\n}",
      "codeql_rule": "import java\n\nclass ImproperAuthentication extends SecurityCodeQL {\n \n  // Query to detect improper authentication\n  query improperAuthentication(){\n    // Find classes that implement authentication\n    Class authClass = find(\"java.util.concurrent.Callable\") \n    // Find methods that check for authentication\n    Method authMethod = authClass.getMethod(\"authenticate\")\n    // Find any calls to the authentication method\n    Call authCall = authMethod.getCalls()\n    where(authCall)\n  }\n\n}"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability in which an application or system stores and uses hard-coded credentials, such as usernames and passwords, instead of retrieving them from an external source. This vulnerability leaves the system vulnerable to attack because an attacker can easily gain access to the credentials if they know where to look. Hard-coded credentials can also cause an application to behave in unexpected ways, as the credentials might not be updated when they need to be.",
      "vulnerable_code": "String username = \"root\";\nString password = \"password123\";\n \nConnection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db\", username, password);",
      "remediation": "// Before \nString username = \"admin\";\nString password = \"password\";\n\n// After\nString username = System.getProperty(\"username\");\nString password = System.getProperty(\"password\");",
      "semgrep_rule": "rule = {\n  id = \"CWE798-hardcoded-credentials\",\n  pattern = \"<[^>]*(username|password|token|secret)[^>]*>\",\n  message = \"Found hardcoded credential(s)\",\n  severity = \"WARNING\"\n}",
      "codeql_rule": "import java\n\nclass CWE798HardcodedCredentialsVulnerability {\n  // Rule to detect the use of hardcoded credentials\n  // https://cwe.mitre.org/data/definitions/798.html\n \n  // Find all string literals\n  string strLiteral = /\".*\"/\n \n  // Find all string literals which are assigned to variables\n  string strLiteralAssignedToVar = strLiteral:Expr |\n                                  strLiteral:Expr[AssignExpr]\n \n  // Find all variables which are used as credentials\n  string credentialVariables = strLiteralAssignedToVar.lhs:Variable\n \n  // Find all methods which are used as credentials\n  string credentialMethods = credentialVariables.memberAccesses:Method\n \n  // Find all method invocations that use the credential"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 is a type of vulnerability where an application or system has incorrect default permissions set on files or directories, which can lead to unauthorized users or processes having access to those files or directories. This can lead to sensitive data or other resources being accessed, modified, or deleted without authorization. In some cases, this can also lead to privilege escalation or other malicious activities.",
      "vulnerable_code": "File file = new File(\"C:\\\\SecretFile.txt\");\nif(file.exists()) {\n    BufferedReader br = new BufferedReader(new FileReader(file));\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n    br.close();\n}\n\nThis code creates a file with default permissions that anyone with access to the system can read. This could lead to sensitive data being exposed if the file is not secured with the correct permissions.",
      "remediation": "// Remediation for incorrect default permissions\n\n// Set more restrictive default permissions \nPath path = Paths.get(\"filePath\");\nFiles.setPosixFilePermissions(path, PosixFilePermissions.fromString(\"rw-r-----\"));",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects incorrect default permissions\"\n      author = \"AuthorName\"\n      version = \"0.1.0\"\n    severity = \"WARNING\"\n    id = \"CWE-276\"\n    tags = [\"security\", \"cwe-276\", \"java\"]\n    confidence = \"HIGH\"\n    message = \"Incorrect default permissions detected\"\n   \n    source:\n      patterns:\n       - pattern: 'File.setReadable(true, false)'\n       - pattern: 'File.setWritable(true, false)'\n       - pattern: 'File.setExecutable(true, false)'\n       - pattern: 'File.setReadOnly()'\n      \n    false-positives:\n      - any\n \n    detection:\n      condition: all\n}",
      "codeql_rule": "// Finds classes with incorrect default permissions\nimport java\n\nclass IncorrectDefaultPermissions extends Query {\n  /**\n   * Finds classes with incorrect default permissions\n   */\n  predicate isVulnerableClass() {\n    // Finds classes with incorrect default permissions\n    cAccess = c.getAccess()\n    return cAccess.contains(java.Access.PRIVATE) or\n           cAccess.contains(java.Access.PROTECTED)\n  }\n\n  query vulnerableClasses() {\n    // Finds classes with incorrect default permissions\n    find class c \n    such that isVulnerableClass(c)\n  }\n}"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that can occur when sensitive information is exposed to an unauthorized actor. This can happen when an application fails to properly protect confidential information such as passwords, credit card numbers, Social Security numbers, or other sensitive data. An attacker may be able to access this information by exploiting weaknesses in the application's authentication, authorization, or encryption mechanisms. This type of vulnerability can lead to serious data breaches and financial losses.",
      "vulnerable_code": "String sensitiveData = \"This is sensitive data\";\nSystem.out.println(sensitiveData); // Exposes sensitive data to unauthorized actor",
      "remediation": "// Before Remediation\nFile file = new File(\"C:/Users/sensitive_data.txt\");\n\n// After Remediation\nString filePath = System.getProperty(\"user.home\") + \"/sensitive_data.txt\";\nFile file = new File(filePath);",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Exposure of Sensitive Information to an Unauthorized Actor\"\n    author = \"Author Name\"\n  strings:\n    $vuln_data = \"SECRET_DATA\"\n  condition:\n    $vuln_data\n}",
      "codeql_rule": "import cwe200\n\nclass CWE200Rule extends Query {\n  // Find any sensitive information exposed to an unauthorized actor\n  // through a method call or member access\n  vulnerableMethodCallOrMemberAccess() {\n    MethodCall m | MemberAccess m\n      // Check if the receiver of the method call or member access is\n      // an unauthorized actor\n      where CWE200.isUnauthorizedActor(m.getReceiver())\n  }\n  \n  // Find any sensitive information that is returned from the vulnerable method call or\n  // member access\n  sensitiveInformationReturned() {\n    MethodCall m\n      // Find the return type of the method call\n      let returnType := m.getType()\n      // Check if the return type contains sensitive information\n      where CWE200.containsSensitiveInformation(returnType)\n  }\n  \n  // Find any vulnerable method calls or"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a vulnerability which occurs when credentials, such as usernames and passwords, are stored in an insecure manner, making them vulnerable to malicious actors. This could occur if the credentials are stored in plain text, in an unencrypted file, or in a file that is accessible to unauthorized users. If a malicious actor gains access to the credentials stored in this manner, they can use them to gain access to the system or resources associated with them.",
      "vulnerable_code": "String username = \"admin\";\nString password = \"admin\";\n\n// Store credentials in plaintext\nString credentials = username + \":\" + password;\n\n// Store credentials to file\nFileWriter fileWriter = new FileWriter(\"credentials.txt\");\nfileWriter.write(credentials);\nfileWriter.close();",
      "remediation": "The following example shows how to remediate CWE-522 by using an encryption library to encrypt sensitive information before storing it in a database.\n\n//Encrypting sensitive information\npublic static void encryptData(String data) {\n\ttry {\n\t\tCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\tSecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n\t\tcipher.init(Cipher.ENCRYPT_MODE, keySpec);\n\t\tString encryptedData = Base64.encodeBase64String(cipher.doFinal(data.getBytes()));\n\t\t//Store the encrypted data in a database\n\t\t//..\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n}",
      "semgrep_rule": "rule = {\n    meta:\n        severity = \"medium\"\n        description = \"Insufficiently Protected Credentials\"\n    strings:\n        $user_id_string = /[A-Za-z0-9_]+/\n        $password_string = /[A-Za-z0-9_]+/\n    condition:\n        $user_id_string and $password_string\n}",
      "codeql_rule": "import cwe522\n\nclass InsufficientlyProtectedCredentialsVulnerability(cwe522.Vulnerability):\n  // Rule to detect code that stores credentials in plain text,\n  // without adequate protection\n  //\n  // Returns true if the given method stores credentials in plain text\n  // without adequate protection\n  predicate isVulnerableMethod(Method m) {\n    exists(\n      Field f,\n      Assignment a |\n        a.getLeft() = f &&\n        f.belongsTo(m) &&\n        f.getType() = \"String\" &&\n        a.getRight().contains(\"plaintext\")\n    )\n  }\n}"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a type of security vulnerability in which an XML parser is configured to allow the inclusion of external references, such as external document type definitions (DTDs) or external entities. This can result in an attacker being able to modify or gain access to sensitive data. For example, an attacker could craft an XML document with an external reference to a malicious entity that can be used to execute code or gain access to sensitive system resources.",
      "vulnerable_code": "// vulnerable code\nString xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \n              \"<!DOCTYPE foo SYSTEM \\\"http://example.com/evil.dtd\\\">\\n\" + \n              \"<foo>&entity;</foo>\";\n\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\nDocument doc = db.parse(new InputSource(xml));  // vulnerable code",
      "remediation": "// Remediation\nDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\nfactory.setXIncludeAware(false);\nfactory.setExpandEntityReferences(false);",
      "semgrep_rule": "rule = {\n    id: \"CWE-611-XML-External-Entity-Reference-Vulnerability\",\n    patterns: [\n        {\n            pattern: \"DocumentBuilderFactory.newInstance().newDocumentBuilder().parse($input)\",\n            message: \"Potential XML External Entity Reference Vulnerability. Consider using an XML parser that disables external entities.\",\n            severity: \"CRITICAL\",\n        }\n    ]\n}",
      "codeql_rule": "import java\n\nclass CWE611_ImproperRestrictionofXMLExternalEntityReference extends SecurityTest {\n    // Query to detect when an XML document is parsed and external entity references are enabled\n    def vulnerable = from xmlParser: java.xml.XMLParser,\n        source: java.io.InputSource\n    where xmlParser.isExpandEntityReferences() == true\n    select xmlParser, source\n\n    // Query to detect cases where the source is a file or URL\n    def vulnerableFileOrURL = \n        vulnerable.where(source.isFile() \n        or source.isURL())\n\n    // Final query to detect the vulnerability\n    vulnerableFileOrURL\n    report CWE611_ImproperRestrictionofXMLExternalEntityReference \n    \"Improper restriction of XML external entity reference\" \n    vulnerability vulnerableFileOrURL\n}"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-Side Request Forgery (SSRF) is a type of security vulnerability that occurs when an attacker is able to manipulate a web application into making a malicious request to a third-party server. This can be done by submitting malicious data to the application, which is then used to construct a request to an external server. The attacker can then gain access to sensitive information or launch further attacks. In Java, SSRF vulnerabilities can be caused by insecure handling of user-supplied data, such as user input that is not properly validated or sanitized.",
      "vulnerable_code": "URL url = new URL(\"http://attacker.example.com/\");\nHttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\nInputStream in = urlConnection.getInputStream();",
      "remediation": "The most effective way to remediate SSRF vulnerabilities is to validate all user-supplied URLs and reject any requests that do not match a predefined list. For example, in Java code:\n\n// Create a list of allowed URLs\nList<String> allowedURLs = new ArrayList<String>();\nallowedURLs.add(\"http://example.com/validUrl\");\nallowedURLs.add(\"ftp://example.com/validUrl\");\n\nString userSuppliedUrl = getUserSuppliedUrl();\n\n// Validate the URL\nif (allowedURLs.contains(userSuppliedUrl)) {\n    // Process the request\n    // ...\n} else {\n    // Reject the request\n    // ...\n}",
      "semgrep_rule": "rule = {\n  id: \"cwe-918-detection\",\n  patterns: [\n    // Detects suspicious requests to internal services\n    {\n      pattern: \"%{url_scheme}:%{url_host}:%{url_port}\",\n      message: \"Detected suspicious request to an internal service\",\n      severity: \"MEDIUM\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass ServerSideRequestForgery extends Vulnerability {\n  // Rule to detect Server Side Request Forgery\n  // CWE-918\n \n  // Query for all methods that take a URL string as a parameter\n  // and make a request to that URL\n  query vulnerableMethodInvocation {\n    // Find the method declaration\n    MethodDecl decl\n    MethodInvocation invok\n    where invok.method = decl\n    // Check the parameter type of the method\n    and decl.getParameters()[0].getType().toString() = \"java.net.URL\"\n    // Check the method is making an HTTP request\n    and exists(ClassType ct, MethodDecl md |\n      ct.getMethods()[] = md\n      and md.getName() = \"openConnection\"\n      and md.getClassType().toString() = \""
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "CWE-077 occurs when user input is not sufficiently sanitized before being used in system commands, allowing an attacker to inject malicious commands into a program. This can lead to attackers gaining access to sensitive data, executing arbitrary code, or changing system configurations. In order for this vulnerability to be successful, the attacker must be able to inject commands into the application without being detected.",
      "vulnerable_code": "String userInput = request.getParameter(\"command\");\nRuntime.getRuntime().exec(userInput);",
      "remediation": "One way to remediate CWE-077 Command Injection vulnerabilities is to properly sanitize user input to ensure that only valid characters are accepted. For example, you can use a whitelist approach to validate user input.\n\nBelow is an example of how to use a whitelist to validate user input in Java:\n\nString input = request.getParameter(\"userInput\");\nString validCharacters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nif (input.matches(\"[\" + validCharacters + \"]+\")) {\n    // The input is valid, proceed as normal\n    // ...\n} else {\n    // The input is invalid, throw an exception\n    throw new IllegalArgumentException(\"Invalid input\");\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-077-detect\",\n  patterns: [\n    {\n      pattern: \"eval(${parameter:StringLiteral} + \\\"${command:StringLiteral}\\\")\",\n      message: \"Vulnerable to CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')\",\n      severity: \"CRITICAL\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe077\n\nclass CWE077_Improper_Command_Injection extends SecurityCodeScanRule {\n    // Rule to detect command injection vulnerabilities\n    // https://cwe.mitre.org/data/definitions/77.html\n   \n    // Find any calls to the ProcessBuilder class\n    ProcessBuilder builderCall = findConstructor(\"java.lang.ProcessBuilder\", _);\n    \n    // Find any calls to the constructor of the ProcessBuilder class\n    // that pass in a command as an argument\n    ProcessBuilder commandCall = findConstructor(\"java.lang.ProcessBuilder\", _, stringLiteral);\n    \n    // Flag any calls to the ProcessBuilder constructor that\n    // pass in a command as an argument\n    // as a potential command injection vulnerability\n    flag(commandCall, cwe077.getDescription());\n}"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295 is a vulnerability that occurs when a program fails to properly validate digital certificates. This can allow attackers to spoof the identity of a trusted server or client, enabling them to intercept and modify data, launch man-in-the-middle attacks, or spoof a legitimate user\u2019s identity. This can result in a variety of security issues, such as malicious code execution, data alteration, and more. Common causes of this vulnerability include improperly configured trust stores, missing or incorrect certificate validation procedures, and weak or outdated encryption algorithms.",
      "vulnerable_code": "String url = \"https://example.com/\"; \nURLConnection con = new URL(url).openConnection(); \nHttpsURLConnection httpsCon = (HttpsURLConnection) con; \n\n// Skip certificate validation \nhttpsCon.setHostnameVerifier(new HostnameVerifier() {\n    @Override \n    public boolean verify(String s, SSLSession sslSession) {\n        return true;\n    } \n}); \n\n// Make the connection \nhttpsCon.connect();",
      "remediation": "The following code demonstrates a remediation for CWE-295: Improper Certificate Validation. The code sets up a TrustManager that checks the validity of an X.509 certificate chain presented by a server.\n\n// Create a TrustManager that validates X.509 certificate chains\nTrustManager[] trustAllCerts = new TrustManager[] {\n    new X509TrustManager() {\n        public X509Certificate[] getAcceptedIssuers() {\n            return null;\n        }\n\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {\n        }\n\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {\n            for (X509Certificate cert : certs) {\n                try {\n                    cert.checkValidity();\n                } catch (CertificateExpiredException | CertificateNotYetValidException e) {\n                    throw new CertificateException",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tauthor = \"anonymous\"\n\t\tdescription = \"Detects potential improper certificate validation\"\n\t\tid = \"CWE-295\"\n\t\tseverity = \"high\"\n\t\ttags = [\"security\", \"certificate-validation\"]\n\t\n\tsource: \n\t\texclude = [\"java.net.URLConnection\", \"javax.net.ssl.HttpsURLConnection\"]\n\t\n\tstrings:\n\t\t$checkCert = /(?i)(?:checkServerTrusted|verify|validate)(?:Certificate|Server|Host)/\n\t\n\tconditions:\n\t\t$checkCert\n}",
      "codeql_rule": "import cwe295\nimport java\n\nclass ImproperCertificateValidation implements Cwe295 {\n    // Rule to detect improper certificate validation\n    // vulnerabilities\n    //\n    // References:\n    //   https://cwe.mitre.org/data/definitions/295.html\n    //\n    // Severity: Critical\n    \n    // Find all calls to X509TrustManager.checkServerTrusted\n    X509TrustManager.checkServerTrusted(...) {\n        // Find calls that do not provide a valid certificate chain\n        not validCertChain {\n            // Flag the call as a CWE-295 vulnerability\n            cwe295.report(\"Improper certificate validation detected.\")\n        }\n    }\n}"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability that occurs when input data is not correctly sanitized or validated before it is used to generate executable code. This can occur when user input is used in a code generation process, such as when user input is used to generate SQL code or when user input is used to generate HTML code. If the input is not sanitized or validated, an attacker can inject malicious code into the generated code and execute it. This can lead to serious security issues, such as data theft, data manipulation, and system compromise.",
      "vulnerable_code": "// This code allows a user to input an SQL query \n// which is then executed on a database.\nString userInput = request.getParameter(\"userInput\");\nString query = \"SELECT * FROM table WHERE \" + userInput;\nStatement stmt = connection.createStatement();\nResultSet rs = stmt.executeQuery(query);",
      "remediation": "// Remediation Example\npublic String sanitizeInput(String input) {\n    String sanitizedInput = input.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n    return sanitizedInput;\n}",
      "semgrep_rule": "rule = {\n    meta:\n      code = \"CWE-094\"\n      description = \"Improper Control of Generation of Code ('Code Injection')\"\n    strings:\n      $expr_exec = /\\b(eval|assert|exec|execfile|executemany|load_source|compile|eval_js|eval_fn|exec_js|exec_fn|spawn|system|popen|popen2|popen3)\\b/\n    condition:\n      any of ($expr_exec)\n}",
      "codeql_rule": "import cwe094\n\nfrom CodeElement c\nwhere c.kind = \"METHOD\"\nand c.containsCall(\"java.lang.Runtime.exec(String)\")\n\nselect c, \"Improper control of code generation detected\"\n\nrule CWE_094_Detection {\n \n  // Find calls to java.lang.Runtime.exec(String)\n  // which may indicate improper control of code generation\n \n  pattern {\n    Call c;\n    c.target:Method m;\n    m.name = \"exec\" and m.owner.name = \"java.lang.Runtime\";\n    c.args[0]:StringLiteral s;\n  }\n  \n  // Run the CWE-094 checker on the call\n \n  checker {\n    cwe094.check(c,s);\n  }\n}"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 Improper Privilege Management is a vulnerability that occurs when an application does not properly manage privileges, allowing unauthorized access to certain areas of the application or granting too much access to certain users. This could allow malicious users to access sensitive data, modify or delete data, or perform other unauthorized operations. It could also lead to elevation of privilege attacks, in which a user is granted privileges beyond what they normally should have access to.",
      "vulnerable_code": "public class VulnerableClass {\n    private int accessLevel = 0;\n\n    public void setAccessLevel(int level) {\n        accessLevel = level;\n    }\n\n    public void doSomething() {\n        if (accessLevel > 0) {\n            // Perform privileged operations\n        }\n    }\n}\n\nIn this code, the access level is set without any input validation. This means a malicious user can set the access level to any value, bypassing the privilege checks and gaining access to privileged operations. This is a vulnerability due to improper privilege management.",
      "remediation": "Example:\n\n1. Assign roles and privileges to each user, clearly defining what they are allowed to do with the system.\n\n2. Create a system of user account monitoring, logging and reporting to detect any unauthorized activity.\n\n3. Implement a system of password management, ensuring that passwords are changed frequently, are complex and not shared among users.\n\n4. Implement access control mechanisms such as authentication, authorization and encryption to protect data from unauthorized access.\n\n5. Implement a policy that requires users to be trained on security best practices and to update their knowledge regularly.\n\n6. Once privileges have been assigned to a user, monitor and review those privileges to ensure that they are still appropriate for the user's role.",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects improper privilege management\"\n      author = \"Your Name\"\n      id = \"CWE-269\"\n    source:\n      lang = \"java\"\n    detection:\n      condition: any\n      for-each:\n        pattern:\n          - 'PrivilegedAction.doPrivileged(.*)'\n       within:\n        - 3\n       patterns:\n        - \"'checkPermission(.*)'\"\n        - \"'AccessController.checkPermission(.*)'\"\n}",
      "codeql_rule": "import cwe269\n\nclass CWE269ImproperPrivilegeManagement extends Rule {\n  // Detects improper privilege management\n  vulnerability {\n    // Finds improper privilege management\n    CWE269.IncorrectPrivilegeManagement()\n  }\n  \n  // Reports the vulnerability\n  defer = CWE269.IncorrectPrivilegeManagement() {\n    // Report the vulnerability\n    report(\"Improper privilege management detected.\")\n  }\n}"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "Expression Language Injection (CWE-917) is a type of injection vulnerability that occurs when an application uses an expression language to evaluate user-supplied input. This can allow an attacker to inject malicious code into the application which can then be executed. Expression language injection can occur in Java applications when user-supplied input is used in the expression language statements, such as when using the JavaServer Pages (JSP) language. This can allow an attacker to inject malicious code into the application, such as executing arbitrary system commands. This can result in the application being compromised and data being compromised.",
      "vulnerable_code": "String username = request.getParameter(\"username\");\nString password = request.getParameter(\"password\");\nString query = \"SELECT * FROM users WHERE username='\" + username + \"' AND password='\" + password + \"'\";\nStatement stmt = con.createStatement();\nResultSet rs = stmt.executeQuery(query);\n\nThis code is vulnerable to expression language injection because it takes an unvalidated parameter from a user input and directly inserts it into a query string. An attacker could inject malicious code into the query string, which would be executed on the database server.",
      "remediation": "In order to remediate CWE-917, input validation should be performed on user input before the data is processed by the application. For example, if an application is using the Java Expression Language (EL), the following code could be used to validate user input against a whitelist of acceptable characters before it is evaluated as an EL expression:\n\nString userInput = request.getParameter(\"userInput\");\nString regex = \"^[a-zA-Z0-9_\\\\-\\\\.\\\\(\\\\)]*$\";\nif (!userInput.matches(regex)) {\n    throw new IllegalArgumentException(\"Invalid characters found in user input\");\n}\n// Now evaluate the user input as expression language\nObject result = expression.getValue(userInput);",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects potential Expression Language Injection vulnerabilities\"\n      authors = [\"Your Name\"]\n      references = [\"https://cwe.mitre.org/data/definitions/917.html\"]\n    strings:\n       $el_func = /\\$\\{.*\\(/\n    condition:\n       $el_func\n}",
      "codeql_rule": "import java\n\nclass ExpressionLanguageInjection implements Rule {\n  // Check for potential Expression Language Injection vulnerabilities\n  // in Java code\n \n  // Finds all EL expressions in the code\n  private Expr elExpression = Expr.regex(\"\\\\$\\\\{[^\\\\}]+\\\\}\");\n  \n  // Finds all potential EL expression injection points\n  private Expr elExpressionInjectionPoint = Expr.select(CallExpr.class,\n    \"callExpr\",\n    (CallExpr callExpr) =>\n      callExpr.getTarget().getName() == \"setAttribute\"\n      and callExpr.getArgument(1).matches(elExpression)\n  );\n  \n  // Checks if there are any potential EL expression injection points\n  // without proper input sanitization\n  private Query elExpressionInjectionQuery ="
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability that occurs when a program fails to properly validate or sanitize links before following them. This results in the program accessing files or resources that are not supposed to be accessed, potentially leading to data leakage, information disclosure, or other security risks. This vulnerability can be exploited by malicious actors who craft malicious links or modify existing links to point to unexpected resources.",
      "vulnerable_code": "File file = new File(\"../../etc/passwd\");\nBufferedReader br = new BufferedReader(new FileReader(file));\nString line;\nwhile ((line = br.readLine()) != null) {\n    System.out.println(line);\n}\nbr.close();\n\nThe code above is vulnerable to CWE-059 because it uses a relative path to access the file, which can be manipulated by an attacker to access files outside of the intended directory. For example, an attacker could traverse up the directory tree to access the \"/etc/passwd\" file, which is not the intended file. To prevent this vulnerability, the code should specify an absolute path to the file.",
      "remediation": "// Before\nString fileName = \"/etc/passwd\"\nFile file = new File(fileName);\n\n// After\nString fileName = \"/etc/passwd\"\nif (Paths.get(fileName).isAbsolute()) {\n    File file = new File(fileName);\n} else {\n    throw new IllegalArgumentException(\"Path is not absolute\");\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper link resolution before file access\"\n    author = \"Security team\"\n    date = \"2020-10-05\"\n  strings:\n    $func_name = /(File|Path).(toRealPath|resolve)/\n  condition:\n    $func_name\n}",
      "codeql_rule": "import java\n\nclass ImproperLinkResolution extends SecurityCodeScannerRule {\n  // Matches an expression that resolves to a file path\n  // and is passed as an argument to a File constructor\n  // or a method that triggers file access.\n  private Expr getFilePathExpr(Expr baseExpr) {\n    Expr filePathExpr = baseExpr;\n    while (filePathExpr instanceof Expr.BinaryOp) {\n      Expr.BinaryOp binaryOpExpr = (Expr.BinaryOp) filePathExpr;\n      if (binaryOpExpr.op == BinaryOp.PLUS) {\n        filePathExpr = binaryOpExpr.getRightOperand();\n      } else {\n        break;\n      }\n    }\n    return filePathExpr;\n  }\n\n  // Checks that a given expression"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information is transmitted over an unsecure network connection in plaintext (cleartext). This means that the data can be intercepted and viewed by anyone with access to the network, creating a potential security risk. In the case of Java applications, this can occur if the application is set up to send data in plaintext instead of using encryption protocols such as SSL/TLS. This can expose the data to anyone who is monitoring the network and can lead to the theft of sensitive information or other malicious activities.",
      "vulnerable_code": "String username = \"user\";\nString password = \"password\";\n\nURL url = new URL(\"http://example.com/login\");\nHttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\nconnection.setRequestMethod(\"POST\");\n\nString urlParameters = \"username=\" + username + \"&password=\" + password;\n\nconnection.setDoOutput(true);\nDataOutputStream wr = new DataOutputStream(connection.getOutputStream());\nwr.writeBytes(urlParameters);\nwr.flush();\nwr.close();\n\nint responseCode = connection.getResponseCode();",
      "remediation": "// Before\nString url = \"http://example.com/data.json\";\n\n// After\nString url = \"https://example.com/data.json\";",
      "semgrep_rule": "rule = {\n  severity = \"warning\"\n  id = \"CWE-319-cleartext-transmission\"\n  pattern = \"(?i)\\\\b((?:http|ftp|https):\\\\/\\\\/)?[\\\\w\\\\d\\\\-_]+\\\\.(?:[\\\\w\\\\d\\\\-_]+\\\\.)*[\\\\w\\\\d\\\\-_]+\\\\b\"\n  message = \"Cleartext transmission of sensitive information\"\n}",
      "codeql_rule": "import cwe319\n\nclass CWE319CleartextTransmissionOfSensitiveInformation : CodeQL\n\n{ \n  // Find all parameters of a method that contain sensitive information\n  // and are transmitted in cleartext\n  ClassDecl cls\n  MethodDecl m\n\n  // Look for methods that contain parameters containing sensitive information\n  ParameterDecl sensitiveParam\n  sensitiveParam.getAncestors() += {m}\n\n  // Look for methods that transmit data in cleartext\n  // over the network\n  MethodInvocation mInv\n  mInv.getAncestors() += {m}\n  mInv.getTarget().getName() = \"send\"\n  mInv.getTarget().getDeclaringType().getName() = \"java.net.Socket\"\n\n  // Check if the sensitive data is being sent over the network\n  // in cleartext\n  exists (Parameter"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 is a vulnerability that allows an attacker to redirect a user from a legitimate website to an untrusted website. This can be done by providing a malicious URL within a link or redirect code that points to the malicious website. This is a dangerous vulnerability because it allows attackers to steal sensitive information from users, such as passwords, credit card numbers, and other personal data. A successful attack can also lead to the installation of malicious software on the user's computer. In Java, this vulnerability can be exploited by manipulating URL parameters and redirecting the user to a malicious website.",
      "vulnerable_code": "// This code redirects the user to a URL specified in the request parameter \"url\"\nString url = request.getParameter(\"url\");\nresponse.sendRedirect(url);",
      "remediation": "// Before Remediation\nresponse.sendRedirect(request.getParameter(\"url\"));\n\n// After Remediation\nString url = request.getParameter(\"url\");\nif (url != null && url.startsWith(\"https://www.example.com\")) {\n    response.sendRedirect(url);\n}",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tdescription = \"Detects CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\"\n\t\tauthor = \"Semgrep Security\"\n\t\tdate = \"2020-08-30\"\n\t\tseverity = \"MEDIUM\"\n\t\ttags = [\"CWE-601\", \"Open Redirect\"]\n\t\t\n\t\t\n\t// Detects potential open redirects\n\t// Checks for calls to redirect() using untrusted input\n\t// as destination URL\n\t\n\tstrings:\n\t\t$redirect_func = /redirect\\s*\\(/\n\t\t$url_param = /[^\\s]*\\$\\w+/\n\t\n\texpressions:\n\t\t$redirect_func @url_param\n}",
      "codeql_rule": "import java\n\nclass OpenRedirectVulnerability extends Vulnerability {\n  /**\n   * Finds instances of open redirection\n   */\n  OpenRedirectVulnerability() {\n    super(\"Open Redirection\");\n  }\n\n  // Find code that sets the location of an HTTP response\n  // to a value provided by an external source\n  @FindMethods(\"java.net.HttpURLConnection#setRequestProperty\")\n  pred setResponseLocationFromExternalSource(java.net.HttpURLConnection httpConn) {\n    exists(String externalSourceValue |\n      httpConn.setRequestProperty(\"Location\", externalSourceValue)\n  }\n\n  // Issue a warning when the external source value is used as the location\n  // of the response\n  @Warning(\"Open Redirection vulnerability\")\n  warn onOpenRedirect(java.net.HttpURLConnection httpConn) {\n    setResponseLocationFromExternal"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability that occurs when sensitive information, such as passwords, credit card numbers, or personal data, is inadvertently inserted into a log file. This information is then stored in the log file, and may be accessed by an attacker if the log file is not properly protected. Attackers can then use this information to gain access to the system, or to commit fraud or identity theft.",
      "vulnerable_code": "try {\n    String sensitiveData = \"password123\";\n\n    // Perform some action\n    // ...\n\n    // Write sensitive data to log file\n    FileWriter writer = new FileWriter(\"logs.txt\");\n    writer.write(sensitiveData);\n    writer.close();\n} catch (Exception e) {\n    e.printStackTrace();\n}",
      "remediation": "// Prevent insertion of sensitive information into log file\npublic static void logMessage(String message) {\n    // Remove any sensitive information from the message\n    message = message.replaceAll(\"(^|\\\\W)(password|credit card|ssn)(\\\\W|$)\", \"***\");\n    \n    // Log the sanitized message\n    logger.info(message);\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects insertion of sensitive information into log file\"\n    author = \"Your Name\"\n    date = \"2020-07-01\"\n  strings:\n    $log_entry = /.*/\n    $sensitive_data = /(password|credit card|social security number|account number|health record)/\n  condition:\n    $log_entry contains $sensitive_data\n}",
      "codeql_rule": "import java\n\nclass InsertionOfSensitiveInformationIntoLogFile extends SecurityCodeRule {\n \n  InsertionOfSensitiveInformationIntoLogFile() {\n    super(\"InsertionOfSensitiveInformationIntoLogFile\");\n  }\n \n  @Override\n  public RuleMatch[] match(Trace trace) {\n    List<RuleMatch> matches = new ArrayList<>();\n \n    // Check for code that writes sensitive information to a log file\n    Collection<MethodCall> calls = trace.getNodes(MethodCall.class);\n    for (MethodCall call : calls) {\n        // Check for calls to logging methods\n        if (call.getTarget().matches(\"java.util.logging.Logger.log*\") ||\n            call.getTarget().matches(\"org.slf4j.Logger.log*\") ||\n            call."
    }
  },
  "Python": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of security vulnerability that occurs when an attacker injects malicious code into a web application. This malicious code can be a script, HTML, or other types of code that can be executed by the browser. If the code is not filtered or sanitized, it can be used to manipulate the application\u2019s data or steal confidential information from users, such as usernames and passwords. XSS is a particularly dangerous vulnerability because it can be used to launch more complex attacks, such as distributed denial of service (DDoS) attacks, phishing scams, and malware distribution.",
      "vulnerable_code": "def vulnerable_function(user_input):\n    page_content = \"<html><body>User input: %s</body></html>\" % user_input\n    return page_content\n\n# This code is vulnerable to cross-site scripting, if the user_input is not properly sanitized and filtered. \n# For example, if the user input is \"<script>alert('XSS')</script>\", the output page will contain the malicious script.",
      "remediation": "# Remediation example\n\ndef sanitize_input(user_input):\n    # Strip any HTML/JavaScript tags\n    user_input = re.sub(r'<[^>]*>', '', user_input)\n    \n    # Escape HTML characters\n    user_input = html.escape(user_input)\n    \n    # Return the sanitized input\n    return user_input",
      "semgrep_rule": "rule = {\n  id: \"CWE-079-detection\",\n  patterns: [\n    {\n      pattern: \"{print,echo,printf,sprintf}.*(?P<input>\\$_[A-Z_]*\\[['\\\"](.*)['\\\"]\\]|\\$_[A-Z_]*\\{['\\\"](.*)['\\\"]\\})\",\n      message: \"Potential Cross-site Scripting detected: input from ${input} may not be properly sanitized before being used in a web page.\",\n      severity: \"WARNING\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe79\n\nclass Cwe79CrossSiteScriptingRule extends Rule {\n  // Create a query to detect the vulnerability\n  query vulnerable_code() {\n    // Look for web page generation code\n    WebPageGenerationCode webPageGenCode\n    where webPageGenCode.containsVulnerableCode()\n  }\n\n  // Check for improper neutralization of user input\n  predicate containsVulnerableCode() {\n    // Look for user input being passed to the web page generation code\n    exists(UserInput ui)\n    such that ui.isPassedTo(WebPageGenerationCode.allInstances())\n    // Check if the input is properly neutralized\n    and not cwe79.isNeutralized(ui)\n  }\n}"
    },
    "CWE-020: Improper Input Validation": {
      "description": "Improper input validation is a vulnerability that occurs when an application does not properly validate user input before passing it to a system or application. This can be exploited by malicious users to inject malicious code or data into the system, leading to security issues such as buffer overflows, cross-site scripting, and SQL injection attacks. Improper input validation can also allow attackers to bypass authentication and authorization checks, allowing them to gain access to sensitive data or perform malicious actions.",
      "vulnerable_code": "def add_user(username, password):\n    # add username and password to database\n    query = \"INSERT INTO users (username, password) VALUES ('{}', '{}')\".format(username, password)\n    cursor.execute(query)\n\n# Vulnerable code\nquery = \"INSERT INTO users (username, password) VALUES ('{}', '{}')\".format(username, password)\ncursor.execute(query)\n\n# Unsanitized input is being used in the query, which can lead to SQL injection attacks.\n# Proper input validation should be used to prevent malicious input from being used.\nquery = \"INSERT INTO users (username, password) VALUES (?, ?)\"\ncursor.execute(query, (username, password))",
      "remediation": "def validate_input(input):\n  if not input.isalpha():  # Check if input is alphabetic\n    raise ValueError('Input must be alphabetic only')\n  return input # If input is valid, return it",
      "semgrep_rule": "rule = {\n  id: \"CWE-020-Improper-Input-Validation\",\n  pattern: \"input[*] not in __import__('whitelist')\",\n  message: \"Input validation is not properly enforced.\",\n  severity: \"error\"\n}",
      "codeql_rule": "import cwe\n\nclass CWE020ImproperInputValidation:\n  // Checks for functions that do not validate user input\n  // and adds the input directly to a database query\n  // without any sanitization.\n \n  @Name(\"CWE-020: Improper Input Validation\")\n  @CWE(cwe.CWE_020)\n \n  def vulnerable(Function func) {\n    // Find all calls to database query functions\n    QueryCall queryCall = func.getCallees().select(QueryCall)\n \n    // Find all user input variables\n    Variable inputVar = queryCall.getArgs().select(Variable).where(isUserInput)\n \n    // Check if the user input is not sanitized\n    Sanitize sanitize = queryCall.getCallees().select(Sanitize).where(sanitize.getInput()"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of security vulnerability that occurs when an attacker is able to inject malicious commands into an operating system (OS) command. These malicious commands can be used to modify, delete or even execute files on the target system. This type of attack is easy to carry out, as it requires only an injection of a single command into an application. The vulnerability is enabled when user inputs are not properly sanitized, allowing malicious code to be executed on the system.",
      "vulnerable_code": "import os\n\n#Vulnerable code\nuser_input = input(\"Enter a command: \")\nos.system(user_input)",
      "remediation": "import subprocess\n\ndef execute_command(cmd):\n    # We create an array with the command and its parameters\n    command = cmd.split()\n    # We use subprocess.call to execute the command\n    subprocess.call(command)\n\n# We call execute_command to execute a command\nexecute_command(\"ls -l\")",
      "semgrep_rule": "rule = {\n\tid: \"CWE-078-OS-Command-Injection\",\n\tpattern: {\n\t\tanyWith: {\n\t\t\tcode: /system\\(|exec\\(|popen\\(|shell_exec\\(|`/\n\t\t\tall: [\n\t\t\t\t{\n\t\t\t\t\t// Verify that the command is not hardcoded\n\t\t\t\t\tnot: {\n\t\t\t\t\t\tcode: /\"|'/,\n\t\t\t\t\t\tanyWith: {\n\t\t\t\t\t\t\tcode: /system\\(|exec\\(|popen\\(|shell_exec\\(|`/\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t// Verify that user input is not directly passed to",
      "codeql_rule": "import cwe\nimport os\n\nclass OsCommandInjection(cwe.Vulnerability):\n    def __init__(self):\n        self.id = 78\n        self.severity = \"High\"\n        self.title = \"Improper Neutralization of Special Elements used in an OS Command\"\n        self.description = \"The application fails to properly neutralize special elements used in an OS command, allowing attackers to execute arbitrary code.\"\n \n    def getVulnerabilityName(self):\n        return self.title\n \n    def getVulnerabilityId(self):\n        return self.id\n \n    def getSeverity(self):\n        return self.severity\n \n    def detect(self, qctx):\n        # search for call to \"os.system\" without proper sanitization\n        qctx.for_stmt(\"$cmd\", \"\"\"\n            ExprSt"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "SQL injection is a type of security vulnerability that occurs when malicious code is inserted into an SQL query through user input. This can allow attackers to gain access to restricted databases, modify or delete data, or even execute system commands. Attackers can use this vulnerability to gain unauthorized access to sensitive data or execute malicious code on the server.",
      "vulnerable_code": "import sqlite3\n\n# Variable user_input is obtained from the user\nuser_input = \"admin'\"\n\n# Establish a connection to the SQLite database\nconnection = sqlite3.connect(\"database.db\")\n\n# Create a cursor object\ncursor = connection.cursor()\n\n# Execute the SQL query\ncursor.execute(\"SELECT username FROM users WHERE username = '\" + user_input + \"'\")\n\n# Fetch the results of the query\nresults = cursor.fetchall()\n\n# Close the connection\nconnection.close()\n\n# Print the results\nprint(results)",
      "remediation": "# Remediation code example\n\n# Sanitize user input to prevent SQL injection\ndef sanitize_inputs(user_input):\n    # Strip all special characters\n    input_sanitized = re.sub('[^\\w]', '', user_input)\n    \n    # Escape all apostrophes\n    input_sanitized = input_sanitized.replace(\"'\", \"''\")\n    \n    return input_sanitized\n\n# Use sanitized user input in SQL query\nsql_query = \"SELECT * FROM users WHERE username = '{}'\".format(sanitize_inputs(user_input))\n\n# Execute query\ncursor.execute(sql_query)",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects SQL injection vulnerabilities\"\n    id = \"CWE-089\"\n    severity = \"CRITICAL\"\n  strings:\n    $sql = /.*(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP|ALTER|EXECUTE).*/ \n    $special = /.*('|\"|;|\\||--|#|%|&|\\*|\\+|=|\\\\).*/\n  condition:\n    any of them\n}",
      "codeql_rule": "import python\n\nclass SqlInjectionVulnerability(Vulnerability):\n    def __init__(self):\n        super().__init__()\n        \n    def vulnerable_function(self, func):\n        return func.has_name(\"execute\") and func.has_return_type(python.VoidType)\n    \n    def predicate(self, q):\n        vulnerable_functions = select(f for f in python.Functions if self.vulnerable_function(f))\n        vulnerable_calls = select(c for c in python.Calls if c.get_function().in(vulnerable_functions))\n        return exists(vulnerable_calls, lambda c: c.has_argument_with_string_literal_contains_sql_keyword(q))\n\nrule SqlInjectionVulnerability\n    when SqlInjectionVulnerability()"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal is a type of vulnerability that occurs when an attacker can gain access to files and directories that are stored outside the intended directory. This can happen when a web application allows user-supplied input, such as a file name or a directory, to be used without proper validation. If the application does not properly validate the user-supplied input, the attacker may be able to traverse the file system to access files and directories that are outside of the intended directory. This can lead to unauthorized access to sensitive information or even system compromise.",
      "vulnerable_code": "# This code is vulnerable to CWE-022\n\nfile_name = request.GET('file_name')\n\n# Open the file\nwith open(file_name, 'r') as f:\n    # Read the contents of the file\n    contents = f.read()",
      "remediation": "# Before\nfilename = request.form.get('filename')\nf = open(filename, 'r')\n\n# After\nfilename = os.path.basename(request.form.get('filename'))\nf = open(os.path.join(allowed_directory, filename), 'r')",
      "semgrep_rule": "rules:\n  - id: PATH_TRAVERSAL\n    severity: critical\n    patterns:\n    - pattern: 'open(.*?[\\\\/][.][.][\\\\/])'\n      message: 'Possible Path Traversal vulnerability detected'\n    filters:\n    - 'open'",
      "codeql_rule": "import cwe\n\nclass PathTraversalVulnerability(cwe.Vulnerability):\n    def __init__(self):\n        self.id = \"CWE-022\"\n        self.name = \"Path Traversal Vulnerability\"\n        self.description = \"Improper limitation of a pathname to a restricted directory allows attackers to gain access to resources that should not be publicly available.\"\n        self.severity = cwe.Severity.HIGH\n        self.cwe_id = \"CWE-022\"\n        self.references = [\"https://cwe.mitre.org/data/definitions/22.html\"]\n        \n    def check(self, qg):\n        # Look for cases where a user-controlled input is used as a pathname\n        return qg.query(\"\"\"\n            // Check for user-controlled input\n            let user_controlled"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-Site Request Forgery (CSRF) is a type of attack in which an attacker tricks a user into performing unwanted actions on a web application in which the user is currently authenticated. The attacker does this by sending a malicious request from a trusted website or application to the vulnerable web application. This malicious request will appear to the web application as if it originated from the user's own browser, and the web application will process the request as if it were a legitimate request. This can result in the attacker gaining access to sensitive data or the ability to perform unauthorized actions on the vulnerable web application.",
      "vulnerable_code": "import flask\n\napp = flask.Flask(__name__)\n\n@app.route('/update_user', methods=['POST'])\ndef update_user():\n    # get data from form\n    user_data = flask.request.form\n    \n    # update user_data in database\n    db.update_user(user_data)\n    return 'User data updated!'\n\nThe above code is vulnerable to a CSRF attack, as it does not have any sort of CSRF token verification, or any sort of user authentication. An attacker could send a malicious POST request to the '/update_user' route, and update data in the database without the user's knowledge.",
      "remediation": "# Create a CSRF token\ndef generate_csrf_token():\n    csrf_token = uuid.uuid4().hex\n    session['csrf_token'] = csrf_token\n    return csrf_token\n\n# Check if the csrf token is valid\ndef csrf_protection(request):\n    token = session.get('csrf_token')\n    if not token or token != request.form.get('csrf_token'):\n        abort(403)",
      "semgrep_rule": "rule = {\n  id: \"CWE-352-Detection\",\n  patterns: [\n    {\n      pattern: \"http.request(param: *, method: 'POST')\",\n      message: \"Potential Cross-Site Request Forgery (CSRF) vulnerability detected\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe352\n\nfrom BaseNode import *\nfrom HTTPRequest import *\n\nclass CWE352CrossSiteRequestForgeryRule(Rule):\n    def __init__(self):\n        Rule.__init__(self, name=\"CWE352CrossSiteRequestForgeryRule\",\n        target=HTTPRequest,\n        severity=\"CRITICAL\")\n    \n    def evaluate(self, target):\n        if (target.method == \"POST\"):\n            if not target.has_csrf_protection():\n                return Report(cwe=cwe352.id,\n                confidence=\"HIGH\")"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a type of vulnerability that allows an attacker to upload files of a dangerous type onto a web application without any restrictions. This can lead to malicious code being executed on the server, which can cause data leakage, system access, or even more serious damage. The dangerous types of files can include .exe, .bat, .php, .js, and other files that can be used to execute malicious code. This vulnerability can be exploited by an attacker if the application does not have proper file type restrictions in place.",
      "vulnerable_code": "# The following code allows a user to upload any type of file to the server\n\n@app.route(\"/upload\", methods=[\"POST\"])\ndef upload_file():\n    file = request.files['file']\n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return redirect(url_for('uploaded_file',\n                                filename=filename))\n\n# The code does not check the type of file being uploaded, allowing users to upload malicious files.",
      "remediation": "# Sanitizing File Uploads\n\ndef sanitize_file_upload(file):\n  # Get the file type\n  file_type = file.content_type\n  \n  # List of allowed file types\n  allowed_file_types = [\n    'image/jpeg',\n    'image/png',\n    'application/pdf',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n  ]\n  \n  # If the file type is not allowed, reject the file\n  if file_type not in allowed_file_types:\n    raise Exception('Unallowed file type')\n  \n  # Return the sanitized file\n  return file",
      "semgrep_rule": "rule = {\n  id: \"CWE-434-unrestricted-upload-file-dangerous-type\",\n  patterns: [\n    {\n      pattern: \"file_name = request.files.get(file_parameter)\",\n      qualifiers: [\"+\"]\n    },\n    {\n      pattern: \"file_name.filename\",\n      qualifiers: [\"+\"]\n    },\n    {\n      pattern: \"file_name.save(file_path)\",\n      qualifiers: [\"+\"]\n    }\n  ],\n  message: \"Possible unrestricted upload of file with dangerous type detected.\"\n}",
      "codeql_rule": "import cwe\nimport python\n\nclass UnrestrictedUploadofDangerousType(python.PythonRule):\n  def __init__(self):\n    super().__init__()\n    self.id = \"CWE-434\"\n    self.vuln_id = cwe.CWE434\n    self.severity = \"high\"\n    self.description = \"Unrestricted upload of file with dangerous type\"\n\n  def getQuery(self):\n    return \"\"\"\n      from FileUpload upload, FilePermission perm, Call call, \n      Function func, File filename\n      where upload.filePermission = perm \n      and upload.call = call\n      and call.callee = func\n      and perm.filename = filename\n      and filename.extension in {\"php\", \"asp\", \"cgi\"}\n      and upload.isSink\n      select upload, \"Un"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306: Missing Authentication for Critical Function is a vulnerability that occurs when an application fails to properly authenticate a user before allowing them to access a critical function. This can allow attackers to gain unauthorized access to sensitive data or perform certain actions that they would not normally have access to. Without proper authentication, malicious users could potentially bypass security controls and gain access to sensitive resources or perform actions that are not authorized.",
      "vulnerable_code": "def update_profile_info(user, info):\n    # code to update user profile information\n    # ...\n    user.profile.update(info)\n    user.save()\n\n# Vulnerable code - No authentication\nupdate_profile_info(user, info)",
      "remediation": "# Example code\n\n# Sanitize user input\ndef secure_input(user_input):\n    return re.sub(r'[^a-zA-Z0-9]', '', user_input)\n\n# Enforce authentication\ndef authenticate_user(user_input):\n    # Check if user is authenticated\n    if secure_input(user_input) == \u2018authenticated\u2019:\n        return True\n    else:\n        return False\n\n# Function that requires authentication\ndef critical_function(user_input):\n    # Check if user is authenticated\n    if authenticate_user(user_input):\n        # Execute critical function\n        # ...\n        return\n    else:\n        # Require authentication\n        print('You must authenticate first!')\n        return",
      "semgrep_rule": "rule = [{\n  \"id\": \"CWE-306\",\n  \"severity\": \"error\",\n  \"message\": \"Critical function is missing authentication\",\n  \"patterns\": [\n    {\n      \"regexp\": \"^(?!.*(auth|authenticate)).*critical_function.*$\"\n    }\n  ]\n}]",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.dataflow\n\nclass MissingAuthForCriticalFunction extends SecurityHardeningChecker {\n  // Check if the program calls a critical function without authentication\n  predicate isCriticalFunction(Function f) {\n    // Insert code here to determine if f is a critical function\n  }\n  \n  @Override\n  check(CallExpr call) {\n    if (call.getTarget().matches(isCriticalFunction) &&\n       !call.hasArgument(isAuthenticationCheck)) {\n      // Report the vulnerability\n      reportCWE(call, cwe.Missing_Authentication_for_Critical_Function);\n    }\n  }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability related to deserialization of untrusted data. This vulnerability occurs when a program deserializes data from an untrusted source without proper validation, allowing attackers to execute malicious code within the system. This can be exploited to gain access to confidential data or to cause a denial of service. It is important to properly validate all data before deserializing it, as deserialization can lead to serious security vulnerabilities.",
      "vulnerable_code": "import pickle\n\n# Deserializing untrusted data\nuntrusted_data = b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\"\nresult = pickle.loads(untrusted_data)\n\n# This code will execute the command 'echo hello world'\n# which can lead to unintended consequences such as\n# executing malicious code or accessing sensitive data.",
      "remediation": "# Before\nimport pickle\n\nuser_data = pickle.loads(data)\n\n# After\nimport pickle\nimport json\n\nuser_data = json.loads(data)",
      "semgrep_rule": "rule = {\n  id: \"deserialization-of-untrusted-data\",\n  patterns: [\n    {\n      pattern: \"{function_name}(.*, pickle.loads(.*)\",\n      message: \"Deserialization of untrusted data is vulnerable to attack.\",\n      metadata: {\n        description: \"Deserialization of untrusted data can lead to remote code execution.\",\n        cwe: 502\n      }\n    }\n  ]\n}",
      "codeql_rule": "import cwe502\n\nclass CWE502Detector:\n  def __init__(self):\n    self.vulnerable_methods = [\"pickle.loads\"]\n  \n  def onCall(self, call, ctx):\n    if call.getTarget().matches(self.vulnerable_methods):\n      ctx.report(call.getSourceLocation(), \"Vulnerable call to '\" + str(call.getTarget()) + \"' detected.\")\n\ncwe502.addDetector(CWE502Detector())"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287 is a type of security vulnerability that occurs when an application or system does not properly authenticate users. This means that the authentication process does not properly verify the identity of the user or does not provide sufficient protection against unauthorized access. This vulnerability can be exploited by attackers to gain access to sensitive data or to perform malicious activities. To prevent this vulnerability, authentication processes should be designed to verify the identity of the user and provide strong protection against unauthorized access.",
      "vulnerable_code": "# This code is vulnerable to improper authentication\n\nusername = input(\"Please enter your username: \")\npassword = input(\"Please enter your password: \")\n\nif username == 'admin' and password == 'password':\n    print(\"Login successful\")\nelse:\n    print(\"Login failed\")",
      "remediation": "# Remediation Example\n\n# 1) Ensure user authentication is properly implemented\n\n# Create a secure login process that requires a unique user ID and password\n# Store user passwords using strong encryption methods\n# Use multi-factor authentication whenever possible\n# Enforce a password policy that includes a minimum length, complexity, and expiration\n# Require users to change their passwords regularly\n# Implement a lockout policy after a certain number of unsuccessful login attempts\n# Monitor user authentication attempts and log any suspicious activity",
      "semgrep_rule": "rule = {\n  id: \"CWE-287-Improper-Authentication\",\n  patterns: [\n    pattern: \"if (.*?== *?null)\",\n    message: \"Improper Authentication detected\",\n    severity: \"warning\"\n  ],\n}",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthentication_CWE287:\n    def predicate(self, ctx):\n        return cwe287.hasImproperAuthentication(ctx)\n\nclass VulnerableFunction:\n    def predicate(self, ctx):\n        return ( ctx.get_caller() as Function ).has_vulnerability(ImproperAuthentication_CWE287)"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability in which hard-coded credentials are used in software applications. This type of vulnerability allows attackers to gain access to sensitive information or system resources by using a password or other authentication information which is stored directly in the application's code. This type of vulnerability is especially dangerous because the credentials are stored in plaintext, making them easily accessible to attackers. Additionally, these credentials are not updated or changed regularly, making them even more vulnerable to attack.",
      "vulnerable_code": "username = \"admin\"\npassword = \"admin123\"\n\nif (username == \"admin\" and password == \"admin123\"):\n    print(\"Login successful\")\nelse:\n    print(\"Login failed\")",
      "remediation": "# Remediation:\n\n# Store credentials in a secure configuration file\n# Ensure that the configuration file is not accessible to the public\n# Use environment variables to store credentials\n# Generate random passwords for each user\n# Use a password manager to store and manage credentials\n# Utilize multi-factor authentication whenever possible",
      "semgrep_rule": "rule = {\n  id: \"cwe-798-detection\",\n  pattern: \"username=\\\"*\\\" password=\\\"*\\\"\",\n  message: \"Possible use of hard-coded credentials detected!\",\n  severity: \"WARNING\"\n}",
      "codeql_rule": "import cwe\nimport python\n\nclass HardCodedCredentialsVuln(python.PythonQuery):\n    def __init__(self):\n        super().__init__()\n\n    def after_query(self):\n        for literal in python.Literal:\n            if literal.is_string() and self.is_credential(literal) and literal.is_hardcoded():\n                self.report(literal, \"Hard-coded credentials detected\")\n    \n    def is_credential(self, literal):\n        return \"password\" in literal.value or \"username\" in literal.value\n```"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 (Incorrect Default Permissions) is a vulnerability that occurs when software is installed with insecure default permissions that allow non-privileged users to access sensitive information or perform privileged actions. These insecure default permissions can allow attackers to gain access to sensitive data, gain elevated privileges, or cause denial-of-service attacks. In a Python environment, this vulnerability can be introduced when developers do not configure secure default permissions on files and folders during installation. For example, if a folder containing sensitive data is installed with world-readable permissions, then any user on the system would be able to access the sensitive data.",
      "vulnerable_code": "f = open(\"myfile.txt\", \"w\") \nf.write(\"This is some sensitive data\") \nf.close() \n\n# This code creates a file with default permissions (which is usually read and write for the owner) that can be accessed by anyone.",
      "remediation": "Create a script to set secure default permissions on files and directories. For example, the script could set permissions on newly created files and directories to read and write for the owner, and read for the group and others. The script could be run on a regular basis to ensure that all files and directories have the correct default permissions.",
      "semgrep_rule": "rule = {\n  id: \"cwe-276-incorrect-default-permissions\",\n  strings: {\n    // match any file permissions that give owner, group, and everyone else full access\n    // e.g. chmod 777 file.txt\n    $set_permissions = /chmod\\s+777\\s+\\S+/,\n  },\n  condition: allof($set_permissions)\n}",
      "codeql_rule": "import cwe276\nfrom AccessControl import FileAccess\n\nclass CWE_276_Incorrect_Default_Permissions:\n    def __init__(self):\n        self.vuln_name = \"CWE-276: Incorrect Default Permissions\"\n        self.severity = \"High\"\n    \n    def get_vuln_name(self):\n        return self.vuln_name\n\n    def get_severity(self):\n        return self.severity\n\n    def query(self):\n        return cwe276.Query.select(f)\n        .where(f.kind == FileAccess.File)\n        .and(f.permissions != FileAccess.Public)\n        .and(f.permissions != FileAccess.Private)"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that occurs when sensitive information is exposed to an unauthorized actor. This can occur when data is improperly stored, transmitted, or accessed, leading to a breach of security. This type of vulnerability can lead to the exposure of information such as passwords, usernames, financial data, or other sensitive information. An attacker may be able to exploit this vulnerability to gain access to various systems and resources, or to access sensitive information.",
      "vulnerable_code": "# This code reads a file containing sensitive information and prints it to the console\n\nwith open('sensitive_data.txt', 'r') as f:\n    data = f.readlines()\n    print(data)",
      "remediation": "One way to remediate CWE-200 would be to ensure that all sensitive information is encrypted when stored or transmitted across a network. For example, when an application needs to store sensitive information in a database, it can use encryption algorithms to encrypt the data before sending it to the database. Additionally, when the application needs to transmit sensitive information over a network, it can use secure protocols such as TLS or SSH to protect the data in transit.",
      "semgrep_rule": "# CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nrules:\n- id: CWE-200\n  patterns:\n  - pattern: |\n      (data|information|credentials|secrets)[^\\n]*(stored|saved|transmitted|shared|exposed)[^\\n]*(publicly|without encryption|without authentication|without authorization|without permission)\n    message: \"Potential exposure of sensitive information to an unauthorized actor\"\n    severity: critical",
      "codeql_rule": "import python\n\nclass CWE200ExposureOfSensitiveInformationRule extends Rule {\n    // Context related to the vulnerability\n    // ...\n    \n    // Helper methods\n    // ...\n    \n    // Entry point of the rule\n    // ...\n    @Query\n    def getVulnerableUsage(): Query {\n        // Return the nodes in the program that can lead to the vulnerability\n        // ...\n    }\n    \n    // Method to verify if the program actually contains the vulnerability\n    // ...\n    @Query\n    def isVulnerable(Node node): Boolean {\n        // Check if the node can lead to the vulnerability\n        // ...\n    }\n}"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a vulnerability that occurs when credentials such as usernames and passwords are not sufficiently protected. This means that the credentials may be stored in plain text, or encrypted in a weak or easily broken manner. This can lead to a breach of security, as malicious actors can gain access to sensitive data. Attackers may also be able to gain privileges to systems and networks by using the leaked credentials.",
      "vulnerable_code": "# This code will store the user's login credentials in plaintext\nusername = input(\"Please enter your username: \")\npassword = input(\"Please enter your password: \")\n\ncredentials = username + \":\" + password\n\n# Store the credentials in a file\nwith open('credentials.txt', 'w') as f:\n    f.write(credentials)",
      "remediation": "# Before:\nusername = 'admin'\npassword = 'admin123'\n\n# After:\nimport bcrypt\n\n# Generate a salt\nsalt = bcrypt.gensalt()\n\n# Hash the password\nhashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)\n\n# Store the username and hashed password\nusername = 'admin'\npassword = hashed_password",
      "semgrep_rule": "rule = {\n    id: \"CWE-522-insufficiently-protected-credentials\",\n    patterns: [\n        {\n            pattern: \"{string} == {string}\",\n            message: \"Potential credentials stored in plaintext. Consider encrypting or hashing the credentials.\",\n            severity: \"WARNING\"\n        }\n    ]\n}",
      "codeql_rule": "import cpp\nimport semmle.code.cpp.dataflow\n\nclass InsufficientlyProtectedCredentialsRule extends SecurityHardeningChecker {\n  Credential getCredential(DataFlow::Node source) {\n    switch source.kind {\n      // Check for credential sources\n      case DataFlow::Node::Kind::StringLiteral: \n        return source.asStringLiteral.credential\n      case DataFlow::Node::Kind::IntegerLiteral:\n        return source.asIntegerLiteral.credential\n      case DataFlow::Node::Kind::FuncCall:\n        return source.asFuncCall.credential\n      // ... more cases\n      default:\n        return none\n    }\n  }\n\n  // Check for insecure storage of credentials\n  // For example, hard-coded credentials\n  @Override\n  predicate is"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a type of XML injection vulnerability that occurs when an application references an external XML entity in its XML processing, allowing an attacker to modify or access sensitive files or data. This vulnerability can be exploited to access local files, execute malicious code, or create a denial of service attack. This vulnerability can be caused by insufficient input validation, incorrect use of XML parsers, or code that references external entities without verifying their contents.",
      "vulnerable_code": "import xml.etree.ElementTree as ET\n\n# Load XML file\ntree = ET.parse('test.xml')\nroot = tree.getroot()\n\n# Get XML element\nvulnerable_element = root.find('vulnerable_element')\n\n# Get value from vulnerable element\nvalue = vulnerable_element.text\n\n# Use external entity reference\nvalue = vulnerable_element.text + \"&external_entity;\"",
      "remediation": "One way to remediate CWE-611 is to ensure that any XML parsing is done using a secure parser. This means that all external entities must be explicitly disabled to prevent malicious content from being parsed.\n\nFor example, if using the Python xml.etree.ElementTree library, the following code can be used to disable external entities:\n\nimport xml.etree.ElementTree as ET\n\n# Parse the XML with external entities disabled\nET.parse(\"myfile.xml\", parser=ET.XMLParser(resolve_entities=False))",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects XML External Entity Reference vulnerability\"\n  patterns:\n    - pattern: '<!ENTITY(\\s+)(?P<entity_name>\\w+)(\\s+)(?P<entity_value>.*?)>(?P<rest>.*)'\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n    message: \"XML External Entity Reference vulnerability detected\"\n    severity: \"CRITICAL\"\n}",
      "codeql_rule": "import cpp\nimport semmle.codeql.dataflow.dataflow_types\n\nclass XMLExternalEntityReferenceVulnerability(Query):\n    def vulnerable_code(c):\n        cpp.CallExpr.select(\n          lambda call: call.getFunction().getName() == \"parseXML\" and\n            call.hasArg(0) and\n            call.getArg(0).getType().isSubtypeOf(semmle.codeql.dataflow.dataflow_types.XML_INPUT)\n        )\n    \n    def query(c):\n        vulnerable_code = vulnerable_code(c)\n        return vulnerable_code.withFalse(\n            vulnerable_code.getArg(0).hasProperty(\"externalEntitiesAllowed\")\n        )"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-Side Request Forgery (SSRF) is a type of web application vulnerability which allows an attacker to send malicious requests from a vulnerable web application to an internal system. This type of attack can be used to access sensitive data from internal systems, gain remote code execution, and more. SSRF vulnerabilities can be exploited in a wide variety of ways, including probing for open ports, redirecting to malicious sites, or even exploiting internal services that are vulnerable to attack.",
      "vulnerable_code": "import requests \n\nurl = input(\"Enter the URL to make a request to: \")\n\nresponse = requests.get(url)\nhtml = response.text\n\nprint(html)",
      "remediation": "# Replace any user-supplied URL values with a whitelisted list of approved URLs\n\napproved_urls = [\"https://www.example.com/\", \"https://www.example2.com/\"]\n\ndef validate_url(url):\n    if url not in approved_urls:\n        raise ValueError(\"URL is not whitelisted\")\n    else:\n        return url\n\n# Use the validate_url() function when handling requests with user-supplied URLs\n\ndef handle_request(request):\n    if 'url' in request.data:\n        user_url = request.data['url']\n        validated_url = validate_url(user_url)\n        # Continue with request handling\n        ...",
      "semgrep_rule": "rule = {\n  id: \"CWE-918-ssrf-detection\",\n  description: \"Detects Server-Side Request Forgery (SSRF) attempts\",\n  author: \"Your name here\",\n  references: [\"https://cwe.mitre.org/data/definitions/918.html\"],\n  tags: [\"security\", \"cwe\", \"ssrf\"],\n  detection: {\n    name: \"ssrf-detection\",\n    code: {\n      pattern: \"http.request(.*)\",\n      message: \"Server-Side Request Forgery (SSRF) vulnerability detected\",\n    }\n  }\n}",
      "codeql_rule": "import cwe918\n\nclass CWE918Rule extends Rule {\n  // Check requests for suspicious URLs\n  // that could be used for SSRF\n  //\n  // Example of suspicious URLs:\n  // - Localhost\n  // - Internal IP addresses\n  // - File paths\n \n  // Find all requests\n  Query RequestMethods = MethodInvocation \n  and getName() in {\"get\", \"post\", \"delete\", \"put\", \"patch\"}\n\n  // Find all suspicious URLs\n  Query SuspiciousURLs = \n  RegexReplaceExpr\n  and getRegex() = \"^localhost$|^127\\.0\\..*$|^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$|^file:.*$\"\n\n  // Find all requests with suspicious"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of vulnerability that allows an attacker to execute arbitrary commands on a system by injecting malicious code into a vulnerable program. This type of attack is especially dangerous as it can be used to gain access to sensitive data, modify system configurations, and even launch additional attacks on other systems. Command injection can occur when user input is not properly sanitized before being passed to a system command. Without proper sanitization, attackers can use special characters to inject malicious code into the vulnerable program, which can then be executed by the system.",
      "vulnerable_code": "import subprocess \n\ndef execute_command(command):\n    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    return p.communicate()[0]\n\n# Vulnerable code\nuser_input = input(\"Enter a command: \")\noutput = execute_command(user_input)\nprint(output)",
      "remediation": "# Before remediation\nquery_string = input(\"Enter your query: \")\nquery_result = execute_query(query_string)\n\n# After remediation\nquery_string = input(\"Enter your query: \")\nsanitized_query_string = sanitize_input(query_string)\nquery_result = execute_query(sanitized_query_string)",
      "semgrep_rule": "rule = {\n  id: \"CWE-077-detection\",\n  patterns: [\n    {\n      pattern: \"{string_literal, identifier} / {string_literal, identifier}\",\n      message: \"Potential command injection vulnerability detected\",\n      severity: \"WARNING\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe077\n\nclass CWE077CommandInjectionRule extends Rule {\n    // Rule body\n   \n    // Finds calls to system() or exec()\n    // that do not sanitize user input\n    // before inserting it into the command\n    @Cwe077\n    def vulnerable_system_exec_calls(call : Call) : QueryNode[Call] {\n        call.getTarget().name(\"system\") or call.getTarget().name(\"exec\")\n    }\n    \n    // Finds calls to system() or exec()\n    // that contain user input\n    @Cwe077\n    def system_exec_with_user_input(call : Call) : QueryNode[Call] {\n        vulnerable_system_exec_calls(call)\n            .hasAnArgument(\"user_input\")\n    }\n    \n    // Checks"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295 is a vulnerability that occurs when an application fails to properly validate a digital certificate before accepting it. This can lead to a variety of security issues, including the potential for attackers to use forged or expired certificates to gain access to resources or data that should be otherwise restricted. This vulnerability can be especially dangerous when used in conjunction with other attack vectors, such as man-in-the-middle attacks.",
      "vulnerable_code": "import ssl\n\n# Create a TCP/IP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Wrap the socket in an SSL context\ncontext = ssl.SSLContext()\n\n# Connect the socket to the remote server\nsock.connect(('www.example.com', 443))\n\n# Perform certificate validation\n# This is the vulnerable line\ncontext.verify_mode = ssl.CERT_NONE\n\n# Send data\nsock.sendall(b'Hello, world')\n\n# Receive response\nresponse = sock.recv(1024)",
      "remediation": "# Remediating CWE-295: Improper Certificate Validation\n\ndef verify_ssl_certificate(server_cert, root_cert):\n    \"\"\"Verifies the server certificate against the root certificate.\"\"\"\n    try:\n        if root_cert.verify(server_cert) is not True:\n            raise Exception('Server certificate verification failed.')\n    except Exception as e:\n        print(e)\n        return False\n    return True",
      "semgrep_rule": "rule = {\n    id: \"CWE-295-Improper-Certificate-Validation\", \n    patterns: [\n        {\n            pattern: 'ssl.verify_mode == ssl.CERT_NONE',\n            message: 'Improper Certificate Validation detected'\n        },\n        {\n            pattern: 'ssl.verify_mode == ssl.CERT_OPTIONAL',\n            message: 'Improper Certificate Validation detected'\n        }\n    ]\n}",
      "codeql_rule": "import cwe\nimport python\n\n// CWE-295: Improper Certificate Validation\n\nclass ImproperCertificateValidation extends PythonQuery {\n    // Query for verifying the validity of certificates\n    def query_for_verifying_certificates() {\n        // Find the method which verifies the validity of certificates\n        MethodCall.find(\n            'ssl.match_hostname',\n        )\n    }\n    \n    // Query for not verifying the validity of certificates\n    def query_for_not_verifying_certificates() {\n        // Find the method which does not verify the validity of certificates\n        MethodCall.find(\n            'ssl.verify_mode',\n            'ssl.CERT_NONE'\n        )\n    }\n\n    // Rule for improper certificate validation\n    rule isVulnerableToImproperCertificateValidation {\n        // Check if"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability where the application generates code without proper validation or sanitization, allowing an attacker to inject malicious code into the application. This can be done through user input, such as when a user is allowed to submit code as part of a form or through a file upload. If the application fails to properly validate and sanitize the user input, the attacker can execute malicious code on the system. This can result in the attacker gaining access to sensitive data, manipulating data within the application, or even executing malicious code on the server.",
      "vulnerable_code": "def malicious_function(data):\n  # data is passed from the user\n  code = data + 'print(\"Hello World!\")'\n  exec(code)\n\nmalicious_function(input(\"Enter some code: \"))",
      "remediation": "Remediation for CWE-094 can be achieved by using input validation methods. This involves checking user input for malicious content and encoding it, if necessary. Below is an example of a function that uses input validation to prevent code injection:\n\ndef validate_input(input):\n    # Remove all non-alphanumeric characters\n    input = re.sub(r'[^a-zA-Z0-9 ]', '', input)\n    \n    # Encode the input\n    input = html.escape(input)\n    \n    return input",
      "semgrep_rule": "rules:\n  - id: cwe-094\n    severity: critical\n    message: \"Detected code injection vulnerability\"\n    patterns: \n      - pattern: 'eval(${parameter})'\n        message: \"Detected code injection vulnerability\"\n        targets:\n          - \"**/*.py\"",
      "codeql_rule": "import cpp\nimport semmle.codeql.dataflow.dataflow\n\nclass CWE094CodeInjection extends SecurityTest {\n  // Look for a call to the system() or exec() function\n  predicate isSystemCall(Expr call) {\n    exists(Call c | c.getTarget() = call and c.getKind() in {\"CXXMemberCall\", \"CXXOperatorCall\"} and c.getDecl().getName() in {\"system\", \"exec\"})\n  }\n\n  // Find assignments of user-controlled data to system calls\n  @EntryPoint\n  @DontReport\n  predicate isUserControlledAssignment(Expr lhs, Expr rhs) {\n    decl lhsDecl := lhs.getDecl()\n    lhsDecl != null and\n    lhsDecl.getName() in {\"__builtin_va_arg\", \""
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 is a vulnerability related to improper privilege management. This means that an application or system may be configured in a way that allows a user to access resources or functions they should not be able to access. This can occur when a user is given access to a system or application with more privileges than necessary, or when an application or system is not configured to restrict access to certain resources. In the case of Python applications, this vulnerability can occur when the software is not configured to properly check user authorization or authentication before allowing access to restricted resources.",
      "vulnerable_code": "def get_admin_access():\n  username = input(\"Please enter your username: \")\n  password = input(\"Please enter your password: \")\n  if username == \"admin\" and password == \"password\":\n    return True\n  else:\n    return False\n  \n\n# This code grants access to the \"admin\" user without any additional authentication or authorization checks. This could allow any user to gain admin access without the proper credentials.",
      "remediation": "# Remediate CWE-269 - Improper Privilege Management\n\n# Ensure that only authorized users have the necessary privileges to perform any given task\ndef restrict_privileges():\n    # Retrieve the list of current users\n    users = get_users()\n    \n    # Remove all unnecessary privileges from each user\n    for user in users:\n        remove_privileges(user)\n    \n    # Create a list of authorized users\n    authorized_users = get_authorized_users()\n    \n    # Grant only the necessary privileges to each authorized user\n    for user in authorized_users:\n        grant_privileges(user)",
      "semgrep_rule": "rule = \"\n\n// CWE-269: Improper Privilege Management\n\nimport \"strings\"\n\n@violation[severity = \"critical\"]\ndef cwe_269_improper_privilege_management() {\n    // Look for code that attempts to grant privileges to a user \n    // without ensuring the user has the appropriate permissions \n    // or credentials to do so\n\n    // Look for functions that grant privileges, such as \n    // setuid, setgid, seteuid, etc.\n    setuid, setgid, seteuid, setegid, initgroups\n    = \"strings.RegexMatch\"\n   \n    // Look for functions that grant privileges, such as \n    // setcap, setresuid, setresgid, etc.\n    setcap, setresuid, setresgid\n    = \"strings.RegexMatch\"",
      "codeql_rule": "import cwe269\n\nclass ImproperPrivilegeManagement(cwe269.Vulnerability):\n  def predicate(self, qctx):\n    return (\n      qctx.select(\"privilege\", \"p\", \n        qctx.call(\"os\", \"geteuid\"))\n      .where(lambda p: p.has_privilege() and\n        p.privilege_is_not_acquired_properly())\n    )"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917, also known as Expression Language Injection, is a vulnerability that occurs when an attacker is able to inject malicious code into an expression language statement. Expression language statements are commonly used in web applications to evaluate and manipulate data. Attackers can leverage this vulnerability to gain access to sensitive data, execute arbitrary code, or even modify application logic. This vulnerability can be exploited when an application does not properly neutralize user input, allowing attackers to inject malicious code into the statement. This can lead to a variety of security issues and potentially result in data loss or system compromise.",
      "vulnerable_code": "def get_greeting(name):\n    return f\"Hello, {name}!\"\n\nuser_name = request.args.get('name')\nreturn get_greeting(user_name)\n\nThe code above is vulnerable to expression language injection because it fails to properly neutralize user input. A malicious user could enter an expression language statement as their name, which could be evaluated by the application and potentially lead to an injection attack. For example, a user could enter the string \"${system.exit()}\" as their name, which would terminate the application.",
      "remediation": "# Before\nuser_input = request.args['user_input']\nquery = \"SELECT * FROM users WHERE name='\" + user_input + \"'\"\n\n# After\nfrom sqlalchemy.sql import text\nuser_input = request.args['user_input']\nquery = text(\"SELECT * FROM users WHERE name=:user_input\").bindparams(user_input=user_input)",
      "semgrep_rule": "rule = {\n  id: \"CWE-917\",\n  patterns: [\n    {\n      pattern: '(?P<expression>.*)(?P<injection>\\$\\{.*\\})',\n      message: \"Expression language injection detected at {{file}}:{{line}}:{{column}}\",\n      severity: \"CRITICAL\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe\n\nclass CWE917ExpressionLanguageInjection:\n \n  //Checks for the presence of expression language injection\n  //vulnerabilities in code\n \n  @Override\n  predicate check() {\n    //Check for the presence of expression language injection:\n    Expr.all(e | \n\t\te.isa(EvalExpr) and\n\t\te.getArgument().getText().contains(\"EL\")\n    )\n  }\n  \n  //Returns the CWE for expression language injection\n  @Override\n  vulnerable_pattern() {\n    cwe.CWE917\n  }\n\n}"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a type of security vulnerability that occurs when a program follows a link or reference to a file without properly validating the target of the link. This type of vulnerability can lead to security issues such as directory traversal and/or privilege escalation, as an attacker may be able to manipulate the link and access other files or directories without the proper security validation.",
      "vulnerable_code": "import os\n\nfilename = input(\"Enter a filename: \")\n\n# Incorrectly assume that filename is a relative path\nfile_path = os.path.join(os.getcwd(), filename)\n\n# Try to open the file\nwith open(file_path) as f:\n    contents = f.read()\n\nprint(contents)",
      "remediation": "# Remediate CWE-059\n\ndef secure_file_access(filepath):\n    \n    # Check if the path is absolute\n    if not os.path.isabs(filepath):\n        # Create an absolute path using os.path.abspath()\n        abs_filepath = os.path.abspath(filepath)\n    else:\n        # Use the absolute path provided\n        abs_filepath = filepath\n    \n    # Check if the path is valid\n    if not os.path.exists(abs_filepath):\n        raise FileNotFoundError\n    \n    # Check if the file is inside the current directory\n    if not os.path.dirname(abs_filepath).startswith(os.getcwd()):\n        raise PermissionError\n    \n    # If all checks pass, return the absolute filepath",
      "semgrep_rule": "# CWE-059: Improper Link Resolution Before File Access ('Link Following')\nrule = {\n    meta:\n      cwe = \"CWE-059\"\n    strings:\n      $func1 = /open(?:at)?/\n      $func2 = /readlink/\n    condition:\n      $func1 and $func2\n}",
      "codeql_rule": "import cwe\nimport python\n\nclass ImproperLinkResolutionBeforeFileAccessRule extends Rule {\n \n  // Rule meta data\n  meta.ruleName = \"Improper Link Resolution Before File Access\"\n  meta.cwe = cwe.CWE_059\n  \n  // Rule class body\n \n  // Find all function calls\n  def callExpr = Expr.call\n  \n  // Find all functions that have access to the filesystem\n  def vulnerableFunc = callExpr.hasTarget(\n    PythonFunction(\"open\")\n    or PythonFunction(\"os.open\")\n    or PythonFunction(\"os.openpyxl\")\n    or PythonFunction(\"os.path.exists\")\n    or PythonFunction(\"os.path.isfile\")\n    or PythonFunction(\"os.path.isdir\")\n    or PythonFunction(\"pickle.load\")\n    or"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability where sensitive information is transmitted in plaintext. This means that the data is not encrypted and can be easily read by anyone with access to the transmission. This is a major security risk as attackers can easily intercept and read the information being sent, which can be used to gain access to private accounts, sensitive data, or confidential information. It is important to ensure that any sensitive information is encrypted before it is transmitted to ensure its security.",
      "vulnerable_code": "# This code sends a username and password over an unencrypted connection\nimport requests\n\nusername = \"admin\"\npassword = \"mypassword\"\n\n# Unencrypted connection\nr = requests.post(\"http://example.com/api/login\", data={'username': username, 'password': password})",
      "remediation": "# Remediation for CWE-319: Cleartext Transmission of Sensitive Information\n\n#1: Encrypt Sensitive Data\nTo prevent cleartext transmission of sensitive data, any data that needs to be sent over the network should be encrypted using a strong encryption algorithm. This can be done using tools such as OpenSSL or TLS/SSL.\n\n#2: Use HTTPS\nWhen sending data over the network, use HTTPS instead of HTTP. This will ensure that the data is encrypted before it is transmitted.\n\n#3: Enforce Access Controls\nMake sure that access to any sensitive data is restricted to authenticated and authorized users. This will prevent unauthorized users from accessing the data.\n\n#4: Utilize Network Segmentation\nNetwork segmentation can be used to separate sensitive data from other parts of the network. This will ensure that the data is not accessible from untrusted networks.",
      "semgrep_rule": "rule = {\n\tid: \"CWE-319-detection\",\n\tseverity: \"warning\",\n\tpattern: \"http(s)?://[a-zA-Z0-9_.-]*(password|credentials|secret|key|token)\"\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass CleartextTransmissionVulnerability(cwe.Vulnerability):\n    \n    def __init__(self):\n        cwe.Vulnerability.__init__(self, \"CWE-319\")\n \n    def predicate(self, q):\n        return q.exists(\n            semmle.code.cpp.dataflow.TaintTracking.DataFlow,\n            lambda df: \n                df.taintSource.taintType == \"plaintext\" \n                and df.taintSink.sinkType == \"network\"\n        )"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601, also known as an Open Redirect, is a type of vulnerability in which an application or website allows a user to be redirected to an untrusted or malicious website, often without the user's knowledge or consent. This type of vulnerability can be exploited by attackers to launch phishing attacks, spread malware, and direct users to malicious websites. This vulnerability can occur when a web application does not properly validate user-supplied input before using it to construct a redirect URL. Attackers can take advantage of this vulnerability by crafting malicious URLs that redirect users to malicious websites.",
      "vulnerable_code": "# This is an example of vulnerable code that is susceptible to CWE-601.\n\ndef redirect_to_site(site_url):\n    # Redirect user to the given URL\n    return redirect(site_url)\n\n# This code is vulnerable because the user could be redirected to an untrusted site.\n# If an attacker were to craft a malicious URL and pass it to the function, \n# the user could be redirected to a malicious site. \n# This could lead to phishing attacks or other malicious activity.",
      "remediation": "# Before\ndef redirect_to_url(url):\n    return redirect(url)\n\n# After\ndef redirect_to_url(url):\n    if is_safe_url(url):\n        return redirect(url)\n    else:\n        return redirect('/error')",
      "semgrep_rule": "rule = {\n  id: \"open_redirect_detection\",\n  pattern: \"urlparse(param, allow_fragments=True, scheme='http')\",\n  message: \"Potential URL Redirection to Untrusted Site detected.\",\n  severity: \"error\"\n}",
      "codeql_rule": "import cwe601\n\nclass CWE601_URL_Redirect_Untrusted_Site:\n    def sanitize_redirect_url(url: String):\n        return url\n    \n    def get_redirect_url(url: String):\n        return sanitize_redirect_url(url)\n    \n    def vulnerable_url_redirection(url: String):\n        redirect_url = get_redirect_url(url)\n        if cwe601.is_unsafe_redirect(redirect_url):\n            return redirect_url\n        else:\n            return \"\"\n    \nviolation{\n  when CWE601_URL_Redirect_Untrusted_Site.vulnerable_url_redirection(url)\n  then\n    alert(\"Vulnerable URL redirection detected to an untrusted site!\")\n}"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability that occurs when sensitive information, such as passwords or other private data, is inserted into log files. This can be a security risk because log files are often exposed to unauthorized users, and the sensitive data can be used to gain access to systems or sensitive data. Attackers can also use the information to gain an understanding of system activity, or to identify possible targets.",
      "vulnerable_code": "import logging\n\n# Create a logger\nlogger = logging.getLogger(__name__)\n\n# Create a username and password\nusername = \"user1\"\npassword = \"MySecretPassword\"\n\n# Log a message with the username and password\nlogger.info(\"Username and Password: %s, %s\", username, password)",
      "remediation": "Remediation of CWE-532 can be achieved by implementing the following best practices:\n\n1. Ensure that sensitive information is not logged in plaintext. \n\n2. Use encryption to protect sensitive information before it is logged.\n\n3. Utilize log management tools to consistently monitor and rotate log files.\n\n4. Develop and implement policies and procedures for logging, reviewing, and storing log files.\n\n5. Establish user access controls to restrict and monitor access to log files.\n\n6. Establish an audit trail to track changes and access to log files.",
      "semgrep_rule": "rule = {\n  id: \"CWE-532\",\n  pattern: \"[log.info, log.warning, log.error] (parameter|input|args|arguments|query|credentials|password|token|key)\",\n  message: \"Sensitive information has been inserted into a log file\",\n  severity: \"error\"\n}",
      "codeql_rule": "import cwe\nimport python\n\nclass CWE532LogFileSensitiveInfoInsertion:\n  def predicate(self):\n    return exists(\n      python.Call('logging.debug', \n        lambda c: exists(c.arg.string_literal, lambda s: cwe.contains_sensitive_information(s)))\n    )"
    }
  },
  "Csharp": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is an attack that involves injecting malicious code into a web page or application. This code can be used to execute malicious scripts or redirect users to malicious websites. XSS attacks occur when a web application does not properly neutralize user input, allowing attackers to inject malicious code into the page or application. This malicious code can be used to access sensitive data, steal user information, or even execute malicious scripts on the user's browser.",
      "vulnerable_code": "String userInput = Request.QueryString[\"userInput\"];\nResponse.Write(\"<p>User Input: \" + userInput + \"</p>\");\n\nThe above code is vulnerable to Cross-site Scripting (XSS) because the userInput variable is being directly output to the page without being properly sanitized. An attacker could inject malicious scripts into the userInput and it would be executed in the user's browser.",
      "remediation": "One way to remediate CWE-079 is to use input validation. This means that all user input is checked against a whitelist of accepted values to ensure that only expected data is accepted. For example, if a web page contains a form field in which the user is asked to enter their age, the application can validate that the user has entered an integer value between 0 and 150. Any input that is not an integer value within this range could be rejected or sanitized.\n\nAnother way to remediate CWE-079 is to use output encoding. This means that all data outputted to the user's browser is encoded so that any potentially malicious code is rendered harmless. For example, if the user is allowed to enter HTML code into a form field, the application can use HTML encoding to convert the code into its corresponding HTML entities, making it harmless.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper neutralization of user-supplied input in web page generation (CWE-079: Cross-site Scripting)\"\n    author = \"Your Name Here\"\n  strings:\n    $input = /(?:<[^>]*(?:value|src|href|action)\\s*=\\s*[\"'][^\"']*)(?<script>\\s*<\\s*script\\s*>)/\n  condition:\n    $input\n}",
      "codeql_rule": "import csharp\nimport semmle.code.cpp.dataflow\n\nclass XSSVulnerability : Vulnerability {\n  // Test if the input is being printed to the output\n  // without sanitization\n  predicate isVulnerable(DataFlow::Node source) {\n    exists(DataFlow::Node sink |\n      source.flowsTo(sink) and\n      sink.asExpr()?.hasAncestor(\n        csharp.CWE_079_Sink()\n      )\n    )\n  }\n}\n\nclass CWE_079_Sink : Stmt {\n  CWE_079_Sink() {\n    // Find statements that print to the output without\n    // sanitizing the input\n    this.containsExpr(\n      csharp.Print()\n    )\n  }\n}"
    },
    "CWE-020: Improper Input Validation": {
      "description": "Improper input validation is a vulnerability in which user-supplied input is not properly validated and can be used to cause malicious code execution. Input validation can involve verifying the syntax of the input, verifying that the user-supplied input is within the expected range, or other measures to ensure that the input is valid and not malicious. Improper input validation can lead to various security breaches, including SQL injection, buffer overflows, and cross-site scripting attacks.",
      "vulnerable_code": "public void ProcessInput(string input)\n{\n    // vulnerable code\n    // no validation of the input\n    int result = 0;\n    for (int i = 0; i < input.Length; i++)\n    {\n        result += (int)input[i];\n    }\n    // do something with the result\n}",
      "remediation": "// Before Remediation:\nstring userInput = Request.QueryString[\"userInput\"];\n\n// After Remediation:\nif (Request.QueryString[\"userInput\"] != null)\n{\n    string userInput = Regex.Replace(Request.QueryString[\"userInput\"], \"[^a-zA-Z0-9]\", \"\");\n}",
      "semgrep_rule": "rule = \n    regexp: /^(?!.*\\b(?:[a-zA-Z0-9_]+\\(\\)))\n    message: \"Potential Improper Input Validation found\"",
      "codeql_rule": "import csharp\n\nclass ImproperInputValidation extends SecurityPolicyRule\n{\n    // Rule is triggered when a function is called with an untrusted input\n    // and no input validation is performed\n    @Override\n    // Declare the query to identify the vulnerability\n    source query isVulnerable() {\n        // Find functions that accept user input as arguments\n        // and do not perform input validation\n        (Method m, Expr e) = Method.allMethods()\n            // m accepts user input as an argument\n            .hasParameterWithType(t => t.isSubtypeOf(\"System.String\")) \n            // m does not perform input validation on user input arguments\n            .not(m2 => m2.anyDescendant(e2 =>\n                e2.isCall(\"System.String.IsNullOrEmpty\") and\n                e2.getArgument(0).equals("
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of security vulnerability that occurs when an attacker exploits a lack of input validation or sanitization by injecting malicious code or commands into an application. This type of injection can be used to bypass authentication, modify or delete data, or even execute arbitrary code. If an application is not properly neutralizing special elements such as user input, environment variables, or other system components, an attacker may be able to inject malicious code or commands into the application, resulting in a security vulnerability.",
      "vulnerable_code": "string command = string.Format(\"ping {0}\", userInput);\nProcessStartInfo procStartInfo = new ProcessStartInfo(\"cmd\", \"/c \" + command);\nProcess.Start(procStartInfo);\n\nIn the above code, the userInput variable is unsanitized before being used in the ping command. This allows an attacker to inject malicious commands into the system, potentially allowing them to gain unauthorized access.",
      "remediation": "//Prevent user input from being executed as a system command\nstring userInput = Console.ReadLine();\n\n//Sanitize user input for any malicious code\nuserInput = Regex.Replace(userInput, @\"[^\\w\\s]\", \"\");\n\n//Execute the user input as a parameterized query\nSqlCommand command = new SqlCommand(\"SELECT * FROM table WHERE column = @input\", connection);\ncommand.Parameters.AddWithValue(\"@input\", userInput);\ncommand.ExecuteNonQuery();",
      "semgrep_rule": "rule = {\n  strings:\n    $str_1 = \"system(\"\n    $str_2 = \"exec(\"\n    $str_3 = \"shell(\"\n  condition: $str_1 or $str_2 or $str_3\n}",
      "codeql_rule": "import csharp\n\nclass CWE_078_OS_Command_Injection extends Rule\n{\n    // expand the query to find all instances of functions that can be used to execute OS commands\n    // (system, exec, etc)\n    query vulnerableFunctions(){\n        CSharp.MethodInvocationExpr(meth : CSharp.SystemCommandExecutionMethod)\n    }\n\n    // check the parameters of the vulnerable functions\n    // if one of them is user-supplied input, this is a potential vulnerability\n    query isVulnerable(){\n        vulnerableFunctions() & CSharp.MethodInvocationExpr.hasArgument(arg : CSharp.Expr, idx : int)\n    }\n \n    // if the user-supplied input is not properly sanitized, this is a vulnerability\n    // use the taint.tainted* family of methods to detect user-supplied"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089 is a type of vulnerability that occurs when user-supplied input is not validated, sanitized or properly escaped before being passed to an SQL query. This can result in malicious SQL code being executed in the database which can grant an attacker unauthorized access to sensitive data, modify the contents of the database, or even delete data. To mitigate this vulnerability, developers should perform input validation and parameterized queries to ensure that the data being passed to the database is safe.",
      "vulnerable_code": "SqlCommand cmd = new SqlCommand(\"SELECT * FROM Users WHERE username='\" + userName + \"'\");",
      "remediation": "// Example using parameterized queries \nusing (SqlConnection conn = new SqlConnection(connectionString))\n{\n    conn.Open();\n    string sql = \"SELECT * FROM Users WHERE Username = @username\";\n    SqlCommand cmd = new SqlCommand(sql, conn);\n    cmd.Parameters.AddWithValue(\"@username\", username);\n    SqlDataReader reader = cmd.ExecuteReader();\n    // Process the data \n}",
      "semgrep_rule": "rules:\n  - id: CWE-089\n    strings:\n      - $sql = \"SELECT * FROM users WHERE username='$username' AND password='$password'\"\n    patterns:\n      - pattern: \"$username' AND password='$password'\"\n        message: \"Potential SQL injection vulnerability detected\"\n        severity: WARNING",
      "codeql_rule": "import csharp\n\nclass Vulnerability_CWE_089_SQL_Injection extends SecurityFocus {\n    // Create a predicate to match a vulnerable query\n    predicate vulnerableQuery() {\n        exists(MethodInvocation inv |\n            inv.getTarget().getName() == \"ExecuteNonQuery\" and\n            inv.getArgument().hasType(csharp.StringType)\n        )\n    }\n\n    // Create a predicate to match an unprotected user input\n    predicate unprotectedInput() {\n        exists(VariableRef vr |\n            vr.getVariable().hasAnnotation(\"unprotected\") and\n            vr.getAnAccess().getReceiver()\n        )\n    }\n\n    // Create a predicate to match a vulnerable query that uses an unprotected user input\n    vulnerableQuery() and unprotectedInput()\n}"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal is a security vulnerability that occurs when a web application or a program uses user-supplied input to construct a pathname that is intended to access files or directories stored outside of the program's root folder. In this way, attackers can traverse the file system to access restricted files, view sensitive information, or even execute malicious code on the server. Path traversal attacks can be prevented by using input validation techniques to ensure that user-supplied paths contain only characters that are authorized and necessary for the application to access the requested files.",
      "vulnerable_code": "string path = \"/path/to/file\";\nstring input = \"../../../../../../etc/passwd\";\n\n//The following code is vulnerable to path traversal\nstring filePath = Path.Combine(path, input);\n//This code would allow an attacker to access the file /etc/passwd\n//This is because the user input was not properly validated, allowing it to escape the restricted directory",
      "remediation": "// Remediation Example \n\nstring filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"Data\", \"users.xml\");\n\n// This will ensure that the filePath is always relative to the application's base directory \n// and will prevent any attempts to access a file outside of this directory.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Path Traversal vulnerability\"\n    author = \"Semgrep team\"\n    id = \"CWE-022\"\n  strings:\n    $s1 = /\\.\\.\\/.*\\//\n    $s2 = /\\~\\//\n  condition:\n    $s1 or $s2\n}",
      "codeql_rule": "import csharp\n\nclass PathTraversalVulnCheck:\n    // Find potential dangerous calls\n    Query potentialDangerousCalls {\n        // Check for System.IO.Path calls with user-controlled input\n        CSharpMethodInvocation m\n        where m.getTarget().getName().matches(\"Path\")\n        and m.hasArgumentWithValue(v) \n        and v.mayPointToUserControlledInput()\n    }\n    \n    // Check if the user-controlled input is being used to build a path\n    Query dangerousPathBuildingCalls {\n        potentialDangerousCalls p\n        where p.getName().matches(\"Combine|GetFullPath|GetDirectoryName\")\n    }\n    \n    // Flag calls to Combine, GetFullPath, or GetDirectoryName that do not restrict the path\n    vulnerability PathTraversalVuln"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site request forgery (CSRF) is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to do. It occurs when a malicious website or application causes a user's web browser to perform an unwanted action on a trusted site for which the user is currently authenticated. This can be done by sending a malicious request from the malicious website to the vulnerable website, which then is executed by the user's browser without their knowledge or consent. It is one of the most common web security vulnerabilities, and it can be used to compromise user accounts and steal sensitive data.",
      "vulnerable_code": "// Client side code\n<form action=\"http://www.example.com/action.php\" method=\"POST\">\n  <input type=\"hidden\" name=\"_csrf\" value=\"<?php echo $csrf_token; ?>\">\n  <input type=\"text\" name=\"username\" value=\"<?php echo $username; ?>\">\n  <input type=\"password\" name=\"password\" value=\"<?php echo $password; ?>\">\n  <input type=\"submit\" value=\"Submit\">\n</form>\n\n// Server side code\n<?php\n$csrf_token = $_POST['_csrf'];\n$username = $_POST['username'];\n$password = $_POST['password'];\n\n// Verify CSRF token\nif ($csrf_token != 'abc123') {\n    // CSRF token is invalid\n    // Do not process the request\n    exit",
      "remediation": "Example:\n\n// CSRF protection\n\n// Generate a unique token for each request\nvar token = GenerateToken();\n\n// Add the token to all POST requests\n$('form').submit(function() {\n    $(this).append('<input type=\"hidden\" name=\"csrf_token\" value=\"' + token + '\" />');\n});\n\n// Validate the token on the server\nif(Request.Form[\"csrf_token\"] != token)\n{\n    // Invalid token - reject request\n}\nelse\n{\n    // Valid token - continue with request\n}",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects Cross-Site Request Forgery (CSRF) vulnerability\"\n        author = \"Your Name\"\n        date = \"2020-04-24\"\n    strings:\n        $s1 = \"csrf_token\"\n    condition:\n        all of them\n}",
      "codeql_rule": "import csharp\n\nclass CSRFVulnerability : Vulnerability {\n \n  // Vulnerability title\n  let title = \"Cross-Site Request Forgery (CSRF) Vulnerability\"\n  \n  // Query to detect the vulnerability\n  // Checks for a web request that does not have an anti-CSRF token\n  // or a verification of the origin of the request\n  query isVulnerable {\n    for webReq in WebRequest.calls\n    where webReq.hasNoAntiCSRFToken && webReq.hasNoOriginCheck\n    select webReq\n  }\n  \n  // Severity of the vulnerability\n  // High severity\n  let severity = \"High\"\n\n  // Remediation advice\n  let remediation = \"Implement an anti-CSRF token or a verification of the origin of the request.\"\n}"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a type of vulnerability that allows attackers to upload malicious files to a server without any restrictions in place. This can be done by exploiting the lack of proper file type validation on the server, allowing attackers to upload and execute malicious code on the target system. This vulnerability can lead to a variety of attacks, such as data theft, defacement, and privilege escalation, as well as providing a foothold for further attacks.",
      "vulnerable_code": "//This code allows a user to upload a file without restriction on file type:\n\nstring filename = \"C:\\\\uploads\\\\myFile.txt\";\n\nif (File.Exists(filename))\n{\n    File.Delete(filename);\n}\n\nFile.Copy(Request.Files[\"fileUpload\"].FileName, filename);",
      "remediation": "Remediation of this vulnerability can involve validating the type and size of the uploaded file before allowing it to be uploaded, and restricting the types of files that can be uploaded.\n\nFor example, the following code can be used to validate the type of files before allowing them to be uploaded:\n\n// Validate the type of the uploaded file\nstring[] allowedExtensions = {\".jpg\", \".png\", \".gif\", \".docx\"};\nstring fileExtension = Path.GetExtension(file.FileName).ToLower();\nif (!allowedExtensions.Contains(fileExtension))\n{\n    // File type is invalid, reject it\n    return false;\n}\n\nThe code can also be used to restrict the size of the uploaded file:\n\n// Restrict the size of the uploaded file\nif (file.ContentLength > 5 * 1024 * 1024)\n{\n    // File size is too large,",
      "semgrep_rule": "rule = {\n\tmeta:\n\t  description = \"Detects Unrestricted Upload of File with Dangerous Type\"\n\t  author = \"Your Name\"\n\t  severity = \"high\"\n\t  \n\tsource:\n\t  lang = \"csharp\"\n\t  \n\tstrings:\n\t  $dangerous_types = /\\.exe|\\.bat|\\.cmd|\\.com|\\.cpl|\\.msi|\\.dll|\\.vb(s|e)|\\.js|\\.jse|\\.wsf|\\.wsh/\n\t  \n\tpatters:\n\t  $dangerous_file = /File\\.Upload\\(.*, $dangerous_types\\)/\n\t  \n\t \n\t\n\tantipatterns:\n\t  $dangerous_upload = $dangerous_file\n}",
      "codeql_rule": "import csharp\n\nclass UnrestrictedUploadOfDangerousFileType extends SecurityCodeScannerRule {\n  // Rule to detect potential unrestricted upload of dangerous file types\n  // File types that should not be allowed are specified in a list of extensions\n \n  // list of file types to detect\n  string[] extensions = {\"exe\", \"dll\", \"js\", \"vbs\", \"bat\", \"bin\", \"scr\"};\n \n  // query to detect potential unrestricted upload of file types\n  query qFileUpload() {\n    FileStream f |\n    MemberAccess m\n    & m.target = f\n    & f.name.like(\"*.(extensions[])\")\n  }\n  \n  // method to obtain the list of dangerous file types\n  public string[] getExtensions() {\n    return extensions;\n  }\n  \n  // rule to detect potential unrestricted upload of dangerous"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306: Missing Authentication for Critical Function is a vulnerability that occurs when authentication is not properly implemented or enforced for a critical function. This type of vulnerability allows attackers to access restricted areas or functions without proper authentication, granting them access to sensitive data and resources. These functions can range from administrative tasks to data manipulation, and an attacker can exploit this vulnerability to gain access to sensitive information or alter data and disrupt operations.",
      "vulnerable_code": "public class UserController\n{\n    public void CreateUser()\n    {\n        // code to create a user\n    }\n\n    public void UpdateUser()\n    {\n        // code to update a user\n    }\n\n    public void DeleteUser()\n    {\n        // code to delete a user\n    }\n}\n\nThe problem with the above code is that there is no authentication or authorization check when calling any of the methods. This means that any user can call the CreateUser(), UpdateUser(), and DeleteUser() methods, which can lead to serious security issues.",
      "remediation": "The following code remediation example shows how an authentication system can be implemented to ensure that only authorized users can access a critical function:\n\n// Begin authentication system\n\n// Check if user is authorized\nif (IsAuthorized(user))\n{\n   // User is authorized. Allow access to the critical function\n   ExecuteCriticalFunction();\n}\nelse \n{\n   // User is not authorized. Deny access to the critical function\n   LogAccessDenial();\n   ThrowUnauthorizedAccessException();\n}\n\n// End authentication system",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Missing Authentication for Critical Function\"\n        id = \"CWE-306\"\n    strings:\n        $func1 = \"critical_function\"\n    condition:\n        not all and $func1 @within 5 lines of /authentication/\n}",
      "codeql_rule": "import csharp\n\nclass MissingAuthForCriticalFunction extends SecurityRiskRule {\n  // Search for methods with a critical function\n  // that are not protected by authentication\n  @Override\n  def getQueries() {\n    Q.select(m, s)\n      .from(csharp.Method, m)\n      .from(csharp.StringLiteral, s)\n      .where(m.body().contains(s))\n      .where(s.matches(\".*critical.*function.*\"))\n      .where(m, \"hasAnnotation\", csharp.Annotation.Authentication, false)\n  }\n\n  // Reports security risk\n  @Override\n  def getRiskMessage() {\n    return \"Missing authentication for critical function\"\n  }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability that occurs when untrusted data is deserialized. This can lead to malicious code being executed, or sensitive information being exposed. Attackers can exploit this vulnerability by introducing malicious code or data into the system, which can be deserialized by the application and executed. This could allow an attacker to gain access to the system or sensitive information, or to cause damage.",
      "vulnerable_code": "// Deserialization of untrusted data, vulnerable to CWE-502\nusing System.Runtime.Serialization.Formatters.Binary;\n\nbyte[] data = GetUntrustedData();\n\nBinaryFormatter formatter = new BinaryFormatter();\nobject deserializedObject = formatter.Deserialize(new MemoryStream(data));",
      "remediation": "Example of Deserialization of Untrusted Data remediation:\n\n// Declare a new SerializationBinder\nSerializationBinder binder = new MyCustomBinder();\n\n// Set the SerializationBinder on the SerializationSettings\nvar serializationSettings = new JsonSerializerSettings { \n    SerializationBinder = binder \n};\n\n// Use the serializationSettings when deserializing\nvar deserializedObject = JsonConvert.DeserializeObject<MyObject>(jsonString, serializationSettings);",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects deserialization of untrusted data\"\n    id = \"CWE-502\"\n  strings:\n    $deserialize = \"Deserialize\"\n    $untrusted = \"untrusted\"\n  condition:\n    $deserialize and $untrusted\n}",
      "codeql_rule": "import csharp\n\nclass DeserializationOfUntrustedData extends SecurityCodeQL {\n    // CWE-502: Deserialization of Untrusted Data\n\n    // Finds all methods that call Deserialize on an untrusted object\n    query untrustedDeserialize(){\n        MethodInvocation m |\n        // Find the method invocation of Deserialize\n        m.getName().matches(\"Deserialize\") and \n        // Identify the receiver of the method invocation\n        exists(ObjectCreation c | c.getObjects().references(m.getReceiver())) and \n        // Identify the creation of untrusted data\n        // Replace \"untrustedData\" with the type of untrusted data\n        exists(ObjectCreation c2 | c2.getObjects().references(m.getReceiver()) and c2.getType()."
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability that occurs when an application or system fails to properly authenticate users or verify their credentials. When this happens, an attacker can gain access to data or resources that should be restricted. This type of vulnerability can be exploited by attackers to gain access to sensitive data, files, and services in the system. Additionally, improper authentication can lead to privilege escalation or account hijacking.",
      "vulnerable_code": "public void Login(string username, string password) \n{ \n    if (username == \"admin\" && password == \"admin\") \n    { \n        // allow authentication \n    } \n} \n\nIn the code above, the authentication process is vulnerable to a brute force attack. This is because the username and password are both hard-coded within the code, making it easy for an attacker to guess the correct credentials.",
      "remediation": "1. Ensure that all users are required to authenticate using a strong password that meets certain requirements (e.g. minimum length, combination of letters, numbers and special characters).\n\n2. Use a two-factor authentication system, such as a one-time password (OTP) or biometric authentication, to verify the identity of users.\n\n3. Ensure that authentication credentials are securely stored, using a secure hashing algorithm such as SHA-2 or bcrypt.\n\n4. Monitor authentication attempts and lock out user accounts after a certain number of failed attempts.\n\n5. Use a secure connection (e.g. SSL/TLS) to protect the transmission of authentication credentials.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects CWE-287: Improper Authentication\"\n    author = \"Security Team\"\n    id = \"CWE-287-1\"\n  strings:\n    $password = /\\b(password|passwd)\\b/\n    $user = /\\b(user|username)\\b/\n  condition:\n    $password and $user\n  message: \"CWE-287: Improper Authentication detected\"\n}",
      "codeql_rule": "import csharp\n\nclass ImproperAuthenticationVulnerability implements CxChecks {\n  CxList authenticationMethods = Find_Methods().FindByShortName(\"authenticate*\", false);\n\n  @Override\n  public CheckResult test() {\n    if(authenticationMethods.Count == 0){\n      return CheckResult.failure(\"No authentication methods found\");\n    }\n    CxList passwords = authenticationMethods.FindByParameterName(\"password\", false);\n    \n    if (passwords.Count == 0){\n      return CheckResult.failure(\"No password parameter found in authentication methods\");\n    }\n    CxList hashes = passwords.FindByShortName(\"hash*\", false);\n    if (hashes.Count == 0){\n      return CheckResult.fail(\"Password parameter not hashed in authentication methods\");\n    }\n    return CheckResult.success();\n  }\n}"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability where a program or application uses hard-coded credentials, such as a username and password, to access restricted resources. This is a security issue because anyone that knows the credentials can gain access to the resource, and potentially cause damage or steal data. It also makes it difficult to change or revoke access as the credentials cannot be easily changed or updated. Additionally, hard-coded credentials are typically stored in plain text, which leaves them exposed to anyone who is able to access the source code or executable file.",
      "vulnerable_code": "string username = \"admin\";\nstring password = \"admin123\";\n\nif(username == \"admin\" && password == \"admin123\")\n{\n   // grant access\n}\nelse\n{\n   // deny access\n}",
      "remediation": "// Before \nstring connectionString = \"Data Source=database_server;User Id=username;Password=password;\";\n\n// After \nstring connectionString = \"Data Source=database_server;User Id=@username;Password=@password;\";\n\n// Retrieve credentials from an encrypted configuration file or user prompt\nstring username = GetUsername();\nstring password = GetPassword();\n\n// Create connection string with retrieved credentials\nstring connectionString = \"Data Source=database_server;User Id=\" + username + \";Password=\" + password + \";\";",
      "semgrep_rule": "rule = {\n \tmeta:\n \t\tdescription = \"Detection of hard-coded credentials\"\n \t\tauthor = \"Author Name\"\n \tstrings:\n \t\t$creds_1 = \"*username*\"\n \t\t$creds_2 = \"*password*\"\n \t\t$creds_3 = \"*key*\"\n \t\t$creds_4 = \"*token*\"\n \t\t$creds_5 = \"*secret*\"\n \t\t$creds_6 = \"*account*\"\n \t\t$creds_7 = \"*api-key*\"\n \t\t$creds_8 = \"*auth-token*\"\n \t\t$creds_9 = \"*access-key*\"\n \t\t$creds_10",
      "codeql_rule": "import csharp\n\nclass HardcodedCredentialsVulnerability {\n  /**\n   * Finds uses of hard-coded credentials\n   */\n  predicate isHardcodedCredential(Credential c) {\n    exists(Identifier id, MemberAccess ma |\n           ma.getTarget() = c &&\n           ma.getName() = id &&\n           id.getName().matches(\"password|username|token\")\n    )\n  }\n  \n  //Vulnerable code should be flagged\n  //If the credentials are hardcoded\n  @CxSecurityCodeMarker\n  @CxSecurityVulnerability(type=\"CWE-798: Use of Hard-coded Credentials\")\n  void vulnerableMethod(Credential c) {\n    if (isHardcodedCredential(c)) {\n      //Vulnerable code\n    }\n  }\n}"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 is a vulnerability that occurs when a system has incorrect default permissions set, which can lead to unauthorized access to sensitive information or code. This vulnerability can arise in several ways, including when a system is installed with default settings that provide more access to the system than necessary, or when a system is configured to allow access to privileged accounts without proper authentication. Attackers can exploit this vulnerability to gain access to sensitive data, modify system settings, or even take control of the system.",
      "vulnerable_code": "// This code sets the default permissions for a file to 0666\nFileStream fs = new FileStream(\"file.txt\", FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);\nfs.SetAccessControl(new FileSecurity(\"file.txt\", AccessControlSections.Access));\nfs.SetAccessControl(new FileSecurity(\"file.txt\", FileSystemRights.Modify, AccessControlType.Allow));",
      "remediation": "// Remediation\n\n// Create a new policy to ensure that all files and folders are given the correct default permissions. \n\n// Steps:\n\n// 1. Create a new security group and add all users who need access to the files and folders.\n\n// 2. Create a new Group Policy Object (GPO) and set the default permissions for the security group.\n\n// 3. Link the GPO to the domain, so that all files and folders have the correct default permissions.\n\n// 4. Test the policy to ensure that all files and folders have the correct default permissions.",
      "semgrep_rule": "rule = {\n  id: \"CWE-276-Incorrect-Default-Permissions\",\n  patterns: [\n    // Look for permissions settings that are less restrictive than expected\n    pattern: \"permission == '*' or permission == 'Everyone' or permission == 'World' or permission == 'Anonymous'\",\n    message: \"Incorrect default permissions detected\",\n    severity: \"WARNING\"\n  ]\n}",
      "codeql_rule": "import csharp\n\nclass IncorrectDefaultPermissions : CodeQLQuery {\n  // Find all method declarations\n  private query MethodDecl() {\n    m:MethodDecl\n  }\n  \n  // Find all access modifiers\n  private query AccessModifier() {\n    m:AccessModifier\n  }\n  \n  // Find all constructors\n  private query ConstructorDecl() {\n    m:ConstructorDecl\n  }\n  \n  // Find all classes\n  private query ClassDecl() {\n    m:ClassDecl\n  }\n\n  // Find all method declarations with public or private access modifiers\n  private query MethodDeclWithAccessModifier() {\n    MethodDecl(\n      AccessModifier(\n        m.getModifier() in {\"public\", \"private\"}\n      )\n    )\n  }\n\n  // Find all constructor declarations with public or private access modifiers\n  private query"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability which occurs when sensitive information, such as passwords, credit card numbers, or personal data, is exposed to an unauthorized actor. This data may be exposed either through the malicious actions of an attacker, accidental disclosure, or a lack of security measures in place to protect the sensitive information. This vulnerability can lead to identity theft, financial fraud, and other malicious activities.",
      "vulnerable_code": "using System.Net;\n\n// Receive data from a web service\nstring data = \"\";\n\nusing (WebClient client = new WebClient())\n{\n    data = client.DownloadString(\"http://example.com/data.txt\");\n}\n\n// Display the data on the screen\nConsole.WriteLine(data);",
      "remediation": "The following example shows how to remediate a CWE-200 vulnerability by using encryption to protect sensitive data:\n\n1. Identify the sensitive data and the unauthorized actors who could have access to it.\n\n2. Decide on an appropriate encryption algorithm and key size.\n\n3. Implement the encryption algorithm to encrypt the sensitive data.\n\n4. Store the encrypted data in a secure location and limit access to only authorized personnel.\n\n5. Use secure protocols to transmit the encrypted data over an untrusted network.\n\n6. Utilize secure authentication methods to verify the identity of authorized personnel.\n\n7. Monitor and audit access to the encrypted data.",
      "semgrep_rule": "rule = {\n\tid: CWE-200\n\tpattern: \"*(password|passwd|credentials|secret|access_token|auth_token)[^\\s]*=\"\n\tmessage: \"Possible exposure of sensitive information to an unauthorized actor detected\"\n\tseverity: WARNING\n}",
      "codeql_rule": "import csharp\n\nclass CWE_200 : CodeQLSecurityVulnerability {\n\n  // Checks if a sensitive information is passed to an unauthorized actor\n  CxList sensitiveInfo = Find_Sensitive_Data_Stored_In_Variables();\n  CxList unauthorizedActors = Find_Unauthorized_Actors();\n  CxList potentialVulnerabilities = sensitiveInfo.DataInfluencingOn(unauthorizedActors);\n  \n  // Checks if the sensitive information is used in a method call\n  CxList methods = Find_Methods();\n  CxList methodCall = potentialVulnerabilities.FindByType(typeof(MethodInvokeExpr));\n  CxList vulnerableMethods = methods.FindByParameters(potentialVulnerabilities);\n  \n  // Checks if sensitive data is used in an assignment\n  CxList assignments = Find_Assignments();"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522: Insufficiently Protected Credentials is a vulnerability that occurs when authentication credentials are stored in a way that does not protect them from unauthorized access. This could be done by storing them in plaintext, using weak encryption, or not using any encryption at all. By not properly protecting credentials, an attacker could gain access to an application or system, compromising the security of the system and any data it contains.",
      "vulnerable_code": "string user = \"admin\";\nstring pass = \"password\"; \n\n// This code doesn't use any encryption\nif (user == \"admin\" && pass == \"password\")\n{\n    // user is authenticated\n}\nelse\n{\n    // user is not authenticated\n}",
      "remediation": "Remediation for CWE-522: Insufficiently Protected Credentials involves implementing strong authentication and access control measures. Specifically, organizations should take steps to ensure that passwords or other credentials used to access sensitive systems or data are sufficiently protected from unauthorized use or access.\n\nSome best practices for protecting credentials include:\n\n1. Requiring strong passwords that are at least 8-10 characters long and difficult to guess.\n\n2. Limiting the number of failed login attempts before locking out the user account.\n\n3. Ensuring that passwords are not shared or stored in plaintext.\n\n4. Utilizing multi-factor authentication.\n\n5. Enforcing regular password changes.\n\n6. Encrypting passwords and other confidential information.",
      "semgrep_rule": "rules:\n  - id: insufficiently-protected-credentials\n    patterns:\n    - pattern: 'username=${username:regex(\".*\")}&password=${password:regex(\".*\")}'\n    message: 'Credentials are not sufficiently protected.'\n    severity: ERROR\n    metadata:\n      cwe: 'CWE-522'",
      "codeql_rule": "import csharp\n\nclass InsufficientlyProtectedCredentialsRule extends Rule {\n \n  // Query to find all instantiations of the DataProtection class\n  query dataProtectionClass() {\n    DataProtection dp\n  }\n  \n  // Query to find all instantiations of the System.Configuration.ConfigurationManager class\n  query configManagerClass() {\n    ConfigurationManager cm\n  }\n  \n  // Query to find all calls to DataProtection.Protect()\n  query protectMethod() {\n    DataProtection.Protect(...)\n  }\n  \n  // Query to find all calls to System.Configuration.ConfigurationManager.AppSettings.Get()\n  query getMethod() {\n    ConfigurationManager.AppSettings.Get(...)\n  }\n  \n  // Query to find instances of credentials stored in the configuration that are not sufficiently protected\n  query insufficientlyProtectedC"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability that occurs when an application parses XML input without properly restricting external entity references. This vulnerability allows attackers to access sensitive data and potentially execute malicious code by exploiting references to outside resources. By manipulating the XML input, an attacker could access files on the server or even remote systems, resulting in unauthorized access to confidential data or remote code execution.",
      "vulnerable_code": "// Vulnerable Code\nXmlDocument xmlDoc = new XmlDocument();\nxmlDoc.Load(\"http://example.com/file.xml\");\n\n// The URL provided in the Load method is not sanitized which can allow attackers to exploit XXE vulnerabilities by providing an external entity reference in the file.xml file. This can lead to sensitive information disclosure, denial of service, and other attacks.",
      "remediation": "Example:\n\n// Before\nXmlDocument doc = new XmlDocument();\ndoc.LoadXml(xmlString);\n\n// After\nXmlReaderSettings settings = new XmlReaderSettings();\nsettings.DtdProcessing = DtdProcessing.Prohibit;\nXmlReader reader = XmlReader.Create(new StringReader(xmlString), settings);\nXmlDocument doc = new XmlDocument();\ndoc.Load(reader);",
      "semgrep_rule": "rule = {\n  strings:\n    // detect usage of XML External Entity Reference\n    $xml_ee_ref=\"<!ENTITY\"\n  condition: $xml_ee_ref\n}",
      "codeql_rule": "import csharp\n\nclass VulnerableXMLRefInjectionRule extends Rule {\n  // Rule to detect improper restriction of XML external entity reference\n \n  // Finds any XML document created from a string\n  query XMLDocFromString(){\n    XmlDocument.ctor(string)\n  }\n \n  // Finds any suspicious external entity references\n  query ExternalEntityRef(){\n    XmlDocument.CreateEntityReference(string)\n  }\n \n  // Matches any XML document created from a string that contains a suspicious external entity reference\n  query result(){\n    XMLDocFromString()\n    ctor <- ExternalEntityRef()\n  }\n \n  // Reports the vulnerability\n  vuln_msg = \"Improper restriction of XML external entity reference detected\"\n \n  // Entry point\n  @Override\n  public predicate isVulnerable(){\n    result()\n  }"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "CWE-918 is a type of attack which allows attackers to send malicious requests to a web server from a trusted source. This type of attack allows attackers to bypass authentication and access internal systems and data that would otherwise be inaccessible. It is possible to use this vulnerability to scan internal networks, access restricted files, and gain access to sensitive information. Additionally, attackers can use SSRF to launch denial of service attacks, or even launch attacks against other servers.",
      "vulnerable_code": "public async Task<string> GetData(string url) \n{\n    HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\n    request.Method = \"GET\";\n    string response = \"\";\n    using (HttpWebResponse resp = (HttpWebResponse)await request.GetResponseAsync())\n    {\n        using (StreamReader reader = new StreamReader(resp.GetResponseStream()))\n        {\n            response = reader.ReadToEnd();\n        }\n    }\n    return response;\n}\n\nThe above code is vulnerable to a server-side request forgery attack. An attacker could provide a malicious URL in the \u201curl\u201d parameter, which the code would then send an HTTP request to, potentially exposing the server to attack.",
      "remediation": "Example:\n\nThe following code implements a SSRF vulnerability remediation strategy in Csharp:\n\n// Check if the request is local\nif (!Request.IsLocal)\n{\n    // Redirect to an error page\n    Response.Redirect(\"/Error.aspx?ErrorCode=403\");\n}\n\n// Validate the request by comparing the Host header with the domain name\nif (Request.Url.Host != \"domain.com\") \n{\n    // Redirect to an error page\n    Response.Redirect(\"/Error.aspx?ErrorCode=403\");\n}\n\n// Verify the request is for a valid endpoint\nif (!Request.Url.PathAndQuery.StartsWith(\"/validEndpoint\")) \n{\n    // Redirect to an error page\n    Response.Redirect(\"/Error.aspx?ErrorCode=403\");\n}",
      "semgrep_rule": "rules:\n  - id: CWE-918-SSRF\n    severity: critical\n    message: \"Server-Side Request Forgery (SSRF) detected\"\n    patterns:\n      - pattern: '<\\s*[a-zA-Z0-9]+\\s*(?:src|action|href)\\s*=\\s*[^\\s]*(?:http|https)\\s*:'\n        qualifiers:\n          - \"diagnostics.severity='critical'\"\n    metadata:\n      cwe: 918\n      cve: \n      capec: \n      references: \n        - name: OWASP\n          url: \"https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\"",
      "codeql_rule": "import csharp\n\nclass ServerSideRequestForgeryVulnerability: Vulnerability {\n  // Checks if request can be sent to an external URL\n  // and the URL is not validated\n  predicate isExternalRequest() {\n    // Checks if a Uri object is instantiated with a user-controlled string\n    exists(MethodInvocation mi | \n      mi.getTarget().getType().getName() = \"System.Uri\" and\n      mi.getArgumentCount() > 0 and\n      mi.getArgument(0).hasStringValue()\n    )\n  }\n  \n  // Checks if the URL is being verified\n  predicate isUrlValidated() {\n    // Checks for any method that validates the URL\n    exists(MethodInvocation mi | \n      mi.getTarget().getType().getName() = \"System.Uri\" and\n      (mi.getName"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of vulnerability that allows an attacker to execute arbitrary commands on a vulnerable system. This vulnerability occurs when an application takes user input and passes it directly to a system command without sufficient validation. The attacker can then inject malicious commands into the application, which are then executed by the system. This can allow an attacker to gain access to sensitive information or make changes to the system.",
      "vulnerable_code": "string userInput = Console.ReadLine();\nProcess.Start(\"cmd.exe\",\"/c \" + userInput);\n\nThis code is vulnerable to command injection as it does not properly handle user input. An attacker could pass malicious input to the program, which would be executed without validation.",
      "remediation": "// Before Remediation \nstring cmd = \"dir\" + input;\nSystem.Diagnostics.Process.Start(\"cmd.exe\",cmd);\n\n// After Remediation \nstring cmd = \"dir\";\nSystem.Diagnostics.Process.Start(\"cmd.exe\",cmd);\nstring[] args = input.Split(\" \");\nSystem.Diagnostics.Process.Start(\"cmd.exe\",cmd + string.Join(\" \", args));",
      "semgrep_rule": "rule = { \n    meta: \n        description = \"Detects command injection vulnerabilities\"\n    source: \n        language = \"Csharp\"\n    patterns: \n        - pattern: \n            multi-patterns: \n                - '\" | cmd.exe /c \\\"'\n                - 'System.Diagnostics.Process.Start(\"'\n    message: \"Command injection vulnerability detected\"\n}",
      "codeql_rule": "import csharp\n\nclass CWE077ImproperCommandInjection : CodeQLSecurityVulnerability {\n  CWE077ImproperCommandInjection() {\n    super(\"CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')\");\n  }\n\n  override predicate isVulnerable(Method m) {\n    // Look for methods that use user-provided input to construct a command\n    m.getInstructions()\n    .matching(\n      Instruction.Call(Method.Named(\"System.Diagnostics.Process.Start\"),\n                       _,\n                       // The second argument of Start() is a string that is passed to the shell\n                       Instruction.LoadConst(userInput)\n                      )\n    )\n  }\n}"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "Improper Certificate Validation is a vulnerability that occurs when an application fails to properly validate digital certificates. This can allow an attacker to use forged or otherwise maliciously created certificates to bypass authentication and authorization, hijack sensitive data, or launch man-in-the-middle attacks. Improper certificate validation can also lead to an application trusting a malicious certificate presented by an attacker, leading to a variety of security issues.",
      "vulnerable_code": "// This code does not validate the server certificate properly\nHttpWebRequest request = (HttpWebRequest)WebRequest.Create(\"https://www.example.com/\");\nrequest.ServerCertificateValidationCallback = (sender, certificate, chain, sslPolicyErrors) => true;\nHttpWebResponse response = (HttpWebResponse)request.GetResponse();",
      "remediation": "using System.Security.Cryptography.X509Certificates;\n\n// Check the certificate chain\nbool VerifyCertificateChain(X509Certificate2 certificate)\n{\n    X509Chain chain = new X509Chain();\n    chain.ChainPolicy.RevocationMode = X509RevocationMode.Online;\n    chain.ChainPolicy.RevocationFlag = X509RevocationFlag.EntireChain;\n    chain.ChainPolicy.VerificationTime = DateTime.Now;\n    chain.ChainPolicy.UrlRetrievalTimeout = TimeSpan.FromSeconds(10);\n    chain.ChainPolicy.VerificationFlags = X509VerificationFlags.AllowUnknownCertificateAuthority;\n    \n    if (!chain.Build(certificate))\n    {\n        return false;\n    }\n\n    foreach (X509ChainElement element in chain.ChainElements)\n    {",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects Improper Certificate Validation vulnerability\"\n      author = \"Your Name\"\n      id = \"CWE-295\"\n      references = \"https://cwe.mitre.org/data/definitions/295.html\"\n    strings:\n      $cert_validation = /(?i)\\b(ssl|tls|certificate)\\b.*\\b(validate|verify|authenticate)\\b/\n    condition:\n      $cert_validation\n}",
      "codeql_rule": "import csharp\n\nclass ImproperCertificateValidationVulnerability {\n  //This query looks for classes that contain methods that call X509Certificate2.Verify()\n  // without passing a parameter to set the revocation flag\n  // as this allows the possibility of a man-in-the-middle attack\n  // to take place.\n  private static Method X509Certificate2Verify =\n    method(\"System.Security.Cryptography.X509Certificates.X509Certificate2.Verify() : void\");\n\n  public predicate isVulnerable() {\n    //The query looks for classes that contain the X509Certificate2.Verify() method\n    // but does not pass in a parameter to set the revocation flag\n    // The parameter is called 'showUI' and is a boolean\n    exists(Method m, Parameter p |\n      m.getContainingType() == this"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 describes a vulnerability where untrusted input is used to generate code that is then executed in the system. This type of vulnerability can occur when a program takes user-supplied input, such as a data string, and uses it to dynamically generate code. This code can then be executed as part of the program, creating a vulnerability that can be exploited by an attacker. In the worst case, the attacker can use this vulnerability to inject malicious code into the system, allowing them to gain control of the system.",
      "vulnerable_code": "string input = Console.ReadLine();\nProcess.Start(\"cmd.exe\", \"/c \" + input);\n\nThis code is vulnerable to code injection because it allows user input to be passed directly to the Process.Start command without any sanitization or validation. This can allow an attacker to inject malicious code into the system, potentially allowing for remote code execution.",
      "remediation": "Example:\n\n// Before\nstring command = Request.QueryString[\"cmd\"];\nProcess.Start(command);\n\n// After\nstring command = Request.QueryString[\"cmd\"];\nif (IsValidCommand(command))\n{\n    Process.Start(command);\n}\nelse\n{\n   // Handle invalid command\n}\n\n// IsValidCommand() is a custom validation function to ensure that only safe commands are executed.",
      "semgrep_rule": "rule = {\n  strings:\n    $cmd = /.+/\n  condition:\n    $cmd\n}",
      "codeql_rule": "import csharp\n\nclass ImproperControlOfGenerationOfCode extends SecurityCodeScannerRule {\n  // Define the query for the rule\n  Query query() {\n    // Find all instances of System.Diagnostics.Process.Start\n    ProcessStart[] starts = ProcessStart.all;\n    // Filter for only calls that accept user input\n    starts = starts.select(s | s.HasUserInput)\n    // Return the results\n    return starts;\n  }\n\n  // Provide a description\n  Description description() {\n    return Description(\"CWE-094: Improper Control of Generation of Code (Code Injection)\");\n  }\n \n  // Provide a remediation\n  Message remediation() {\n    return Message(\"Ensure that user input is sanitized before being passed to System.Diagnostics.Process.Start.\");\n  }\n}"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 Improper Privilege Management is a vulnerability that arises when an application or system does not properly manage user privileges. This can be caused by granting excessive privileges to users, not properly restricting access to certain resources, or failing to properly assign privileges to users. Attackers may be able to take advantage of this vulnerability to gain access to resources that should not be accessible to them, or to elevate their privileges to gain access to more sensitive resources. Additionally, attackers may be able to use this vulnerability to impersonate other users, bypass authentication, or elevate privileges to become a superuser.",
      "vulnerable_code": "public class VulnerableClass\n{\n    public void DoSomething()\n    {\n        // Get the current user's credentials\n        string username = System.Security.Principal.WindowsIdentity.GetCurrent().Name;\n\n        // Give the current user elevated privileges \n        System.Security.Principal.WindowsPrincipal principal = \n            new System.Security.Principal.WindowsPrincipal(\n                System.Security.Principal.WindowsIdentity.GetCurrent());\n        principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);\n    }\n}",
      "remediation": "The best way to remediate CWE-269 is to ensure that user privileges are managed correctly. This can be done by making sure that only the necessary privileges are granted to each user, and that they are not given privileges that could be used to gain unauthorized access to data. Additionally, user privileges should be periodically reviewed and revoked when no longer needed. Finally, it is important to ensure that privilege escalation attacks are prevented by implementing strong authentication measures, such as multi-factor authentication.",
      "semgrep_rule": "rule = {\n    strings:\n    // Detects any assignments to a user's privilege level\n    $privilege_level = *\n    \n    condition: $privilege_level\n}",
      "codeql_rule": "import csharp\n\nclass CWE269ImproperPrivilegeManagement extends Query {\n    private BooleanExpression isPublicMethod = \n        (m: Method) => m.access == Access.PUBLIC;\n\n    private BooleanExpression isWriteFileMethod = \n        (m: Method) => m.getName().matches(\"WriteFile\");\n    \n    private BooleanExpression isCreateFileMethod = \n        (m: Method) => m.getName().matches(\"CreateFile\");\n\n    private BooleanExpression isSetAccessControlMethod = \n        (m: Method) => m.getName().matches(\"SetAccessControl\");\n\n    query hasVulnerability() {\n        Method.find(isPublicMethod, isWriteFileMethod\n            or isCreateFileMethod, isSetAccessControlMethod).hasAtLeast(3)\n    }\n}"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is a vulnerability which occurs when input provided by a user is used in an Expression Language (EL) statement without proper neutralization. This can lead to attackers manipulating the EL statement in order to execute dangerous commands or access sensitive data. These attacks can be performed by injecting specially crafted input into the application which can then be executed by the EL statement. The application may also be vulnerable if it uses user-supplied input as part of an EL statement without properly validating or sanitizing it first.",
      "vulnerable_code": "string name = Request.QueryString[\"name\"];\nstring sqlQuery = \"SELECT * FROM Users WHERE Name=\" + name;\nSqlCommand command = new SqlCommand(sqlQuery, connection);\nSqlDataReader reader = command.ExecuteReader();\n\nIn this example, the code does not properly sanitize user input for the \"name\" parameter before using it as part of a SQL query. This can lead to an Expression Language Injection vulnerability, which can allow an attacker to manipulate the SQL query to gain access to sensitive information or execute malicious code.",
      "remediation": "Example 1:\n\n//Pre-remediation\nString queryString = \"SELECT * FROM Users WHERE Id = \" + userId;\n\n//Remediation\nString queryString = \"SELECT * FROM Users WHERE Id = @userId\";\nSqlCommand cmd = new SqlCommand(queryString);\ncmd.Parameters.Add(\"@userId\", userId);",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tdescription = \"Detects CWE-917 Improper Neutralization of Special Elements used in an Expression Language Statement\"\n\t\tauthor = \"Your Name\"\n\t\tdate = \"YYYY-MM-DD\"\n\t\treference = \"CWE-917\"\n\t\ttags = [\"security\", \"cwe-917\"]\n\t\tseverity = \"CRITICAL\"\n\t\tconfidence = \"HIGH\"\n\t\t\n\tpattern: \n\t\texpression:\n\t\t\t\"${.*?}\"\n\t\t\t\n\t\tmessage:\n\t\t\t\"Possible CWE-917 Improper Neutralization of Special Elements used in an Expression Language Statement\"\n\t\t\t\n}",
      "codeql_rule": "import csharp\n\nclass ExpressionLanguageInjection:\n\n    // Rule to detect improper neutralization of special elements used in an expression language statement\n    // that may lead to expression language injection\n    rule ExpressionLanguageInjection {\n        // Finds calls to methods that use an expression language\n        // statement with user input\n        when\n            m1 := csharp.Method(\"<expression language method>\")\n            p1 := csharp.Parameter(m1, 0)\n            u1 := csharp.UserInput(p1)\n        then\n            // Warns of potential expression language injection\n            csharp.reportWarning(\"Expression language injection detected\", u1)\n    }"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "The CWE-059 vulnerability is a type of security issue that can occur in software when a program is able to gain access to files on a system without ensuring that the files are legitimate. This type of vulnerability can occur when an application follows a link to an external source, such as a web page or file, without checking that the target is valid before accessing it. This type of vulnerability can result in malicious code being executed on the system or sensitive data being exposed.",
      "vulnerable_code": "string fileName = \"C:\\\\Users\\\\user\\\\Documents\\\\file.txt\";\nFile.Open(fileName, FileMode.Open);\n\nIn the above code, the application does not check the validity of the file path prior to attempting to open the file. This can lead to the application attempting to open a file that does not exist, or a malicious file that has been placed in the same directory as the application.",
      "remediation": "The following code shows an example of remediation for this vulnerability:\n\n// Before file access, check that the path is valid and canonicalized \nstring path = Path.GetFullPath(requestedPath);\nif (!Path.IsPathRooted(path))\n{\n    throw new SecurityException(\"Path not rooted\");\n}\n\n// Check to see if the path is within the allowed directory structure\nstring canonicalizedAllowedPath = Path.GetFullPath(allowedPath);\nif (!path.StartsWith(canonicalizedAllowedPath))\n{\n    throw new SecurityException(\"Path not allowed\");\n}\n\n// All checks passed so the file can now be accessed safely\nFileStream fs = File.OpenRead(path);",
      "semgrep_rule": "rule = {\n\tmeta:\n\t  description = \"Detects improper link resolution before file access\"\n\t  id = \"CWE-059\"\n\t  author = \"Signed security\"\n\t  severity = \"MEDIUM\"\n\t\n\tsource:\n\t  include = \"**/*.cs\"\n\t  \n\tstrings:\n\t  $fopen_str = \"File.Open(\"\n\t  $link_str = \"Link(\"\n\t  \n\tcondition:\n\t  $fopen_str and not $link_str\n}",
      "codeql_rule": "import csharp\n\nclass CWE059ImproperLinkResolutionBeforeFileAccess extends Query {\n  // Finds calls to System.IO.File.Open that \n  // access files without first verifying the path\n  predicate isFileOpenCall(Expr filePathExpr, Expr fileModeExpr, Expr fileAccessExpr) {\n    exists(MethodInvocation mi |\n      mi.getTarget().matchesName(\"System.IO.File.Open\") and \n      mi.getArgument(1).equals(filePathExpr) and\n      mi.getArgument(2).equals(fileModeExpr) and\n      mi.getArgument(3).equals(fileAccessExpr)\n    )\n  }\n\n  // Finds calls to System.IO.File.Open that \n  // access files without first verifying the path\n  predicate is"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information is transmitted in plaintext without being encrypted. This can occur when sensitive data is sent over an unsecured network, such as the internet, or when it is stored in cleartext on a computer system. This type of vulnerability can lead to data breaches and other security issues. Attackers can easily access this sensitive data and use it to gain access to other areas of a system or to steal the data. By not encrypting sensitive information, organizations are leaving their data open to potential malicious actors.",
      "vulnerable_code": "string username = \"admin\";\nstring password = \"password\";\n\n//Connect to database\nSqlConnection conn = new SqlConnection(\"Data Source=localhost;User Id=\" + username + \";Password=\" + password);\nconn.Open();",
      "remediation": "Remediation for this vulnerability involves implementing encryption for any sensitive data transmission. For example, if a website is transmitting sensitive user data over the internet, the website should use encryption protocols such as SSL/TLS or IPSec. This will ensure that the data is encrypted and not readable by any malicious third-party. Additionally, the website should also use secure authentication methods, such as two-factor authentication, to prevent unauthorized access to the data.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects cleartext transmission of sensitive information\"\n    severity = \"high\"\n  strings:\n    $sensitive_info = /[a-zA-Z0-9_\\-.]+@[a-zA-Z0-9_\\-.]+/\n  expressions:\n    $sensitive_info\n}",
      "codeql_rule": "import csharp\n\nclass CleartextTransmissionVulnerability {\n  // Finds any instance of sensitive information being sent over an insecure connection\n  // without encryption.\n  //\n  // @cwe CWE-319\n  //\n  // @example\n  //  // Example vulnerable code\n  //  var webRequest = WebRequest.Create(\"http://example.com\");\n  //  webRequest.Method = \"POST\";\n  //  webRequest.ContentType = \"text/plain\";\n  //  webRequest.ContentLength = data.Length;\n  //  using (var streamWriter = new StreamWriter(webRequest.GetRequestStream()))\n  //  {\n  //    streamWriter.Write(data);\n  //  }\n  //\n  // @example\n  //  // Example secure code\n  //  var webRequest = WebRequest.Create(\"https"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 is a type of vulnerability that allows attackers to redirect users from a trusted website to an untrusted one. This can be done by manipulating the URL of the website, inserting malicious code, or using malicious redirects. When a user visits the trusted website, they are unknowingly redirected to the untrusted site, which can be used to collect sensitive data or execute malicious code. This vulnerability can be exploited by attackers to gain access to confidential data or perform malicious activities, such as phishing or malware distribution.",
      "vulnerable_code": "// vulnerable code example\n\nstring redirectUrl = Request.QueryString[\"redirectUrl\"]; \n\nif (!string.IsNullOrEmpty(redirectUrl)) \n{ \n    Response.Redirect(redirectUrl); \n}",
      "remediation": "// Before Remediation\npublic ActionResult Redirect(string url)\n{\n    return Redirect(url);\n}\n\n// After Remediation\npublic ActionResult Redirect(string url)\n{\n    if (string.IsNullOrWhiteSpace(url))\n    {\n        return BadRequest();\n    }\n\n    // whitelist of trusted domains\n    string[] trustedDomains = { \"example.com\", \"example.org\" };\n    Uri uri;\n    if (Uri.TryCreate(url, UriKind.Absolute, out uri) && trustedDomains.Contains(uri.Host))\n    {\n        return Redirect(url);\n    }\n    else\n    {\n        return BadRequest();\n    }\n}",
      "semgrep_rule": "rule = {\n  id: \"cwe-601-open-redirect\",\n  patterns: [\n    {\n      pattern: \"{string_lit:url}\",\n      qualifiers: [{\n        qualifier: \"location\",\n        kind: \"URL\"\n      }]\n    },\n    {\n      pattern: \"Response.Redirect({string_lit:url})\",\n      qualifiers: [{\n        qualifier: \"location\",\n        kind: \"URL\"\n      }]\n    }\n  ],\n  message: \"URL redirection to untrusted site detected: {{url}}\",\n  severity: \"error\"\n}",
      "codeql_rule": "import csharp\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass OpenRedirectVulnerability : CodeQLSecurityVulnerability {\n    // Look for a method that takes a URL as an argument\n    // and checks if the domain is trusted\n    predicate isTrustedDomainCheck(MethodCall m) {\n        exists(string s,\n            m.getArgument(0).asExpr() = s.toExpr()\n            and m.getTarget().getName().matches(\"*isTrustedDomain*\")\n        ) \n    }\n    \n    // Check for a method that takes a URL as an argument\n    // and redirects the user to the given URL\n    predicate isRedirect(MethodCall m) {\n        exists(string s,\n            m.getArgument(0).asExpr() = s.toExpr()"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability that occurs when sensitive information, such as passwords, usernames, or other confidential data, is inadvertently inserted into a log file. This can occur when programs are not properly configured to protect and filter sensitive data before it is written to a log file. Attackers can potentially gain access to this data, leading to potential data breaches or other malicious activity.",
      "vulnerable_code": "string username = \"exampleuser\";\nstring password = \"examplepassword\";\n\n// Log the user information in a file\nFile.AppendAllText(\"log.txt\", \"Username: \" + username + \" Password: \" + password);",
      "remediation": "The application should be designed to avoid the insertion of sensitive information into log files. This can be done in a number of ways, such as:\n\n-Creating separate log files for sensitive information and non-sensitive information\n-Ensuring that any sensitive information is encrypted before being written to a log file\n-Limiting access to log files to authorized personnel only\n-Ensuring that any log files are regularly monitored for suspicious or malicious activity.",
      "semgrep_rule": "rule = {\n    strings:\n    // Sensitive information\n    $sensitive_info = /(password|credit card number|social security number)/\n    // Logging\n    $logging = /(log|write)/\n    // Sensitive information being logged\n    $log_sensitive_info = /$sensitive_info $logging/\n   \n    condition: $log_sensitive_info \n}",
      "codeql_rule": "import csharp\n\nclass CWE532_Insertion_Of_Sensitive_Information_Into_Log_File extends Rule {\n    // Find any calls to a logging function\n    // that contain sensitive information\n    // as an argument\n    //\n    // e.g. log.Info(\"User password: \"+password);\n    //\n    // Note: This rule won't detect all cases as it may not\n    // be possible to identify sensitive information\n    // without additional context\n   \n    // Find any logging functions\n    predicate logFunctions() {\n        exists(Method m |\n            m.getDeclaringType().getName().matches(\"ILog\")\n            and m.getName().matches(\"Info|Warn|Error|Fatal\"))\n    }\n    \n    // Find any sensitive data from the parameters\n    // of a function call\n    predicate sensitiveData"
    }
  },
  "Swift": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of vulnerability that occurs when a malicious script is injected into an application. This script is then executed by a user's browser, allowing attackers to gain access to sensitive information, such as cookies or session tokens. In the case of Swift, this vulnerability can arise when user-supplied data is not properly sanitized before being included in the generated webpage, allowing attackers to inject malicious scripts that can be executed in the user's browser.",
      "vulnerable_code": "let userInput = \"Hello <script>alert('XSS');</script>\"\n\nlet output = \"<h1>\\(userInput)</h1>\"\n\nprint(output)",
      "remediation": "// Before\nlet name = request.value(forKey: \"name\")\nlet html = \"<html><body><h1>Welcome, \\(name)!</h1></body></html>\"\n\n// After\nlet name = request.value(forKey: \"name\")\nlet html = \"<html><body><h1>Welcome, \\(name.sanitizedForHTML())!</h1></body></html>\"",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: \"\\\\[.*?\\\\]\\\\(.*?\\\\)\",\n      message: \"Potential Cross-site Scripting vulnerability detected, consider validating user input before generating web page\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe079\n\nclass CWE079Rule extends Rule {\n  // Define the query\n  query CWE079Rule() {\n    // Identify a potential vector of attack\n    Vector v = InputVector()\n    // Find a vulnerable context\n    VulnerableContext ctx = VulnerableContext.find(v)\n    // Report any vulnerable contexts\n    report ctx\n  }\n}"
    },
    "CWE-020: Improper Input Validation": {
      "description": "Improper input validation is a vulnerability that occurs when an application does not validate or properly sanitize user input before using it. This can allow malicious users to inject malicious code into the application, which can be used to gain access to sensitive information or perform malicious actions.",
      "vulnerable_code": "let inputString = \"12345\"\nlet intValue = Int(inputString)\n\nif intValue! > 5 {\n    // Do something\n}\n\n// This code is vulnerable to CWE-020 because it does not properly validate the input string and could lead to unexpected results if the input string is not a valid integer.",
      "remediation": "// Remediation\nfunc validateInput(input: String) -> Bool {\n    let validInputs = [\"foo\", \"bar\", \"baz\"]\n    if validInputs.contains(input) {\n        return true\n    } else {\n        return false\n    }\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-020\",\n  pattern: \"{left: /(let|var) +[a-zA-Z]+ *=/ *\\\\d+/, right: /}/, message: \"Improper input validation detected\"}",
      "codeql_rule": "import cwe020\n\nclass CWE020ImproperInputValidation:\n \n    // Rule to detect if user input is not properly validated\n    // before being used.\n   \n    // Finds functions that have arguments which are used without\n    // validating them.\n\n    // Finds variables which are set from a function call\n    // without validating the input.\n\n    // Finds variables which are set from user input\n    // without validating the input.\n \n    // Finds unsafe type casts that could lead to\n    // improper input validation.\n    \n    // Finds functions which take user input without\n    // validating it.\n    \n    // Finds calls to functions that are vulnerable to\n    // improper input validation.\n \n    // Finds code which does not properly validate user\n    // input before being used.\n    \n    // Finds code which does not"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "OS Command Injection is a type of vulnerability in which an attacker can execute arbitrary system commands by manipulating input data sent to an application or system. This vulnerability is caused by a lack of proper input validation and sanitization, allowing attackers to modify their input in a way that can execute malicious commands on the system. These commands can be used to gain access to sensitive data, alter or delete files, and even execute malicious code. This vulnerability can be exploited by malicious actors to gain unauthorized access to a system and cause significant damage.",
      "vulnerable_code": "//In this example, a user input is passed as an argument to the 'system()' function call without any validation or sanitization.\n\nlet userInput = \"rm -rf /\"\nsystem(userInput)",
      "remediation": "// The following code can be used to prevent OS Command Injection\n\nlet userInput = \"someInput\"\n\nlet allowedCharacters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\nif userInput.rangeOfCharacter(from: CharacterSet(charactersIn: allowedCharacters).inverted) == nil {\n    // Proceed with userInput\n} else {\n    // Exit immediately\n}",
      "semgrep_rule": "rule = [{\n    \"id\": \"CWE-078\",\n    \"severity\": \"warning\",\n    \"message\": \"Possible OS Command Injection detected\",\n    \"pattern\": [\n        {\n            \"regexp\": \"(system|popen|execvp?|spawnvp?|spawnlp?|execlp?|fork|wait|systemf|exec|spawnl|spawnv|execl|spawn)\",\n            \"modifiers\": \"i\",\n            \"inverse\": true\n        },\n        {\n            \"regexp\": \"(.*)(\\\\s*)(\\\\S+)(\\\\s*)\\\\(\",\n            \"modifiers\": \"i\"\n        }\n    ]\n}]",
      "codeql_rule": "import cwe\n\nclass CWE_078_OS_Command_Injection:\n  // Rule checks for the use of user input in OS commands.\n  // A vulnerable line of code may look like this:\n  // system(\"rm -rf \" + userInput)\n \n  // Declare a query to find the relevant code\n  query vulnerableCode {\n    decl _userInput as String\n    // Find the use of user input in system calls\n    SystemCall.withArg(_userInput)\n  }\n  \n  // Report the finding  \n  vulnerableCode\n  => issue(\"CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\", cwe.CWE_078)"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "SQL injection occurs when an attacker is able to inject malicious SQL code into an application, allowing them to gain access to or modify the underlying database. This can be done by exploiting the dynamic queries used by the application, or by exploiting user input that is not correctly sanitized and validated. By doing so, attackers can bypass authentication, delete or modify data, or even gain access to other systems.",
      "vulnerable_code": "let query = \"SELECT * FROM users WHERE username = '\\(username)'\"\nlet result = try database.executeQuery(query)",
      "remediation": "// Example of Remediation\n\n// Using Prepared Statements to prevent SQL injection\n\nlet statement = \"SELECT * FROM User WHERE email = ?\"\nlet email = \"user@example.com\"\n\nlet preparedStatement = try db.prepare(statement)\nlet queryResults = try preparedStatement.run([email])\n\nfor row in queryResults {\n    // do something with each row\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects potential SQL injection vulnerabilities\"\n    id = \"CWE-089\"\n    severity = \"WARNING\"\n  strings:\n    $s1 = \"SELECT\"\n    $s2 = \"INSERT\"\n    $s3 = \"UPDATE\"\n    $s4 = \"DELETE\"\n    $s5 = \"TRUNCATE\"\n    $s6 = \"EXEC\"\n    $s7 = \"DROP\"\n  condition:\n    ($s1 or $s2 or $s3 or $s4 or $s5 or $s6 or $s7)\n}",
      "codeql_rule": "import cwe089\n\nclass CWE089_SQLInjection:\n    def __init__(self):\n        self.cwe089_error_message = \"Possible SQL injection vulnerability found\"\n\n    def CWE089_detect_vulnerability(self):\n        vulnerable_query = cwe089.find_vulnerable_query()\n        if vulnerable_query:\n            cwe089.report_error(self.cwe089_error_message, vulnerable_query)"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal (also known as directory traversal) is a vulnerability that occurs when an attacker uses a relative pathname to gain access to directories outside of the intended directory. This vulnerability is often exploited by malicious actors to gain access to sensitive files and data. For example, a web application could be vulnerable to path traversal if it accepts a user-supplied filename without properly validating it, allowing the user to traverse outside of the intended directory. This could result in the attacker accessing sensitive files, such as system configuration information, or even allowing them to run arbitrary code on the server.",
      "vulnerable_code": "let path = \"../../../../etc/passwd\"\nlet file = try! Data(contentsOf: URL(fileURLWithPath: path))",
      "remediation": "// Swift\n\n// Before Remediation\nlet filePath = \"/User/Documents/\\(userInput)\"\n\n// After Remediation\nlet filePath = \"/User/Documents/\\(userInput.addingPercentEncoding(withAllowedCharacters: .alphanumerics) ?? \"\")\"",
      "semgrep_rule": "rule = {\n    meta:\n        id = \"CWE-022\"\n        description = \"Detects Path Traversal\"\n        severity = \"CRITICAL\"\n        author = \"Semgrep\"\n    source:\n        language = \"Swift\"\n    detection:\n        any:\n            - pattern: |\n                open(_ fname: String, _ mode: String,\n                pathContains(\"..\")\n            - pattern: |\n                NSURL(fileURLWithPath:\n                pathContains(\"..\")\n}",
      "codeql_rule": "// Create the CodeQL query to detect the vulnerability\nimport cwe022\n\nclass PathTraversalVulnerability extends Vulnerability {\n    PathTraversalVulnerability() {\n        this.cwe = cwe022\n    }\n    \n    // This predicate returns true if the given method takes a file path as parameter\n    predicate isFilePath(Method m) {\n        exists(Parameter p | m.getParameters().contains(p) and p.getType().isSubtypeOf(\"String\") and p.hasAnnotation(\"Path\"))\n    }\n    \n    // This predicate returns true if the given method sanitizes the file path\n    predicate isSanitized(Method m) {\n        exists(Call c | c.getTarget().getName() =~ \".*sanit.*\" and m.getCalls().contains(c))\n    }\n    \n    // This predicate"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-Site Request Forgery (CSRF) is a type of web security vulnerability that allows an attacker to remotely execute malicious requests on behalf of a legitimate user. In a CSRF attack, a malicious actor tricks a legitimate user into making a request to a vulnerable web application without their knowledge. This type of attack can be used to modify the user\u2019s data, delete data, or even gain access to sensitive information. In the case of Swift, CSRF attacks can be performed by sending a malicious request from a legitimate user's browser that interacts with the vulnerable application. This type of attack is especially dangerous because the malicious request can be sent from the user\u2019s browser without their knowledge or consent.",
      "vulnerable_code": "This example of vulnerable code shows an action endpoint that is vulnerable to Cross-Site Request Forgery (CSRF) attacks: \n\n@IBAction func transferMoney(_ sender: Any) {\n    let parameters = [\"amount\": amountTextField.text ?? \"\",\n                      \"recipient\": recipientTextField.text ?? \"\"]\n    \n    let url = URL(string: \"https://example.com/transferMoney\")!\n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n \n    // Note: This code is vulnerable to CSRF attack as it does not include any anti-CSRF token\n    request.httpBody = parameters.percentEscaped().data(using: .utf8)\n    let task = URLSession.shared.dataTask(with: request) { data, response, error in\n        guard let data = data,\n            let",
      "remediation": "The best way to remediate a Cross-Site Request Forgery (CSRF) vulnerability is to implement a CSRF token. A CSRF token is a unique, secret, unpredictable value that is generated by the server and included in the HTML form or in the URL. When the form or the URL is submitted, the server checks the request to make sure that the CSRF token included in the request is valid. If the token is not valid or is missing, the request is blocked.\n\nExample implementation of CSRF token in Swift:\n\n// Generate a CSRF token\nlet csrfToken = UUID().uuidString\n\n// Store the CSRF token in the user's session\nsession[.csrfToken] = csrfToken\n\n// Include the CSRF token in the HTML form\n<input type=\"hidden\" name=\"csrfToken\" value=\"\\(csrfToken)\" />\n\n// Validate",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects Cross-Site Request Forgery (CSRF)\"\n        severity = \"CRITICAL\"\n    source:\n        lang = \"swift\"\n    patterns:\n        - pattern: \n            message: |\n                \"GET\"\n            negated: true\n        - pattern: \n            message: |\n                \"POST\"\n            negated: true\n        - pattern:\n            message: |\n                \"PUT\"\n            negated: true\n        - pattern:\n            message: |\n                \"DELETE\"\n            negated: true\n        - pattern:\n            message: |\n                \"PATCH\"\n            negated: true\n        - pattern:\n            message: |\n                \"dataTask(with:)\"\n            negated: false\n        - pattern:\n            message: |\n                \"check",
      "codeql_rule": "import cwe352\n\nclass CrossSiteRequestForgeryVulnerability:\n  // Rule to detect code that is vulnerable to Cross-Site Request Forgery (CSRF)\n  CWE352\n  {\n    // Find any methods that do not have a CSRF token\n    // as a parameter or in the body\n    method\n    {\n      // Check that the method does not contain a CSRF token\n      not exists(Parameter p | p.hasAnnotation(\"CSRFToken\")) and\n      not exists(MethodCall mc | mc.getTarget().hasAnnotation(\"CSRFToken\"))\n    }\n  }"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability that occurs when an application allows users to upload files without restrictions on the type of file. This can lead to malicious files being uploaded, such as scripts or executable programs, which can be used to compromise the system. Additionally, since unrestricted file uploads can allow for large files to be uploaded, this could cause a denial of service attack by exhausting system resources.",
      "vulnerable_code": "let fileURL = Bundle.main.url(forResource: \"dangerousFile\", withExtension: \"exe\")\nlet fileData = try? Data(contentsOf: fileURL!)\nlet fileName = \"dangerousFile.exe\"\nlet uploadPath = \"uploads/\" + fileName\n\nlet fileManager = FileManager.default\ntry? fileManager.copyItem(atPath: fileURL!.path, toPath: uploadPath)",
      "remediation": "First, a whitelist of allowed file extensions should be created and enforced. This whitelist should include only safe file types such as .jpg, .txt, .pdf, etc. Any files with an extension not in the whitelist should be blocked from being uploaded.\n\nAdditionally, a content type check should be performed when a file is uploaded. This ensures that the file is actually the type of file that the user claims it is. For example, if a user uploads a file with a .jpg extension, the content type should be checked to ensure that it is actually a JPEG image file. If the content type check fails, the file should be rejected.",
      "semgrep_rule": "rules:\n  - id: unrestricted_upload\n    files:\n      - '*.swift'\n    message: 'Unrestricted Upload of File with Dangerous Type'\n    expression: |\n      let fileName := /[^/]+\\.(?P<extension>[^/\\.]+)$/\n      let dangerousExtensions := [\"exe\", \"dll\", \"bat\", \"sh\"]\n      fileName.extension in dangerousExtensions",
      "codeql_rule": "import cwe\nimport swift\n\nclass UnrestrictedUploadOfDangerousFileType:\n \n    // Find any FileUpload functions\n    FileUpload = method(m:swift.FunctionDeclaration)\n    {\n        m.name =~ /.*upload.*/i \n    } \n    \n    // Get any file extensions used in the FileUpload function\n    FileExtension = FileUpload.body.containsSubstring(pattern:\"\\\\.\\\\w*$\")\n \n    // Search for any dangerous file extensions\n    DangerousFileExtension = FileExtension.literal.stringValue matches regex \"\\\\.(exe|bat|bin|sh)$\"\n \n    // Flag any unrestricted upload of dangerous file type\n    flag cwe`CWE-434` for DangerousFileExtension\n\n}"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "This vulnerability occurs when a critical function within an application or system does not require authentication in order to access and manipulate data. Without authentication, any user can access confidential data and make changes to it, which can lead to data corruption, unauthorized access, or even malicious attacks. Additionally, this vulnerability can allow attackers to gain access to sensitive data, such as passwords and financial information.",
      "vulnerable_code": "// This code defines a function that allows a user to access restricted resources\nfunc accessRestrictedResources() {\n    // The function does not require any authentication\n    // The user can access the restricted resources without any authentication\n}",
      "remediation": "One way to remediate CWE-306 is to add an authentication layer to the application. This can be done by implementing an authentication system that requires users to provide a valid username and password before they can access the critical function. The authentication system should also be configured to use the latest security measures, such as two-factor authentication, to ensure the highest level of security. Additionally, the authentication system should be monitored regularly to ensure it is still secure, and any breaches should be addressed quickly.",
      "semgrep_rule": "rule = {\n    id = \"CWE-306-Missing-Authentication-For-Critical-Function\",\n    patterns = [\"if !authenticated()\"],\n    message = \"Missing authentication for critical function\", \n    severity = \"WARNING\"\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.security\n\nclass MissingAuthenticationCriticalFunction extends SecurityHardeningChecker {\n  public MissingAuthenticationCriticalFunction() {\n    super(\"Missing Authentication for Critical Function\");\n  }\n\n  @Override\n  Prediction canHardeningBeApplied(Cwe cwe, SemmleCode code) {\n    // CWE-306 is an authentication issue\n    if (cwe != Cwe.CWE_306) {\n      return Prediction.NO;\n    }\n    \n    // Check if the function is critical\n    if (!code.getFunction().isCritical()) {\n      return Prediction.NO;\n    }\n\n    // Check if the function is missing authentication\n    if (!code.getFunction().isMissingAuthentication()) {\n      return Prediction.NO;\n    }\n\n    return Prediction.YES;\n  }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability that occurs when an application deserializes untrusted data, allowing malicious data to be executed. This can lead to code execution, denial of service, or other malicious actions. The data could be from a file, a database, or from a network connection and can be exploited by an attacker to gain access to sensitive information or cause other malicious actions.",
      "vulnerable_code": "let jsonData = Data(bytes: [0x7b, 0x22, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x22, 0x42, 0x6f, 0x62, 0x22, 0x7d])\nlet decoder = JSONDecoder()\nlet user = try decoder.decode(User.self, from: jsonData)\n\n// Vulnerable code\nlet user = try! decoder.decode(User.self, from: jsonData)",
      "remediation": "// Before Remediation\nlet decodedData = try? JSONDecoder().decode(MyData.self, from: data)\n\n// After Remediation\nguard let decodedData = try? JSONDecoder().decode(MyData.self, from: data) else {\n    throw DeserializationError.invalidData\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-502-Deserialization-of-Untrusted-Data\",\n  patterns: [\n    {\n      pattern: \"{NSKeyedUnarchiver, NSSecureUnarchiver} unarchiveObjectWithData:\",\n      languages: [\"Swift\"]\n    }\n  ]\n}",
      "codeql_rule": "import swift\n\nclass DeserializationOfUntrustedDataCWE502Rule extends Rule {\n\n  // Rule metadata\n  string info = \"CWE-502: Deserialization of Untrusted Data\";\n\n  // Query for vulnerable code\n  query vulnerableQuery {\n    // Find calls to methods that deserialize untrusted data\n    call as untrustedCall where (\n      untrustedCall.name =~ \"deserialize.*\"\n    )\n    // Find the source of untrusted data\n    source as untrustedSource where (\n      untrustedSource.hasAncestor(untrustedCall)\n    )\n    // Find any of the untrusted sources without explicit validation\n    not exists(Validation v | untrustedSource.hasAncestor(v))\n  }\n\n  // Report any matches\n  protected violation() {\n    for (un"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability that occurs when an application fails to properly authenticate users before allowing them access. This can result in unauthorized access to sensitive data or systems, or the ability to perform malicious actions. This can also happen when authentication credentials are not properly validated or stored, allowing attackers to gain access with stolen credentials.",
      "vulnerable_code": "let username = \"admin\"\nlet password = \"password\"\n\nif username == \"admin\" && password == \"password\" {\n    // Allow user access\n} else {\n    // Deny user access\n}",
      "remediation": "The best way to remediate this type of vulnerability is to ensure that proper authentication measures are put in place. This would include implementing stronger authentication methods such as multi-factor authentication, using secure passwords, and using a secure authentication protocol. Additionally, any authentication processes should be monitored and tested regularly to ensure that they remain secure.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper authentication\"\n    author = \"security expert\"\n    severity = \"critical\"\n  source:\n    lang = \"swift\"\n  included:\n    strings:\n      - \"authentication\"\n      - \"login\"\n      - \"log in\"\n  detection:\n    condition: not strings.login and not strings.log in\n}",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthentication: Rule {\n  // Find all places where authentication is checked\n  predicate isAuthenticationCheck(Expr e) {\n    e.hasAncestor(FunctionDecl f) and f.getName() == \"authenticate\"\n  }\n  \n  // Find all if statements where authentication is checked\n  predicate isAuthenticationIfStatement(Expr e) {\n    e.hasAncestor(IfStmt ifs) and isAuthenticationCheck(ifs.getCondition())\n  }\n  \n  // Check if the authentication check is incorrect or insufficient\n  @Override\n  predicate isVulnerable(Expr e) {\n    isAuthenticationIfStatement(e) and cwe287.isVulnerable(e.getParent())\n  }\n  \n  @Override\n  void check(Expr e) {\n    if ("
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability where an application uses hard-coded credentials, such as passwords, to authenticate with a system or service. This means that the credentials are stored in the application's code, making them easily accessible to anyone who can view the code. This poses a security risk as these credentials can be used to gain unauthorized access to the system or service.",
      "vulnerable_code": "let username = \"admin\"\nlet password = \"password123\"\n\nlet authString = \"\\(username):\\(password)\"\nlet authData = authString.data(using: String.Encoding.utf8)!\nlet authValue = \"Basic \\(authData.base64EncodedString())\"\n\nlet headers: [String: String] = [\n    \"Authorization\": authValue\n]",
      "remediation": "// Remediation example\n\nlet username = \"\"\nlet password = \"\"\n\nfunc authenticateUser(username: String, password: String) {\n    // Check for hard-coded credentials\n    guard username != \"admin\" && password != \"admin\" else {\n        print(\"Hard-coded credentials detected\")\n        return\n    }\n\n    // Authenticate user\n    // ...\n}",
      "semgrep_rule": "rule = {\n    meta:\n        id = \"CWE-798\"\n        description = \"Detects the use of hard-coded credentials\"\n        author = \"Semgrep\"\n    source:\n        lang = \"swift\"\n    detection:\n        passwords:\n            regexp: \"username=\\\".*\\\" password=\\\".*\\\"\"\n            message: \"Hard-coded credentials detected\"\n}",
      "codeql_rule": "import cwe\n\nclass CWE_798_Hardcoded_Credentials:\n  vulnerability as cwe.Vulnerability {\n  cwe = \"CWE-798\"\n  }\n\n  // Find string literals with the word \"password\"\n  stringLiteral as LiteralString hasValue \"password\"\n \n  // Find assignments from string literals\n  assignment as Assignment from stringLiteral\n  \n  // Find declarations of variables used in assignments\n  decl as VariableDecl from assignment\n  \n  // Find the declarations used in credentials\n  credential as VariableDecl from assignment, decl.HasAnnotation(\"credential\")\n  \n  // Flag any hardcoded credentials\n  flag as Report from credential, assignment, stringLiteral, cwe.Vulnerability\n  where credential.HasAnnotation(\"credential\") and assignment.ToVariable = credential and stringLiteral.Value"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 is a vulnerability that occurs when default permissions are set incorrectly, allowing unauthorized users to access sensitive data or resources. This vulnerability can be exploited by setting weak or no permissions on files, directories, or other system resources, allowing malicious users to gain access to confidential data or system functionality. For example, if a file is set to 777 (read-write-execute for all users) instead of 644 (read-write for the owner, read for everyone else), an attacker could gain access to that file and modify or delete it.",
      "vulnerable_code": "// This code sets the default permissions on a file to world-writeable\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\nlet fileManager = FileManager.default\ntry? fileManager.setAttributes([.posixPermissions: 0o777], ofItemAtPath: fileURL.path)",
      "remediation": "// Remediate incorrect default permissions on a file\n\nlet filePath = \"<file path>\"\nlet fileManager = FileManager.default\n\nlet fileAttributes = [FileAttributeKey.posixPermissions: 0o755]\n\ndo {\n    try fileManager.setAttributes(fileAttributes, ofItemAtPath: filePath)\n} catch {\n    print(\"Error setting permissions: \\(error.localizedDescription)\")\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detect incorrect default permissions\"\n    author = \"Your name here\"\n  source:\n    source = \"swift\"\n  detection:\n    condition:\n      all:\n        - pattern:\n            regexp: \"\\\\.defaultPermissions\\\\s*=\\\\s*\\\\w*\\\\(\\\\s*[^\\\\)]*\\\\)\"\n            modifiers: \"s\"\n        - pattern:\n            regexp: \"\\\\w*\\\\(\\\\s*[^\\\\)]*\\\\)[^\\\\s]*\\\\s*\\\\.\\\\s*write\\\\b\"\n            modifiers: \"s\"\n}",
      "codeql_rule": "import cwe\nimport swift\n\nclass IncorrectDefaultPermissionsRule extends Rule {\n \n  // Query to detect incorrect default permissions\n  query IncorrectDefaultPermissions() {\n    // Find all declarations of fields and properties\n    FieldDecl | SwiftPropertyDecl(\n      // Make sure the fields or properties are not declared with a specific permission\n      permission => permission == cwe.Permission.Default\n    )\n  }\n \n  // Report an issue when the query finds an incorrect default permission\n  getIssueMessage(FieldDecl fd) {\n    return \"Field '\" + fd.name + \"' is declared with incorrect default permissions.\"\n  }\n \n  // Report an issue when the query finds an incorrect default permission\n  getIssueMessage(SwiftPropertyDecl spd) {\n    return \"Property '\" + spd.name + \"' is declared with incorrect default permissions.\""
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that occurs when sensitive information is exposed to an unauthorized actor. This type of vulnerability can occur when a system does not have proper authentication or access controls in place, allowing unauthorized actors to gain access to sensitive data. This type of vulnerability can also occur when unencrypted data is transmitted across insecure networks or stored in clear text on public-facing systems. In some cases, the information exposed can be used to gain access to other systems or even commit identity theft.",
      "vulnerable_code": "let password = \"myPassword123\"\nprint(password) // Prints \"myPassword123\"",
      "remediation": "Remediation of this vulnerability requires properly encrypting any sensitive information that is being transmitted or stored. Where possible, use industry standard encryption protocols such as TLS/SSL or AES. Additionally, make sure that the encryption keys are protected and stored securely. Finally, ensure that any and all sensitive data is accessed only by authorized users and that access is properly tracked and monitored.",
      "semgrep_rule": "rule = [\n  id = \"CWE-200\",\n  message = \"Possible exposure of sensitive information to an unauthorized actor.\",\n  expr = \"database.query($x) and not ($x in ['SELECT * FROM secure_table'])\",\n  severity = \"error\"\n]",
      "codeql_rule": "import cwe\nimport swift\n\nclass CWE_200_Vulnerability:\n    def get_sensitive_data():\n        return swift.select(\"Stmt\")\n        .where(lambda stmt: \n            stmt.isInstanceOf(\"Decl\") \n            and stmt.hasDescendant(\"StringLiteral\")\n        )\n        .hasDescendant(\"Identifier\", \n            lambda id: id.hasAnnotation(\"sensitive\")\n        )\n\n    def vulnerable_code():\n        return get_sensitive_data()\n        .where(lambda stmt:\n            stmt.hasAncestor(\"FunctionCall\")\n            and stmt.parent().isInstanceOf(\"PropertyWrapperValue\")\n            and stmt.hasAncestor(\"ClassDecl\")\n            and stmt.hasAncestor(\"StructDecl\")\n            and stmt.hasAncestor(\""
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a type of vulnerability that arises when credentials are not sufficiently protected. This type of vulnerability can occur when credentials are stored in plaintext or when access control measures are not in place to prevent unauthorized access to credentials. Additionally, this vulnerability can occur when credentials are transmitted over insecure channels, such as in plaintext over HTTP or FTP. This can leave credentials exposed to potential attackers, who can then gain access to the system or data that the credentials are meant to protect.",
      "vulnerable_code": "let username = \"admin\"\nlet password = \"password123\"\n\n// Vulnerable code\nlet userData = [username: password]\nlet success = checkUserData(userData)",
      "remediation": "Remediation for this vulnerability would involve implementing a more secure credential management system. This could include using a secure password manager, using two-factor authentication for authentication and authorization, and using a secure authentication protocol such as OAuth. Additionally, it is important to ensure that all passwords are stored in an encrypted format and that access to these passwords is restricted to only those who need it.",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects insufficiently protected credentials\"\n        severity = \"MEDIUM\"\n        reference = \"CWE-522\"\n    strings:\n        $cred1 = \"username\"\n        $cred2 = \"password\"\n        $cred3 = \"API key\"\n    condition:\n        any of ($cred*)\n}",
      "codeql_rule": "import swift\n\nclass InsufficientlyProtectedCredentials: CodeQLAnalysis {\n  predicate isCredentialAccess() {\n    exists(\n      Variable v,\n      MethodAccess ma,\n      Assignment a |\n        a.getAssignedValue() = v \n        and ma.getMethod() = v \n        and ma.getType() = \"credential\"\n    )\n  }\n  \n  predicate isCredentialStoredInString() {\n    exists(\n      Variable v,\n      Assignment a |\n        a.getAssignedValue() = v \n        and v.isString()\n    )\n  }\n\n  predicate isCredentialStoredInPlainText() {\n    isCredentialAccess() and isCredentialStoredInString()\n  }\n\n  query insufficientlyProtectedCredential() {\n    isC"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability that occurs when an XML document includes an external entity reference in an unsafe manner. This allows malicious actors to access data stored in external locations, or to execute arbitrary code on the vulnerable system. This can be exploited by an attacker sending crafted XML requests to a vulnerable system, which can then be used to gain unauthorized access to sensitive data or execute malicious code.",
      "vulnerable_code": "let xmlData = \"<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<!DOCTYPE foo [\n <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]> \n<results> \n  &xxe; \n</results>\"\n\nlet xmlDoc = try? XMLDocument(xmlString: xmlData, options: .documentTidyXML)",
      "remediation": "In Swift, it is possible to prevent XML external entity references by using the NSXMLParser class\u2019s setShouldProcessExternalEntities method. This method should be set to false, which will disable the processing of external entities.\n\nFor example, the following code snippet shows how to use the setShouldProcessExternalEntities method to disable external entity processing for an NSXMLParser instance:\n\nlet parser = NSXMLParser(data: data)\nparser.setShouldProcessExternalEntities(false)",
      "semgrep_rule": "description: Detect improper restriction of XML external entity reference\n\ncodesnippet: /\\bXMLParser\\b/\n\nseverity: warning\n\nconditions:\n\n- pattern: '!doctype\\s+\\w+\\s*\\[\\s*(\\s*<\\s*!\\s*entity\\s+\\w+\\s*system\\s+[^>]+>\\s*)+'\nmessage: \"This XML document contains an improper restriction of XML external entity reference.\"",
      "codeql_rule": "import cwe\nimport swift\n\nclass VulnCWE611 : CWE611\n\n{\n  // create a query to find instances of XML external entity references\n  // that have not been restricted\n  // this includes uses of the URL loading system\n\n  // find XML documents that have been parsed and loaded\n  // using the URL loading system\n  query xmlLoadedFromURL(){\n    let url = URL.init()\n    let xmlDoc = Document.init(contentsOf: url)\n    XMLDocument.parse(contentsOf: xmlDoc)\n  }\n  \n  // find references to external entities that are not properly\n  // restricted\n  query externalReference(){\n    // find references to external entities\n    XMLNode.referencesExternalEntities()\n    // find any reference that is not properly restricted\n    XMLNode.referencesExternalEntities() \n    and not External"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-side request forgery (SSRF) is a type of web application vulnerability that allows an attacker to send malicious requests from a vulnerable server to other systems or services. This type of attack can be used to gain access to private networks, sensitive data, or other restricted resources. In Swift, an SSRF vulnerability can occur if an application allows user-supplied input to be used as part of a URL, and does not properly validate the input. This can allow an attacker to send malicious requests from the vulnerable server to other systems or services, potentially bypassing access control mechanisms.",
      "vulnerable_code": "let urlString = \"http://[attacker controlled server]:8080\"\nlet url = URL(string: urlString)\nlet request = URLRequest(url: url!)\nlet task = URLSession.shared.dataTask(with: request) { data, response, error in\n    // Handle Response\n}\ntask.resume()",
      "remediation": "One way to remediate CWE-918 is to use a whitelist of allowed URLs or IP addresses when making requests from the server. This way, requests from malicious sources can be blocked from reaching the server. The following example in Swift shows how to create a whitelist of allowed IP addresses for making requests:\n\nlet allowedIPs = [\"127.0.0.1\",\"192.168.1.1\"]\n\nlet request = URLRequest(url: URL(string: \"https://example.com\"))\n\nif let remoteIP = request.remoteIP(), allowedIPs.contains(remoteIP) {\n    // Make request\n} else {\n    // Block request\n}",
      "semgrep_rule": "rule = {\n  id: \"cwe-918-ssrf-detection\"\n  patterns: [\n    {\n      pattern: 'URL(url:|.init|.init(string:)?|.absoluteString)? *?(=|==|<|>) *?(URL(Components|QueryItem)?|URLComponents|String|[\"']{1}http)',\n      message: \"Potential Server-Side Request Forgery (SSRF) vulnerability detected.\",\n      severity: \"WARNING\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe918\n\nclass CWE918Rule extends Rule {\n\n  // Checks for server-side request forgery issues\n  CWE918Pattern\n    = classDeclaration(name:\"*\")\n    & methodDeclaration(name: \"*\")\n    & callExpression(callee: memberAccess(property: \"url\"))\n    &+ callExpression(callee: memberAccess(property: \"open\"));\n\n  // Checks for user input being used to construct a URL\n  CWE918UserInput\n    = classDeclaration(name:\"*\")\n    & methodDeclaration(name: \"*\")\n    & callExpression(\n        callee: memberAccess(property: \"stringByAddingPercentEncodingWithAllowedCharacters\"),\n        arguments: contains(stringLiteral())\n    )\n    &+ callExpression(callee: member"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of security vulnerability that occurs when an attacker is able to inject malicious commands into an application or system. This occurs when user input is not properly sanitized or validated, allowing an attacker to execute system commands, malicious code, or other malicious actions on the underlying system. In Swift, this vulnerability can manifest itself when user input is used to form a system command, such as using a string to create a system call or using an input parameter in a call to a library function that uses the input as a command.",
      "vulnerable_code": "let input = \"cat /etc/passwd\";\nlet command = \"sh -c \\\"\" + input + \"\\\"\";\nsystem(command);",
      "remediation": "The following code snippet illustrates how an application can perform proper input sanitation to prevent command injection attacks. \n\nfunc validateInput(input: String) -> Bool {\n    let allowedCharacters = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\")\n    return input.rangeOfCharacter(from: allowedCharacters.inverted) == nil\n}",
      "semgrep_rule": "rule = {\n    strings:\n    $cmd = /.*/\n    condition: $cmd\n}",
      "codeql_rule": "import swift\n\nclass CommandInjectionVulnerability: Vulnerability {\n  // The source of the vulnerability\n  // should be the injection of user-controlled \n  // data into a system call.\n  //\n  // The vulnerability is detected when a user-controlled\n  // string is used as part of a command without\n  // proper sanitization.\n  //\n  // Sanitization should include removing metacharacters,\n  // like \"<>&;, and escaping quotes.\n  //\n  // In Swift, use of the Process class to spawn\n  // subprocesses is the most likely source of this\n  // vulnerability.\n \n  // Find all calls to Process.launch\n  // that do not use proper sanitization.\n  //\n  // Note: This rule is a basic proof-of-concept and\n  // should be further refined.\n \n  //"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295 is a vulnerability where an application fails to properly validate an SSL/TLS certificate presented by a remote server. This can allow an attacker to intercept and potentially modify traffic between the affected application and the remote server, potentially allowing them to gain access to sensitive data or perform malicious actions. In Swift, this vulnerability can be introduced when developers fail to properly validate the server certificate, usually by not verifying the chain of trust or the certificate's expiration date.",
      "vulnerable_code": "let url = URL(string: \"https://example.com\")!\nlet session = URLSession(configuration: .default)\nlet task = session.dataTask(with: url) { data, response, error in\n    if let error = error {\n        // Handle error\n    }\n\n    guard let data = data,\n        let response = response as? HTTPURLResponse,\n        (200 ..< 300) ~= response.statusCode\n    else {\n        // Handle error\n    }\n\n    // The code below is vulnerable to CWE-295\n    let serverTrustPolicy = ServerTrustPolicy.disableEvaluation\n    let serverTrustPolicies = [url.host!: serverTrustPolicy]\n    let serverTrustManager = ServerTrustManager(policies: serverTrustPolicies)\n    let session = URLSession(configuration: .default, serverTrustManager: server",
      "remediation": "// Remediation:\nguard let serverTrust = challenge.protectionSpace.serverTrust else {\n    completionHandler(.cancelAuthenticationChallenge, nil)\n    return\n}\n\nlet policies: [SecPolicy] = [SecPolicyCreateSSL(true, serverTrust.host as CFString)]\nlet trust = SecTrustCreateWithPolicies(serverTrust, policies as CFTypeRef, nil)\nlet result = SecTrustEvaluateWithError(trust!, nil)\n\nif result == errSecSuccess || result == errSecTrustResultUnspecified {\n    completionHandler(.useCredential, URLCredential(trust: serverTrust))\n} else {\n    completionHandler(.cancelAuthenticationChallenge, nil)\n}",
      "semgrep_rule": "rules:\n  - id: CWE-295-Improper-Certificate-Validation\n    severity: warning\n    patterns:\n      - pattern: 'URLRequest(url: .*?, settings: .*?, validatesSecureCertificate: false)'\n        message: 'The application is using an invalid or untrusted certificate with URLRequest'\n        contexts:\n          - call: URLRequest(url: .*?, settings: .*?, validatesSecureCertificate: false)",
      "codeql_rule": "import cwe\nimport Swift\n\nclass ImproperCertificateValidation: CodeQLSecurityVulnerability {\n  override func vulnerableCodePatterns() -> [CodeQLSecurityVulnerability.VulnerableCodePattern] {\n    let pattern = VulnerableCodePattern(language: .swift) {\n      // Pattern to detect code that could be vulnerable to CWE-295\n      // Improper Certificate Validation\n      BinaryOperation(\"==\", \n        FunctionCall(\"URL\", any()),\n        FunctionCall(\"URL\", any()))\n    }\n    return [pattern]\n  }\n}"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability in which an attacker is able to inject malicious code into an application. This type of vulnerability is particularly dangerous because the malicious code can be executed with the same privileges as the application and can lead to data theft, data destruction, or other malicious activities. In Swift, this vulnerability can occur when user input is not properly validated, allowing an attacker to inject malicious code into an application. If this malicious code is then executed, the attacker can gain access to sensitive information, or cause other malicious activities.",
      "vulnerable_code": "//In this code, userInput is taken from an untrusted source\nlet userInput = getUntrustedUserInput()\nlet command = \"echo \\(userInput)\"\nsystem(command) //This line allows for code injection attacks if user input is not properly validated",
      "remediation": "// Remediation Example\n\n// Prevent unsanitized user input from being used in code\nlet userInput = readLine()\nlet sanitizedInput = userInput.trimmingCharacters(in: .whitespacesAndNewlines)\nlet codeToExecute = \"print(\\(sanitizedInput))\"\n\nif let result = try? NSExpression(format: codeToExecute) {\n    let evaluatedExpression = result.expressionValue(with: nil, context: nil)\n    \n    if let evaluatedValue = evaluatedExpression as? String {\n        print(evaluatedValue)\n    } else {\n        print(\"Invalid input\")\n    }\n} else {\n    print(\"Invalid input\")\n}",
      "semgrep_rule": "rule = {\n    meta:\n      author = \"your_name\"\n      description = \"detects improper control of generation of code\"\n      risk = \"high\"\n    source:\n      languages = [\"swift\"]\n    detection:\n      condition:\n        all:\n          - pattern:\n              regexp: \"\\s*(eval|exec)\\s*\\(\"\n              message: \"Improper control of code generation detected.\"\n}",
      "codeql_rule": "import cwe094\n\nclass CWE094CodeInjectionDetector extends Rule {\n\n    // Find initialization of strings from external sources\n    // such as user input or files\n    private pattern userInputStrings :=\n        // `let` is used to initialize a string from user input\n        let _ = StrLiteral.from(_)\n\n        // `String(contentsOf:)` is used to initialize a string from a file\n        | String(_) <- contentsOf(_)\n\n    // Find initialization of any type from external sources\n    // such as user input or files\n    private pattern userInputAny :=\n        // `init()` is used to initialize any type from user input\n        init(_)\n\n        // `decode()` is used to initialize any type from a file\n        | decode(_) <- contentsOf(_)\n\n    // Find code which is executed from the string initialized from"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 is a type of vulnerability where an application or system fails to properly manage users' privileges, allowing users to gain access to resources or functions that they should not be able to access. This could include granting a user administrative privileges when they should only have access to limited resources, or allowing a user to access sensitive data that should remain confidential. It can also include granting privileges to malicious or unauthorized users.",
      "vulnerable_code": "let fileManager = FileManager.default\nlet documentsDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first\nlet fileURL = documentsDirectory?.appendingPathComponent(\"file.txt\")\n\n//Write to the file\nlet data = Data(...)\ntry? data.write(to: fileURL)\n\n//Set the file to be publicly readable\ntry? fileManager.setAttributes([.posixPermissions: 0o777], ofItemAtPath: fileURL!.path)",
      "remediation": "To remediate this vulnerability, a code change should be made that ensures the application is granting privileged access only to those users who have been authorized to access it. This can be done by implementing role-based access control (RBAC) system that clearly defines what access and privileges each user/role has. Additionally, the application should be configured to log all access attempts and activities, so that any suspicious activities can be identified and investigated.",
      "semgrep_rule": "rules:\n  - id: Improper_Privilege_Management\n    message: \"Improper privilege management detected\"\n    severity: warning\n    patterns:\n      - pattern: \"if (let |var )?(?<privilege>[A-Za-z]+) = .*?.authorization(For|Status)((For|From|To)Item)?\\\\(([A-Za-z]+\\\\s+)?(?<item>[A-Za-z]+)\"\n        filters:\n          - $privilege != $item",
      "codeql_rule": "import cwe269\n\nclass CWE269ImproperPrivilegeManagement: CodeQL.Vulnerability {\n  provider CWE269\n\n  // find functions that set privileges\n  let setPrivileges =\n    CallGraph.nodes(\n      Function(\n        name: /[sS]et[Pp]rivileges/,\n        type: /void\\s*\\(\\s*\\)\\s*$/\n      )\n    )\n\n  // find functions that set privileges without checking the privilege level\n  let setNoCheck =\n    setPrivileges.select(\n      CallGraph.calls(\n        Function(\n          name: /[cC]heck[Pp]rivileges/,\n          type: /void\\s*\\(\\s*\\)\\s*$/\n        )\n      ).not\n    )\n\n  // flag any calls to the functions that"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "Expression Language Injection is a type of vulnerability that occurs when user-supplied inputs are used to construct an expression language statement without proper neutralization. In Swift, this can occur when user-supplied values are used to create a string without proper sanitization. This can allow malicious code to be injected in the application, potentially leading to privilege escalation, data leakage, or other malicious activities.",
      "vulnerable_code": "let userInput = \"{{userInput}}\"\nlet sqlQuery = \"SELECT * FROM users WHERE username = '\\(userInput)'\"\n\n// The code above is vulnerable to Expression Language Injection, since userInput is not properly sanitized before being used in the SQL query. An attacker could craft a malicious input, such as ' OR ''=' to return all rows from the users table.",
      "remediation": "//Remediation Example\nlet inputString = \"userInput\"\n\n//Sanitize user input\nlet sanitizedInput = inputString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)\n\n//Use the sanitized input for expression language statement\nlet expressionLanguageStatement = \"MyExpressionLanguageStatement \\(sanitizedInput)\"",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects potential Expression Language Injection vulnerabilities in Swift code\"\n      author = \"Semgrep\"\n      id = \"S1001\"\n      references = [\"https://cwe.mitre.org/data/definitions/917.html\"]\n    strings:\n     $unsafe_string1 = \"\\\\$\\\\{\"\n     $unsafe_string2 = \"\\\\}\"\n    condition: \n      all of them\n}",
      "codeql_rule": "import swift\n\nclass ExpressionLanguageInjectionRule extends Audit.Rule {\n \n  // Define the query to detect the vulnerability\n  // Search for 'stringByEvaluatingJavaScriptFromString' which is used to evaluate an expression language statement\n  // Check for any user-controlled input passed as an argument\n  // If the user-controlled input is not properly sanitized, the app is vulnerable to expression language injection\n \n  meta.severity = Audit.Severity.High\n \n  predicate isExpressionLanguageInjectionVulnerable(call: Call) {\n    exists(call.target.accessibility == swift.staticAccessibility.public &&\n           call.target.belongsTo(\"String\") &&\n           call.name == \"stringByEvaluatingJavaScriptFromString(_:)\" &&\n           exists(callArgument: Expr, call.arguments[0] |"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability related to improper link resolution before file access (also known as \"link following\"). This vulnerability occurs when a program follows a link to a file without properly verifying the target of the link. This can lead to a malicious file being opened or executed, resulting in a security breach. In order to prevent this type of attack, developers must ensure that all links are validated before they are followed. This can be done by using the proper APIs or using checksums to verify the integrity of linked files.",
      "vulnerable_code": "let filePath = \"../../MyFile.txt\"\nlet fileURL = URL(fileURLWithPath: filePath)\nlet fileContents = try String(contentsOf: fileURL)",
      "remediation": "// Before\nlet fileName = \"example.txt\"\nlet filePath = \"Documents/\\(fileName)\"\n\n// After\nlet fileName = \"example.txt\"\nlet filePath = NSURL(fileURLWithPath: \"Documents/\\(fileName)\").standardizedFileURL.absoluteString",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"CWE-059: Improper Link Resolution Before File Access ('Link Following')\"\n    severity = \"WARNING\"\n  strings:\n    $path = /\\.\\/[^/]*/\n    $dynamic_path = /\\$\\{[^\\}]*\\}/\n  condition:\n    allof them\n}",
      "codeql_rule": "import cwe059\n\nclass CWE059_ImproperLinkResolutionBeforeFileAccessRule extends Rule {\n  // Rule to detect improper link resolution before file access\n \n  Query fileAccessQry() {\n    // Queries for all file access operations\n    FileAccess[]\n  }\n  \n  Query linkResolutionQry(FileAccess fa) {\n    // Queries for all link resolution operations from the file access operations\n    FileAccess[] = fa.getLinkResolvedFiles()\n  }\n  \n  @Override\n  public boolean isVulnerable(Query q) {\n    // Checks if any link resolution operations have been performed before any file access operations\n    return q.exists(fileAccessQry(),\n                    fa | linkResolutionQry(fa) not empty)\n  }\n}"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information, such as passwords, credit card numbers, or other personal information, is transmitted in plaintext, rather than being encrypted. This means that any malicious actor who is able to intercept the data could read it and misuse it. Furthermore, it also means that the data is vulnerable to attack from man-in-the-middle attacks, as the malicious actor could modify the data before it is sent to its destination.",
      "vulnerable_code": "let data = \"sensitive_data\"\nlet url = URL(string: \"http://example.com/senddata\")!\nvar request = URLRequest(url: url)\nrequest.httpMethod = \"POST\"\nrequest.httpBody = data.data(using: .utf8)\nURLSession.shared.dataTask(with: request) { data, response, error in\n    if let error = error {\n        // Handle error\n    }\n    if let response = response {\n        // Handle response\n    }\n}.resume()\n\nThe vulnerable code in this example is the lack of encryption when sending sensitive data over the network. Instead of using a secure protocol such as HTTPS, the data is sent in cleartext, which can be intercepted by malicious actors. To fix this vulnerability, the code should be modified to use an encrypted protocol such as HTTPS:\n\nlet data = \"sensitive_data\"",
      "remediation": "// Remediation\nlet apiURL = \"https://example.com\"\nlet urlRequest = URLRequest(url: URL(string: apiURL)!)\nurlRequest.httpShouldHandleCookies = false\nlet sessionConfiguration = URLSessionConfiguration.default\nsessionConfiguration.httpShouldSetCookies = false\nsessionConfiguration.httpCookieAcceptPolicy = .never\nsessionConfiguration.allowsCellularAccess = false\nsessionConfiguration.protocolClasses = [MyCustomUrlProtocol.self]\nlet urlSession = URLSession(configuration: sessionConfiguration)\nurlSession.dataTask(with: urlRequest) { (data, response, error) in\n    // handle response\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects cleartext transmission of sensitive information\"\n    author = \"Security Team\"\n    date = \"2020-08-01\"\n  strings:\n    $sensitive = /(password|credential|key)/i\n  condition:\n    any of them\n}",
      "codeql_rule": "import cwe319\nimport swift\n\nclass CWE319_Cleartext_Transmission_of_Sensitive_Information:\n \n  // Finds calls to functions that could transmit sensitive information in cleartext\n  @Rule()\n  def cwe_319_cleartext_transmission_of_sensitive_information(func: Function):\n      conn := func.calls(\n          swift.func(\"NSURLConnection.sendSynchronousRequest(_:returningResponse:)\",\n              \"Foundation\", \"NSURLConnection\"),\n          swift.func(\"NSURLConnection.connectionWithRequest(_:delegate:)\",\n              \"Foundation\", \"NSURLConnection\")\n      )\n      if conn {\n          cwe319.reportCleartextTransmission(conn)\n      }"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 is a type of security vulnerability that occurs when a web application or server redirects a user to an untrusted or malicious website. This can occur when a user clicks on a malicious link or is tricked into entering a malicious URL into the address bar. The malicious website can then be used to steal information or inject malicious code into the user's device. In Swift, this vulnerability can be found when developers use an unvalidated external source for redirecting users, such as a malicious URL.",
      "vulnerable_code": "// This code snippet is vulnerable to an open redirect vulnerability.\n\nlet urlString = \"http://evil.example.com/?redirect=\" + request.queryString[\"url\"]\nUIApplication.shared.open(URL(string: urlString)!, options: [:], completionHandler: nil)",
      "remediation": "// Before\nfunc redirectToURL(_ url: String) {\n    let redirectURL = url\n    if let url = URL(string: redirectURL) {\n        UIApplication.shared.open(url)\n    }\n}\n\n// After\nfunc redirectToURL(_ url: String) {\n    let allowedRedirectURLs = [\n        \"https://example.com/ok-redirect\"\n    ]\n    \n    if allowedRedirectURLs.contains(url) {\n        if let url = URL(string: url) {\n            UIApplication.shared.open(url)\n        }\n    }\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects open redirects\"\n    author = \"semgrep\"\n  strings:\n    $s1 = /.*redirect_to.*/\n    $s2 = /.*http.*/\n  condition:\n    $s1 and $s2\n}",
      "codeql_rule": "import cwe601\n\nclass OpenRedirect:\n  // Detects attempts to perform an open redirect\n  // using a URL with a user-controlled parameter\n  // as the target\n \n  // Find all URL objects\n  QueryURLObjects() {\n    URLObject\n  }\n  \n  // Find all URL objects with a user-controlled parameter as the target\n  QueryTargetURLs() {\n    URLObject[parameter != \"\"]\n  }\n  \n  // Find all locations where the target URL is used to perform a redirect\n  QueryRedirectLocations() {\n    // Find all function calls to the URL\n    let call = OpenRedirect.QueryTargetURLs().HasFunctionCall()\n    // Find all locations that use the URL as the target of a redirect\n    call.FindLocations(Redirect.To(call.GetTarget()))\n  }"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a type of vulnerability where sensitive information is inadvertently logged by a system or application. This could be information such as passwords, credit card numbers, or any other type of confidential data. This could occur if a system is configured to log any data that is input into the system, but fails to take into account the possibility of sensitive data being logged. The logging of such information can put both the system and its users at risk, as the confidential data can be accessed by unauthorized users.",
      "vulnerable_code": "let userInput = \"password123\"\n\n// Log user input\nprint(\"User input: \\(userInput)\")",
      "remediation": "// Remediation\n\nfunc logSensitiveData(sensitiveData: Any) {\n    // Don't log sensitive information\n    print(\"Sensitive data not logged\")\n}",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects insertion of sensitive information into log files\"\n        severity = \"high\"\n    strings:\n        $logs = /.*/(log|LOG|Log).*/\n        $sensitive_data = /.*(password|credit card number|social security number|date of birth).*/\n    condition:\n        $logs and $sensitive_data\n}",
      "codeql_rule": "import cwe\n\nclass CWE_532_Log_File_Sensitivity : SecurityCodeScanRule {\n \n  // Rule metadata\n  meta.ruleName = \"CWE-532 Log File Sensitivity\"\n  meta.description = \"Detects the insertion of sensitive information into log files.\"\n  meta.rationale = cwe.cwe_532_log_file_sensitivity_rationale\n  meta.type = \"cwe\"\n \n  // Query\n  // The query looks for log functions that take in sensitive information.\n  query log_file_sensitivity_query {\n    // Look for usages of logging functions\n    LogFunc = LogFunction()\n    // Look for sensitive information being passed as an argument to the logging functions\n    SensitiveArgument = Identifier(LogFunc.parameter.name == \"sensitiveData\")\n    // Report the"
    }
  },
  "Kotlin": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "CWE-079, also known as Cross-site Scripting (XSS), is a vulnerability in which malicious code is inserted into an application or website. This malicious code can be used to gain unauthorized access to user data and other sensitive information. In a web page, the vulnerability occurs when user input is not properly validated or escaped, allowing an attacker to inject malicious code into the web page which is then executed by the user's browser. This can be used to gain access to the user's session or to perform other malicious actions.",
      "vulnerable_code": "val userInput = request.getParameter(\"userInput\")\n\nresponse.writer.println(\"<html>\")\nresponse.writer.println(\"<body>\")\nresponse.writer.println(\"Hello \" + userInput + \"!\")\nresponse.writer.println(\"</body>\")\nresponse.writer.println(\"</html>\")\n\nThis code is vulnerable to cross-site scripting attacks as it is directly displaying user input into the HTML response without any sanitization. An attacker can inject malicious code into the userInput variable which could be executed on the user's browser.",
      "remediation": "One way to remediate CWE-079 is to use an input validation library such as OWASP ESAPI (Enterprise Security API). This library provides a set of functions that can be used to validate user input and perform proper encoding to prevent cross-site scripting attacks.\n\nFor example, the following code will validate an input string:\n\n// Validate the input string\nval validatedString = ESAPI.validator().getValidInput(\"inputString\", inputString, \"SafeString\", 200, false);\n\n// Encode the validated string\nval encodedString = ESAPI.encoder().encodeForHTML(validatedString);\n\n// Output the encoded string\nprintln(encodedString);",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: `\n        /<.*?(?:(?:on(?:[a-z]+)\\\\s*?=\\\\s*?\\\\\"(?:[^\\\\\"]*?(?:\\\\${sep}|\\\\\\\")[^\\\\\"]*?)*?\\\\\")/\n      `,\n      message: \"Possible Cross-site Scripting (CWE-079) vulnerability detected.\",\n      severity: \"CRITICAL\",\n    },\n  ],\n  sep: \"\\\\s*?(?:;|&|\\\\?|#)?\\\\s*?\",\n}",
      "codeql_rule": "import cwe79\n\nclass CWE079CrossSiteScriptingRule extends Rule {\n  // Query looking for strings being inserted directly into the response\n  // without passing through any kind of sanitation\n  query unsafeStringInsertion() {\n    // Find all calls to Response.outputStream.write()\n    CallExpr writeCall | Response.outputStream.write(_) => writeCall\n\n    // Find any parameters passed to the write call that are strings\n    PatternArgument stringArg <- writeCall.arguments\n    Literal stringLiteral <- stringArg.value\n    string literalType = typeOf(stringLiteral)\n    string literalValue = valueOf(stringLiteral)\n    string literalText = textOf(stringLiteral)\n    string literalKind = kindOf(stringLiteral)\n   \n    // Check that the string is not a sanitized input\n    //"
    },
    "CWE-020: Improper Input Validation": {
      "description": "CWE-020, Improper Input Validation, occurs when an application fails to properly validate user input. This can lead to malicious code injection, buffer overflows, and other security issues. In Kotlin, improper input validation can be caused by accepting untrusted data without validation, or allowing malicious code to be executed on the user's machine. To prevent this vulnerability from occurring, user input should be checked for malicious code and any suspicious behavior should be blocked.",
      "vulnerable_code": "fun validateInput(input: String): Boolean {\n    if (input.length > 10) {\n        return true\n    }\n    return false\n}",
      "remediation": "A simple way to remediate a CWE-020 vulnerability is to use input validation. An example of this in Kotlin would be to check the user's input against a set of valid strings before allowing it to be used:\n\n// Define a set of valid strings\nval validStrings = setOf(\"valid1\", \"valid2\", \"valid3\")\n\n// Get the user's input\nval userInput = readLine()\n\n// Validate the input\nif (userInput in validStrings) {\n    // Do something with the valid input\n} else {\n    // Throw an error if the input is not valid\n    throw IllegalArgumentException(\"Input is not valid\")\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Improper Input Validation\" \n    author = \"MyName\"\n    date = \"2020-09-30\"\n    severity = \"WARNING\"\n    id = \"RULE1\"\n  strings:\n    $ = \"*\"\n  condition:\n    all of them\n}",
      "codeql_rule": "import cwe020\n\nclass Vulnerability_CWE_020 : SecurityFeature{\n\t\n\t// Rule to detect improper input validation\n\t// This rule is triggered when a function takes in user input without any validation\n\t\n\tpredicate isUserInputFunc(Func func) {\n\t\texists(Parameter param, Expr userInput | \n\t\t\tparam.getFunction() == func &&\n\t\t\tuserInput instanceof Variable &&\n\t\t\tuserInput.getOrigin() == Origin.USER_INPUT\n\t\t)\n\t}\n\t\n\t// This rule is triggered when a function takes in user input without any sanitization\n\t\n\tpredicate isUserInputSanitizedFunc(Func func) {\n\t\texists(Sanitize sanitize, Expr userInput | \n\t\t\tsanitize.getFunction() == func &&"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of vulnerability that occurs when user-supplied data is not correctly sanitized before being used in an OS command. This allows attackers to inject malicious commands into the system, allowing them to execute arbitrary code and potentially gain access to sensitive data. This vulnerability can be exploited by malicious actors to gain control of a system, compromise data, or execute malicious code. An example of this vulnerability in Kotlin might be a web application that allows users to input a command line argument into a form, the application then uses this user input to execute the command without properly sanitizing the input, thus allowing attackers to inject malicious code into the system.",
      "vulnerable_code": "fun executeCommand(command: String) {\n    val process = Runtime.getRuntime().exec(command)\n    process.waitFor()\n    println(\"Command executed!\")\n}\n\n// Vulnerable code\nexecuteCommand(request.queryParams(\"command\"))",
      "remediation": "// Sanitize user input to ensure it is safe to use in a system command \nfun sanitizeInput(input: String): String {\n    // Replace any characters that could be used to execute system commands with an empty string\n    return input.replace(Regex(\"[;&|<>()$\\\\\\\"' ]\"), \"\")\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects when vulnerable parameters are passed to the underlying OS command\"\n    authors = [\"Your Name Here\"]\n  source:\n    include = [\"**/*.kt\"]\n  detection:\n    patterns:\n      - pattern: |\n          Runtime.getRuntime().exec(\"$PARAMETER\")\n        message: \"Possible OS command injection vulnerability detected\"\n        severity: WARNING\n        identifiers:\n          PARAMETER:\n            type: parameter\n            encodings: [base64, hex]\n            locations: [arguments]\n}",
      "codeql_rule": "import cwe078\n\nclass CWE078_Rule extends Rule {\n \n  // Finds functions that execute OS commands\n  // where the command is formed using user-provided data\n  query commandExecution() {\n    ExecuteCommand | ExecuteProgram\n    // Finds commands where user-provided data is used to form the command\n    where exists (DataFlow::DataSource ds | ds.hasOrigin(\"USER_INPUT\"))\n  }\n \n  // Finds functions that execute OS commands\n  // where the command is formed using user-provided data\n  // and does not properly neutralize the user-provided data\n  query vulnerableCommandExecution() {\n    ExecuteCommand | ExecuteProgram vulnCommand\n    where exists(DataFlow::DataSource ds | \n\t\tds.hasOrigin(\"USER_INPUT\") and\n\t\tnot cwe07"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') is a vulnerability which occurs when user input is not properly sanitized before it is used in an SQL query. This can allow attackers to inject malicious code into the query, which can be used to access and modify the underlying data, or even execute arbitrary commands on the system. Additionally, this vulnerability can be used to bypass authentication mechanisms, gain access to sensitive data, and even allow attackers to gain full control of the system.",
      "vulnerable_code": "val query = \"SELECT * FROM users WHERE name='$userName' AND password='$password'\"\nval result = statement.executeQuery(query)",
      "remediation": "// Before\nval queryString = \"SELECT * FROM table WHERE id = $userId\"\n\n// After\nval queryString = \"SELECT * FROM table WHERE id = ?\"\nval statement = connection.prepareStatement(queryString)\nstatement.setInt(1, userId)\nval result = statement.executeQuery()",
      "semgrep_rule": "rule = {\n  id      : \"CWE-089-SQL-Injection\",\n  pattern : \"\\\"$SQL_COMMAND$\\\"\",\n  message : \"Possible SQL Injection detected.\",\n  mark    : true\n  references : [\"https://cwe.mitre.org/data/definitions/89.html\"]\n}",
      "codeql_rule": "import cwe089\n\nclass CWE089Rule extends SecurityRule {\n  // Rule to detect injection of user-controlled data into an SQL query\n  // without proper sanitization\n  override fun getCweId() = cwe089.CWE_089\n\n  override fun getDescription() =\n      \"Detects injection of user-controlled data into an SQL query without proper sanitization\"\n\n  override fun getInterestingNodes() = listOf(\n    Query.pattern(\n      // Match an SQL query with user-controlled data\n      // without proper sanitization\n      // e.g. query(\"SELECT * FROM users WHERE name = '$name'\")\n      pattern {\n        Query(\n          stringLiteral(\n            anyOf(\n              // Match unescaped single quotes\n              containsString(\"'\"),\n              // Match interpolated variables\n              containsString(\"$\")"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal is a type of security vulnerability that occurs when an attacker is able to access files and directories that are outside the intended directory through manipulating the path variables. This can be done by using relative path traversal such as \"../../../../etc/password\" or absolute path traversal such as \"/etc/password\". With this vulnerability, attackers can gain access to sensitive information or perform malicious activities.",
      "vulnerable_code": "val fileName = request.getParameter(\"file\")\nval file = File(\"./files/$fileName\")\n// ...\ntry {\n    file.readText()\n} catch (e: FileNotFoundException) {\n    // Handle error\n}",
      "remediation": "// Before\nval directoryPath = request.param(\"path\")\nval file = File(directoryPath)\n\n// After\nval directoryPath = request.param(\"path\")\nval file = File(directoryPath.replace(\"..\", \"\")) // replace any occurrences of \"..\" with blank string, so no directory can be traversed outside of the allowed directory",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: \"File(.*?)\\.get(.*?)\\(.*?(?:'|\\\")(.*?)(?:'|\\\")\",\n      message: \"Potential path traversal vulnerability detected\",\n      metadata: {\n        severity: \"CRITICAL\"\n      }\n    }\n  ]\n}",
      "codeql_rule": "import cwe022\nimport kotlin\n\nclass CWE022Detector : Rule {\n  // Get all function calls that take a file path as a parameter\n  // and check if the parameter is a constant string\n  // (which is a security risk)\n  getFunctionCalls(pattern:\n    kotlin.FunctionCall(\n      pattern: \"java.io.File.<init>\",\n      parameters: kotlin.StringLiteral(_) \n    )\n  ) {\n    // Report the vulnerability\n    report(CWE022, functionCall)\n  }\n}"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site request forgery (CSRF) is a type of attack that occurs when a malicious website, email, or blog causes a user\u2019s web browser to perform an unwanted action on a trusted website for which the user is currently authenticated. This vulnerability can be exploited by a malicious attacker to perform any type of action that the user is allowed to perform on the website, such as transferring funds, changing passwords, and other sensitive activities.\n\nExplain how the vulnerability can be prevented:\n\nTo prevent cross-site request forgery (CSRF) attacks, developers should implement a server-side protection mechanism that verifies the origin of the request. This can be done by generating a unique token for each request, and ensuring that the token is sent back with the response to validate the request's origin. Additionally, developers should use secure HTTP headers, such as X-Frame-Options and Content-Security-Policy, to prevent the browser from sending malicious requests.",
      "vulnerable_code": "fun handleRequest(request: HttpServletRequest) {\n    val userId = request.getParameter(\"userId\")\n    val action = request.getParameter(\"action\")\n\n    // If the userId and action are not provided, the request is invalid\n    if (userId == null || action == null) {\n        return\n    }\n\n    // Perform the requested action\n    performAction(userId, action)\n}\n\n// This function performs the action requested in the handleRequest() function\nfun performAction(userId: String, action: String) {\n    when (action) {\n        \"deleteAccount\" -> deleteAccount(userId)\n        \"changePassword\" -> changePassword(userId)\n        \"postMessage\" -> postMessage(userId)\n    }\n}\n\nThe code above is vulnerable to CSRF because it does not check if the request is a valid",
      "remediation": "// Create a CSRF token\nval csrfToken = UUID.randomUUID().toString()\n\n// Store the token in the user session\nrequest.session.setAttribute(\"csrfToken\", csrfToken)\n\n// Add the token as a request header\nrequest.addHeader(\"X-CSRF-Token\", csrfToken)\n\n// Validate the token on the server-side for every POST request\nif (request.getMethod() == \"POST\" && \n    request.getHeader(\"X-CSRF-Token\") != request.session.getAttribute(\"csrfToken\")) {\n    response.status = 403\n    response.sendError(403, \"Invalid CSRF Token\")\n}",
      "semgrep_rule": "rule = {\n    meta:\n      author = \"MyName\"\n      description = \"Detects Cross-Site Request Forgery (CSRF) vulnerabilities\"\n      risk = \"high\"\n    source:\n      lang = \"kotlin\"\n    strings:\n      $form = \"POST\"\n      $token = /\\*CSRF TOKEN\\*/\n    condition:\n      $form @[-3] and $token @[-2]\n}",
      "codeql_rule": "import cwe352\n\nclass CSRFVulnerability(Vulnerability):\n    let description = \"Cross-Site Request Forgery (CSRF) Vulnerability\"\n    let severity = \"High\"\n\n    // Find calls to methods that can cause CSRF\n    // such as those that modify state\n    vuln_methods = method.select(m |\n        m.name in [\"PUT\", \"POST\", \"DELETE\", \n                   \"UPDATE\", \"INSERT\"]\n    )\n\n    // Look for calls to these methods that lack appropriate\n    // CSRF protection\n    vuln_sites = vuln_methods.select(m |\n        not m.ancestorOrSelf().hasDescendant(\n            cwe352.antiCSRF()\n        )\n    )\n\n    // Report any calls to vulnerable methods\n    // without CSRF protection\n    vuln_sites.report()"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability which occurs when an application allows unrestricted upload of files with dangerous types. This vulnerability can be exploited by an attacker to upload malicious files to the server, which can then be used to execute arbitrary code and compromise the system. These dangerous file types can include executables, scripts, and other malicious payloads. By allowing unrestricted upload of these types of files, the application may be vulnerable to a wide range of attacks.",
      "vulnerable_code": "val file = File(\"/uploads/user.php\")\nval filePath = file.absolutePath\nval name = filePath.substringAfterLast(\"/\")\nval uploadDir = File(\"/uploads\")\n\n// Unrestricted upload of file with potential dangerous type\nif (!uploadDir.exists()) {\n    uploadDir.mkdirs()\n}\n\nfile.copyTo(File(uploadDir, name), true)",
      "remediation": "// Validate the file type before accepting the upload\nval allowedTypes = arrayOf(\"jpg\", \"png\", \"gif\", \"pdf\", \"txt\")\n\nfun validateFileType(fileName: String): Boolean {\n    val fileExtension = fileName.substringAfterLast(\".\") \n    return allowedTypes.contains(fileExtension)\n}\n\n// If file type is not valid, reject the upload\nif (!validateFileType(fileName)) {\n    throw IllegalArgumentException(\"Unsupported file type\")\n}",
      "semgrep_rule": "rule = {\n    meta:\n\t    description = \"Detects unrestricted uploads of file with dangerous types\"\n\t    author = \"Semgrep\"\n    strings:\n\t    $input = /.*\\.(bat|exe|sh|js|vbs|cmd)/\n    condition:\n\t    $input\n}",
      "codeql_rule": "import cwe434\n\nclass UnrestrictedUploadWithDangerousType extends Rule {\n    // Rule to detect Unrestricted Upload of File with Dangerous Type\n    // (CWE-434)\n\n    // Query to detect direct access to a file upload API without any\n    // restrictions on the type of file being uploaded\n    @QlObservation(\n        name=\"Unrestricted file upload API\"\n    )\n    // Find calls to file-upload API functions that do not restrict\n    // the type of file being uploaded\n    def vulnerableAPI =\n        Call.target(\"*FileUploadAPI*\").\n        hasAncestor(Method.named(\"*\"));\n\n  @Cwe434\n  // Report a CWE-434 vulnerability if the vulnerable API is called\n  // without any restrictions on the type of file being uploaded\n  def vulnerableCode = \n    vulnerableAPI.select(c =>"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306: Missing Authentication for Critical Function is a vulnerability that occurs when an application does not properly authenticate a user before allowing them to access a critical function. This can lead to unauthorized access to sensitive data or other malicious activity. In order for an application to protect critical functions, it must ensure that only authenticated users can access them. Failing to do so can lead to a severe security breach.",
      "vulnerable_code": "fun sendMessage(message: String, recipient: String) {\n    // code to send message\n}\n\nThis code is vulnerable to CWE-306 because it does not require any authentication before it sends a message. Any user can call this function to send a message to any recipient without any verification of their identity or authorization.",
      "remediation": "// Create a function to authenticate a user\nfun authenticateUser(username: String, password: String): Boolean {\n    // Get the user details from the database\n    val userInfo = getUserInfoFromDB(username)\n    \n    // Compare the provided credentials against the database\n    if (userInfo.username == username && userInfo.password == password) {\n        return true\n    } else {\n        return false\n    }\n}\n\n// Create a function to check if user is authenticated before allowing access to a critical function\nfun checkAuthentication(username: String): Boolean {\n    // Call the authentication function\n    if (authenticateUser(username)) {\n        return true\n    } else {\n        return false\n    }\n}\n\n// Use the authentication check before allowing access to a critical function\nfun criticalFunction(username: String) {\n    // Check if user is authenticated",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"CWE-306: Missing Authentication for Critical Function\"\n      severity = \"CRITICAL\"\n      \n    strings:\n      $func1 = \"functionName\"\n\n    condition:\n      $func1 and not ( /.*if.*authenticated.*/ )\n}",
      "codeql_rule": "import cwe/CWE306\n\nclass MissingAuthForCriticalFunction extends Rule {\n  // Get all the functions that are marked as critical\n  // and don't have authentication\n  query criticalFuncWithoutAuth(){\n    // Finds functions marked as critical\n    Function func\n    where exists(Annotation ann |ann.type = \"Critical\" \n    and annotates(ann, func))\n\n    // Finds functions without authentication\n    and not exists(FunctionCall call |\n    call.callee.name = \"authenticate\"\n    and call.target.matches(func))\n  }\n\n  // Report any functions that match the query\n  // as a vulnerability\n  vulnerability when criticalFuncWithoutAuth(){\n    description(\"This function does not have authentication for its critical function\")\n    cwe = CWE306\n  }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability related to the deserialization of untrusted data. It occurs when an application deserializes data from an untrusted source without validating or sanitizing the input, resulting in a malicious attack vector. This vulnerability can potentially lead to remote code execution, data manipulation, privilege escalation, and other security issues. By exploiting the vulnerability, an attacker can gain access to the system and compromise its security.",
      "vulnerable_code": "// Deserialize untrusted data from a malicious user\nval inputStream = ByteArrayInputStream(userInput.toByteArray())\nval obj = ObjectInputStream(inputStream).readObject()",
      "remediation": "Remediating CWE-502 can be achieved by verifying any data that is received from an untrusted source before deserializing it. A simple example in Kotlin could look something like this:\n\n// Deserialize the data from the untrusted source\nval data = deserialize(untrustedSource)\n\n// Sanity check the data\nif (data.isValid()) {\n    // Deserialize the data\n    val obj = deserialize(data)\n} else {\n    // Handle the invalid data\n    handleInvalidData()\n}",
      "semgrep_rule": "rule = {\n  meta:\n    id = \"CWE-502\"\n    description = \"Deserialization of untrusted data\"\n    tags = [\"security\", \"cwe-502\", \"kotlin\"]\n  source:\n    language = \"kotlin\"\n  detection:\n    input:\n      // Detect when an object is deserialized with an untrusted source\n      var serializedData = ObjectInputStream(\"<some untrusted source>\")\n      // This will detect the vulnerability\n      val deserializedObject = serializedData.readObject()\n}",
      "codeql_rule": "import cwe502\nimport kotlin\n\nclass DeserializationVulnerabilityRule extends Rule {\n  // Override the query method to define the query\n  override query(): string {\n    // Find all deserialization of untrusted data\n    DeserializationUntrustedData[] = cwe502.findDeserializationUntrustedData()\n    \n    // Find all calls to deserialization methods in Kotlin\n    DeserializationCall[] = kotlin.findKotlinObjectInputStreamReadObject() +\n                            kotlin.findKotlinObjectInputStreamReadUnshared() +\n                            kotlin.findKotlinObjectInputStreamResolveObject()\n    \n    // Find all deserialization calls of untrusted data\n    return DeserializationUntrustedData[].hasCallers(DeserializationCall[])\n  }\n\n  // Over"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability related to authentication for applications or systems. It occurs when authentication controls, such as usernames and passwords, are not properly configured or enforced. This allows attackers to gain access to restricted resources or data without authorization. This vulnerability can result in data breaches or other malicious activities from unauthorized access.",
      "vulnerable_code": "fun authenticateUser(username: String, password: String): Boolean {\n    // assume username and password are entered by the user\n    if (username == \"admin\" && password == \"admin\") {\n        return true\n    }\n    return false\n}\n\n// This code does not adequately authenticate the user, as it only checks for a specific username and password (in this case \"admin\"). This leaves the system vulnerable to brute-force attacks.",
      "remediation": "The following code can be used to remediate CWE-287: Improper Authentication:\n\n// Use a secure hashing algorithm for password storage\nfun hashPassword(password: String): String {\n    return MessageDigest.getInstance(\"SHA-256\")\n        .digest(password.toByteArray())\n        .fold(\"\", { str, it -> str + \"%02x\".format(it) })\n}\n\n// Use a unique salt for each user\nclass User {\n    private val salt = SecureRandom.getInstanceStrong().nextBytes(16)\n    private val hashedPassword: String\n\n    constructor(password: String) {\n        this.hashedPassword = hashPassword(password + salt.toString())\n    }\n\n    fun authenticate(password: String): Boolean {\n        return hashPassword(password + salt.toString()) == hashedPassword\n    }\n}",
      "semgrep_rule": "rule = {\n  source: \"**/*.kt\"\n  meta:\n    description = \"Detects improper authentication implementations in Kotlin code\"\n    author = \"MyName\"\n    id = \"CWE-287\"\n  patterns: \n   - pattern: \"if \\((?P<user_input>.*)\\) == (?P<static_value>.*)\"\n     message: \"Improper authentication found: Authentication is based on static value and user input\"\n     severity: WARNING\n}",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthenticationRule extends Rule {\n    // Query to find all instances of improper authentication\n    query improperAuthenticationChecks() {\n        // Find all authentication attempts\n        AuthenticationAttempt[] authAttempts\n\n        // Find all authentication checks\n        AuthenticationCheck[] authChecks\n\n        // Check that all authentication attempts are matched with an authentication check\n        authAttempts \n            // Check that the authentication attempts are not matched with authentication checks\n            where exists(authChecks, c | !cwe287.matches(authAttempts, c))\n    }\n\n    // Reports the findings of the query\n    private void report(AuthenticationAttempt authAttempt) {\n        // Report the improper authentication\n        report(authAttempt, \"Improper authentication detected\");\n    }\n\n    // Executes the query and reports the findings\n    override def getQueries() {\n        query improperAuthenticationChecks"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability that occurs when an application or system uses hard-coded credentials, such as usernames, passwords, or cryptographic keys, instead of using dynamically-generated credentials. This can allow malicious actors to gain access to the system or application by simply knowing the hard-coded credentials, bypassing any authentication process.",
      "vulnerable_code": "val username = \"admin\"\nval password = \"admin123\"\n\n// authenticate user\nif (username == \"admin\" && password == \"admin123\") {\n    println(\"User authenticated!\")\n} else {\n    println(\"Unauthorized access\")\n}",
      "remediation": "To fix this vulnerability, a secure authentication mechanism should be used instead of hard-coded credentials. This could be done by implementing OAuth2 or OpenID Connect for authentication and authorization, or by using an API key or token. Additionally, any credentials stored in the application code should be encrypted and stored separately from the application code.",
      "semgrep_rule": "rule = {\n  strings:\n    // hard-coded credentials\n    $cred = /username[^\\S\\n]*:[^\\S\\n]*[^\\S\\n]*password/\n \n  patterns:\n    // look for credentials used in function calls\n    // or stored in variables\n    $func_call = /([a-zA-Z_]*)\\s*\\(\\s*$cred\\s*\\)/\n    $var_assign = /\\$[a-zA-Z_]*\\s*=\\s*$cred/\n\n  metadata:\n    author = \"Semgrep team\"\n    description = \"Detects the use of hard-coded credentials\"\n    severity = \"MEDIUM\"\n\n  control-flow:\n    // look for uses of credentials in function calls or\n    // assignments to",
      "codeql_rule": "import cwe\nimport java\n\nclass HardCodedCredentials extends Rule {\n  // Finds hard-coded credentials\n  String getCweId() {\n    return cwe`CWE-798`\n  }\n\n  Boolean[] getLanguages() {\n    return [java]\n  }\n\n  Query getQuery() {\n    return let hardCreds =\n      // Finds string literals that contain \"username\" or \"password\"\n      // Ignores strings that contain the word \"logging\"\n      // These are potential hard-coded credentials\n      (StringLiteral c | exists (Method m, MethodInvocation mc, c.matches(\".*(username|password).*\") && !c.matches(\".*logging.*\"))\n    in hardCreds\n  }\n}"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276: Incorrect Default Permissions occurs when a software developer sets incorrect default permissions for a file, directory, or other resource. These incorrect permissions can allow unauthorized users access to sensitive information, or allow them to make modifications to the resource without the owner\u2019s knowledge or permission. These incorrect permissions can also be exploited to elevate the privileges of the user, allowing them to gain access to further resources or modify system settings.",
      "vulnerable_code": "// Vulnerable code\nval file = File(\"data.txt\")\nfile.createNewFile() // Creates a new file with default permissions\n\n// Non-vulnerable code\nval file = File(\"data.txt\")\nval permissions = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"))\nval filePath = FileSystems.getDefault().getPath(\"data.txt\")\nFiles.createFile(filePath, permissions) // Creates a new file with specified permissions",
      "remediation": "// Remediate CWE-276: Incorrect Default Permissions\n\n// Set default permissions to proper values\nval filePermissions = 0600 // Owner read and write, others no access\nval folderPermissions = 0700 // Owner read, write, and execute, others no access\n\n// Get all files and folders in the current directory\nval files = File(\".\").listFiles()\n\n// Set the permissions for each file and folder\nfiles?.forEach {\n    if (it.isFile) {\n        it.setPermissions(filePermissions)\n    } else if (it.isDirectory) {\n        it.setPermissions(folderPermissions)\n    }\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects incorrect default permissions\"\n    id = \"CWE-276\"\n    tags = [\"security\", \"vulnerability\", \"CWE-276\"]\n  source:\n    lang = \"kotlin\"\n  detection:\n    any_of:\n      - patterns:\n          - pattern: \"chmod\\(.*, 0666\\)\"\n          message: \"Incorrect default permissions detected\"\n      - patterns:\n          - pattern: \"chmod\\(.*, 0644\\)\"\n          message: \"Incorrect default permissions detected\"\n      - patterns:\n          - pattern: \"chmod\\(.*, 0755\\)\"\n          message: \"Incorrect default permissions detected\"\n}",
      "codeql_rule": "import java\nimport security\n\nclass IncorrectDefaultPermissions extends SecurityCodeScanRule {\n    /**\n    * Checks whether the default permissions of a class are incorrect\n    */\n    getCweId(): string {\n        return \"CWE-276\"\n    }\n\n    getDescription(): string {\n        return \"Checks whether the declared default permissions of a class are incorrect\"\n    }\n\n    getName(): string {\n        return \"Incorrect Default Permissions\"\n    }\n\n    getRisk(): Risk {\n        return Risk.High\n    }\n\n    // Find classes with incorrect default permissions\n    query incDefPermissions {\n        Class c\n        Permission p\n        c.defaultPermission = p\n        // Check for incorrect default permissions\n        not p.isCorrect()\n    }\n}"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that occurs when sensitive information, such as passwords, credit card numbers, or personal data, is exposed to an unauthorized actor. This can occur through insecure data storage, unencrypted communications, or a lack of proper access control. This vulnerability can lead to identity theft, data breaches, and other forms of malicious activity.",
      "vulnerable_code": "// This code exposes a user's password to anyone who can call the function\nfun getUserPassword(username: String): String {\n    val password = getPasswordFromDatabase(username)\n    return password\n}",
      "remediation": "// The following code implements an encryption layer to protect sensitive data from unauthorized actors\n\nval encryptionKey = generateEncryptionKey()\n\nfun encryptData(data: String): String {\n    val encryptedData = encrypt(data, encryptionKey)\n    return encryptedData\n}\n\nfun decryptData(encryptedData: String): String {\n    val decryptedData = decrypt(encryptedData, encryptionKey)\n    return decryptedData\n}",
      "semgrep_rule": "rule = {\n    meta:\n        id = \"CWE-200-Exposure-of-Sensitive-Information-to-an-Unauthorized-Actor\"\n        description = \"This rule detects potential exposure of sensitive information to an unauthorized actor\"\n        authors = \"Semgrep\"\n        references = \"https://cwe.mitre.org/data/definitions/200.html\"\n        tags = [\"security\", \"kotlin\"]\n    strings:\n        $sensitive_info = /.*(password|username|api-key|token).*/i\n    condition:\n        $sensitive_info\n}",
      "codeql_rule": "import cwe200\n\nclass CWE200_Unprotected_Information {\n\n  // Defines a query to detect exposure of sensitive information to an unauthorized actor\n  // that can be used to identify potential CWE-200 vulnerabilities\n  query CWE200_Unprotected_Information() {\n    // Finds methods that can potentially access sensitive information\n    MethodAccess sensitiveInfoAccess = {\n      Method.accesses(sensitiveData)\n      | Method.accesses(sensitiveResource)\n    }\n    \n    // Finds methods that can potentially be accessed by an unauthorized actor\n    MethodAccess unauthorizedActorAccess = {\n      Method.accesses(unauthorizedActor)\n    }\n    \n    // Finds methods that can potentially expose sensitive information\n    // to an unauthorized actor\n    sensitiveInfoAccess.refs() * unauthorizedActorAccess.refs()\n    // Checks if the sensitive information is not adequately protected"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a vulnerability that occurs when credentials, such as passwords, are stored in a way that does not provide sufficient protection. This means that the credentials are not encrypted, hashed, or otherwise safeguarded from potential attackers who could access the credentials and use them for malicious purposes. Without proper protection, attackers may be able to gain access to accounts, systems, and sensitive data that the credentials are meant to protect.",
      "vulnerable_code": "fun authenticateUser(username: String, password: String): Boolean {\n    val credentials = loadCredentialsFromFile() // load username/password pairs from a file\n    return credentials.contains(username to password)\n}\n\nThis code is vulnerable to CWE-522 because it is storing credentials in plain text in a file and then checking if the provided username and password match the stored credentials. This means that the credentials are not sufficiently protected, and could be compromised if the file is accessed by an unauthorized user.",
      "remediation": "// Remediation:\n\n// Create a secure credentials storage system\nval credentialsDataStore = HashMap<String, String>()\n\n// Encrypt the credentials using a strong encryption algorithm\nval encryptedCredentials = encryptCredentials(credentialsDataStore)\n\n// Store the encrypted credentials in a secure location\nstoreEncryptedCredentials(encryptedCredentials)\n\n// Access the stored encrypted credentials only when needed\nval retrievedCredentials = retrieveEncryptedCredentials()\n\n// Decrypt the credentials securely\nval decryptedCredentials = decryptCredentials(retrievedCredentials)",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects insufficiently-protected credentials\"\n        author = \"Your Name Here\"\n        references = [\"https://cwe.mitre.org/data/definitions/522.html\"]\n    strings:\n        $username = /[A-Za-z0-9_]+/\n        $password = /[A-Za-z0-9_]+/\n    condition:\n        ($username and $password) and (\n            # strings.password used without any encryption\n            \"password\" contains $password\n            or\n            # strings.username used without any encryption\n            \"username\" contains $username\n        )\n}",
      "codeql_rule": "import security\n\nclass InsufficientlyProtectedCredentials: SecurityCodeQL {\n    \n    //CWE-522: Insufficiently Protected Credentials\n    predicate vulnerableExpression(){\n        credential = VariableRef( TypeRef( \"java.lang.String\" ) )\n        return ExprStmt( AssignExpr( credential, MethodCallExpr( _, \"getPassword\" ) ) )\n    }\n    \n    predicate isVulnerable(){\n        return ExprStmt( AssignExpr( _, credential ) )\n        and not ExprStmt( MethodCallExpr( _, \"encrypt\" ) )\n    }\n    \n    //Trigger the alert when vulnerableExpression() and isVulnerable() both hold\n    //in the same method\n    from vulnerableExpression() as vuln, isVulnerable() as isVuln,\n        Method m"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability that can occur when XML parsers are used to process user-supplied input. It occurs when an XML document references an external entity, such as a remote file or web service, and the parser does not properly restrict or sanitize the external entity. This can lead to the potential for the malicious user to gain access to sensitive data, launch a denial of service attack, or even execute arbitrary code.",
      "vulnerable_code": "val factory = DocumentBuilderFactory.newInstance()\nfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false)\nval builder = factory.newDocumentBuilder()\nval document = builder.parse(inputStream) // Vulnerable code - InputStream can reference external entity",
      "remediation": "Remediation could involve disabling external entity processing entirely and rejecting any XML documents that contain an entity reference. This can be done by setting the property 'FEATURE_SECURE_PROCESSING' to true on the XML parser:\n\nval factory = DocumentBuilderFactory.newInstance()\nfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\nfactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\nfactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)",
      "semgrep_rule": "rule = {\n  meta:\n    severity = \"medium\"\n    description = \"Detects possible XML External Entity (XXE) injection vulnerabilities\"\n  source:\n    lang = \"kotlin\"\n  patterns:\n    - pattern: |\n        newInputSource(\n          FileInputStream(\n            (\"?<file>.*\")\n          )\n        )\n  experiments:\n    - pattern-match\n  issued_warnings:\n    - message: \"Possible XXE injection vulnerability detected.\"\n    locations:\n      - pattern: \"file\"\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass CWE611_ImproperRestrictionOfXMLExternalEntityReference extends Rule {\n  // Query to detect code that is vulnerable to CWE-611\n  CWE611_ImproperRestrictionOfXMLExternalEntityReference() {\n    when {\n      // Find any XML parsing method\n      call < java.xml.XMLReader : Constructor() >()\n    }\n\n    then {\n      // Find any external entity reference\n      def ref = find_entity_reference(result);\n      // Find any external entity references that don't use an absolute path\n      if (!ref.isAbsolutePath()) {\n        // Report the vulnerability\n        reportFlaw(cwe.CWE611_Improper_Restriction_Of_XML_External_Entity_Reference())\n      }\n    }\n  }\n}"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server Side Request Forgery (SSRF) is a type of vulnerability where an attacker is able to send malicious requests from a vulnerable server to another server. This type of attack can be used to access restricted services, such as those requiring authentication, on the server. Additionally, the attacker can use SSRF to access internal networks, potentially leading to an escalated attack.",
      "vulnerable_code": "fun fetchData(url: String) {\n    // fetch data from the URL\n    val response = URL(url).readText()\n\n    // parse the response\n    // ...\n}\n\n// Call the function with a user-supplied URL\nval userUrl = request.getParameter(\"url\")\nfetchData(userUrl)",
      "remediation": "// Before\n\nfun doRequest(url: String) {\n    val request = Request.Builder().url(url).build()\n    val response = client.newCall(request).execute()\n}\n\n// After\n\nfun doRequest(url: String) {\n    val url = URL(url)\n    val host = url.host\n    if (!isAllowedHost(host)) {\n        throw SecurityException(\"Host is not whitelisted\")\n    }\n    val request = Request.Builder().url(url).build()\n    val response = client.newCall(request).execute()\n}\n\nfun isAllowedHost(host: String): Boolean {\n    val allowedHosts = listOf(\"example.com\", \"example2.com\")\n    return allowedHosts.contains(host)\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Server-Side Request Forgery (SSRF) vulnerability\"\n    id = \"RULE_ID\"\n    severity = \"CRITICAL\"\n    author = \"AUTHOR_NAME\"\n  strings:\n    $s_1 = \"java.net.URL\"\n    $s_2 = \"openConnection\"\n    $s_3 = \"connect\"\n    $s_4 = \"setDoOutput\"\n    $s_5 = \"getInputStream\"\n  condition:\n    all of them\n}",
      "codeql_rule": "import cwe918\n\nclass CWE918_ServerSideRequestForgery : CodeQL\n{\n    // Declare a predicate to detect functions that make HTTP requests\n    // (e.g. curl, http.get, axios.get)\n    predicate isHttpRequest(Function func) {\n        func.nameMatches(\"curl\") or\n        func.nameMatches(\"http.get\") or\n        func.nameMatches(\"axios.get\")\n    }\n\n    // Declare a predicate to detect functions that accept user-controlled\n    // parameters\n    predicate isUserControlled (Parameter param) {\n        param.hasAnnotation(\"userControlled\")\n    }\n\n    // Declare a query to detect CWE-918\n    query cwe_918_detection() {\n        // Find functions that make HTTP requests\n        Function httpRequestFunc ="
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of security vulnerability that occurs when a user is able to inject malicious commands into an application. This vulnerability allows attackers to gain access to systems and execute malicious code. The vulnerability occurs when an application doesn't properly sanitize user input, allowing attackers to inject malicious commands into the application. This can result in the application executing malicious code, which can be used to gain access to the system or to gain control of the application. Attackers can also use this vulnerability to modify or delete data and files on the application or system.",
      "vulnerable_code": "fun executeCommand(command: String) {\n    val process = Runtime.getRuntime().exec(command)\n    process.waitFor()\n    println(\"Command executed successfully\")\n}\n\n// Vulnerable call\nexecuteCommand(request.getParameter(\"command\"))",
      "remediation": "// Before\nval cmd = \"curl $userInput\"\nRuntime.getRuntime().exec(cmd)\n\n// After\nval sanitizedUserInput = userInput.replace(\";\", \"\")\nval cmd = \"curl $sanitizedUserInput\"\nRuntime.getRuntime().exec(cmd)",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Command Injection\"\n    severity = \"CRITICAL\"\n    author = \"Your Name\"\n    references = [\"https://cwe.mitre.org/data/definitions/77.html\"]\n  strings:\n    $cmd_injection = \"Runtime.getRuntime()\"\n  condition:\n    $cmd_injection\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass CWE077CommandInjection extends SecurityCodeQL {\n  /**\n  * Detects command injection by analyzing unsafe string concatenation\n  * in Java programs\n  */\n  def vulnerable_pattern(String cmd, String userInput) {\n    // Get the method containing the command\n    Method m <- findMethod(anywhere) {\n      m.getName() == cmd\n    }\n    // Find the user input parameter and concatenate it with the command\n    Expr userInputExpr <- m.getParam(userInput)\n    Expr cmdExpr <- m.getBody()\n    Expr concatExpr <- concat(userInputExpr, cmdExpr)\n    // Check if the result of the concatenation is executed\n    Expr execExpr <- containsExec(concatExpr)\n    m.getCall"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295: Improper Certificate Validation occurs when an application fails to properly validate an SSL/TLS certificate. This can happen in a number of ways, such as not validating the certificate chain, not verifying the hostname, or not verifying the certificate's expiration date. This leaves the application vulnerable to man-in-the-middle attacks, where an attacker can intercept and alter data being transmitted between the application and the server. To prevent this vulnerability, applications should ensure that certificates are properly validated before establishing any SSL/TLS connections.",
      "vulnerable_code": "val url: URL = URL(\"https://example.com\")\nval connection: HttpsURLConnection = url.openConnection() as HttpsURLConnection\nconnection.sslSocketFactory = TrustAllSocketFactory()\nconnection.hostnameVerifier = TrustAllHostnameVerifier()\nconnection.connect()",
      "remediation": "// Function to validate a certificate\nfun validateCertificate(certificate: X509Certificate): Boolean {\n    try {\n        // Validate the certificate\n        certificate.checkValidity()\n        // Verify the certificate is signed by a trusted Certificate Authority\n        val trustManager = X509TrustManagerImpl()\n        trustManager.checkServerTrusted(arrayOf(certificate), \"RSA\")\n        return true\n    } catch (e: Exception) {\n        return false\n    }\n}",
      "semgrep_rule": "rule = {\n  meta:\n    id = \"CWE-295\"\n    description = \"Detects improper certificate validation\"\n    severity = \"CRITICAL\"\n    author = \"Semgrep\"\n    reference = \"https://cwe.mitre.org/data/definitions/295.html\"\n  strings:\n    $cert_validation = /validateCertificate\\(/\n  condition:\n    $cert_validation\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass CWE295ImproperCertificateValidation:\n\t\n\t// Find calls to X509TrustManager.checkServerTrusted which do not check the chain of certificates\n\t// for validity\n\t\n    X509TrustManager.checkServerTrusted(chain, authType) as checkServerTrusted\n    {\n    \tnot exists (\n    \t\tchain.forEach(certificate => certificate.checkValidity())\n    \t)\n    }\n    \n    // Report issue\n    vulnerableTo(checkServerTrusted, cwe.ImproperCertificateValidation)\n    \n    // Suggest fixing it\n    suggestFix(checkServerTrusted,\n    \t\"Ensure that each certificate in the chain is checked for validity before calling X509TrustManager.checkServerTrusted\"\n    )"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094, Improper Control of Generation of Code ('Code Injection'), is a type of vulnerability that happens when an application dynamically generates code without properly validating or sanitizing user input. This can allow an attacker to inject malicious code into the application, which can be executed and cause unexpected behavior or damage. Attackers can use this vulnerability to gain access to sensitive information, modify data, and execute malicious code on the system.",
      "vulnerable_code": "fun maliciousFunction(input: String) {\n    val codeToRun = input // input is not sanitized\n    eval(codeToRun) // eval() is used to run the code\n}\n\nThis code can be used to inject malicious code into the system, potentially causing security issues.",
      "remediation": "// Remediation\n// Sanitize all user input before using it as an argument for any system calls\nfun exec(command: String) {\n    val sanitizedCommand = command.replace(\";\", \"\")\n    Runtime.getRuntime().exec(sanitizedCommand)\n}",
      "semgrep_rule": "rule = {\n  strings:\n  $inj_str = /.*eval.*/\n \n  condition:\n  $inj_str\n}",
      "codeql_rule": "import cwe_check\n\nclass ImproperControlOfGenerationOfCode implements CweCheck {\n  override fun getCweId() = \"CWE-094\"\n\n  override fun check(node: AstNode): List<Issue> {\n    val issues = mutableListOf<Issue>()\n    \n    // Check for usage of eval(), exec(), execfile() and other functions that can generate code\n    if (node is FunctionCall &&\n        node.name in setOf(\"eval\", \"exec\", \"execfile\")) {\n      issues += Issue(node, \"Improper control of generation of code\", \"Potential code injection vulnerability\")\n    }\n    \n    // Check for command injection in shell scripts\n    if (node is AssignmentExpr &&\n        node.right is BinaryExpr &&\n        node.right.operator.kind == BinaryOperator.Kind.Concat) {"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269: Improper Privilege Management is a vulnerability that can occur when an application fails to properly manage user privileges. This type of vulnerability can allow an attacker to gain access to privileged functions and features that they should not have access to. These privileges can include access to sensitive data, the ability to modify system configurations, and the ability to execute malicious code. Failure to properly manage user privileges can leave an application open to attack and can lead to a number of security issues.",
      "vulnerable_code": "fun main(args: Array<String>) {\n    val user = getUser()\n    val admin = getAdmin()\n\n    // Vulnerable code\n    admin.updateData(user.data)\n}\n\nfun getUser(): User {\n    return User(\"Bob\")\n}\n\nfun getAdmin(): Admin {\n    return Admin(\"Alice\")\n}\n\nclass User(val name: String) {\n    var data: String = \"\"\n}\n\nclass Admin(val name: String) {\n    fun updateData(data: String) {\n        this.data = data\n    }\n    var data: String = \"\"\n}",
      "remediation": "Remediation for CWE-269 can involve implementing appropriate access control measures to ensure that users are only given privileges in accordance with their role and clearance level. For example, a privilege management system can be implemented which assigns users different levels of privileges depending on their role and clearance. Furthermore, all privileges should be reviewed on a regular basis and revoked when no longer necessary. Additionally, the system should be configured to log any privilege changes, so that any unauthorised changes can be detected and investigated.",
      "semgrep_rule": "rule = {\n  id: \"CWE-269-Improper-Privilege-Management\"\n  patterns: [\n    {\n      pattern: \"$var_name := set_privilege($privilege_level)\"\n      message: \"Improper privilege management detected\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe269\n\nclass CWE269ImproperPriviledgeManagement:\n  // Set of functions that are used to gain access to resources.\n  // For example: open, chown, setuid, etc.\n  // These functions are used to change the permissions of a resource\n  // and should be used with caution.\n  private let privilegedFunctions = [\"open\", \"chown\", \"setuid\", ...]\n\n  // Finds calls to privileged functions\n  predicate isPrivilegedFunctionCall(CallExpr e) {\n    e.callee.name in privilegedFunctions\n  }\n\n  // Rule to detect privilege misuse\n  // A potential security issue can occur if the function is called\n  // without the appropriate permissions.\n  //\n  // For example:\n  // setuid(0)\n  //\n  // The above invocation of setuid would grant the calling process full"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is a type of injection attack where an attacker can inject malicious code into an expression language statement to gain access to unauthorized information or to modify the application's behavior without authorization. This vulnerability occurs when an application fails to properly sanitize user input, allowing an attacker to inject malicious code into an expression language statement. This can be done by using malicious code in a query string, form input, or cookie value. If the application fails to properly sanitize the user input, the attacker can inject malicious code which can be used to modify the application's behavior or gain access to unauthorized information.",
      "vulnerable_code": "In the following code snippet, an attacker can inject malicious code into the expression language statement, which can be used to execute arbitrary code in the application:\n\nval expression = \"${request.getParameter(\"expression\")}\"\nval result = Expression.evaluate(expression)",
      "remediation": "// Before\nval userInput: String? = ...\nval query = \"SELECT * FROM users WHERE name = '$userInput'\"\n\n// After\nval userInput: String? = ...\nval safeInput = userInput?.replace(\"'\", \"''\")\nval query = \"SELECT * FROM users WHERE name = '$safeInput'\"",
      "semgrep_rule": "rule = {\n\tmeta:\n\t  description = \"Detects Expression Language Injection vulnerability\"\n\t  severity = \"CRITICAL\"\n\t  author = \"Author\"\n\t  date = \"2020-12-14\"\n\tsource:\n\t  lang = \"kotlin\"\n\t  code = \"\"\"\n\t\t// code here\n\t  \"\"\"\n\tpattern:\n\t  expression = \"\\\\$\\\\{.*\\\\}\"\n\t  message = \"Expression Language Injection vulnerability detected.\"\n}",
      "codeql_rule": "import cwe\nimport java\n\nclass ExpressionLanguageInjection extends Vulnerability {\n  ExpressionLanguageInjection() {\n    super(cwe:CWE-917)\n  }\n\n  // Matches usage of vulnerable expression language statements\n  predicate vulnerableStatement() {\n    exists(MethodCall exprLang)\n    // Checks for vulnerable expression language statements\n    exprLang.getTarget().toString() = \"getExpressionEvaluator\"\n  }\n  \n  // Matches usage of vulnerable data as input\n  predicate vulnerableInput() {\n    // Checks for vulnerable data being passed as input\n    exists(StringLiteral userInput)\n  }\n\n  // Checks for vulnerable statement and vulnerable input in the same method\n  @Override\n  predicate isVulnerable() {\n    vulnerableStatement() and vulnerableInput()\n  }\n}"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability that occurs when a program does not properly resolve linked files before attempting to access them. This can lead to unintended files being accessed which could potentially lead to the disclosure of sensitive information. The vulnerability usually occurs when the application is trying to access a file, but the wrong file is being accessed due to an incorrect link being followed. This could be due to a lack of input validation or incorrect assumptions about the path of the file.",
      "vulnerable_code": "val path = \"path/to/my/file.txt\"\nval file = File(path)\n\n// Vulnerable code\nif (file.exists()) {\n    // Do something with the file\n}",
      "remediation": "// Remediation\n\n// First, check if the file path is valid before attempting to access it\nfun checkFilePath(filePath: String): Boolean {\n    return File(filePath).exists()\n}\n\n// Second, check if the file is located within an allowed directory\nfun checkFileDirectory(filePath: String): Boolean {\n    return File(filePath).absolutePath.startsWith(\"/allowed/directories/\")\n}\n\n// Third, if necessary, sanitize the file path to prevent malicious input\nfun sanitizeFilePath(filePath: String): String {\n    return filePath.replace(\"..\", \"\")\n}\n\n// Finally, use the sanitized file path for all file system operations\nfun readFile(filePath: String) {\n    val sanitizedFilePath = sanitizeFilePath(filePath)\n    if (checkFilePath(",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: \"File.create(file:$f)\",\n      operands: [\n        {\n          name: \"f\",\n          kind: \"expr_ref\"\n        }\n      ]\n    },\n    {\n      pattern: \"File.exists(file:$f)\",\n      operands: [\n        {\n          name: \"f\",\n          kind: \"expr_ref\"\n        }\n      ]\n    }\n  ],\n  message: \"Improper link resolution before file access detected\",\n  severity: \"error\"\n}",
      "codeql_rule": "import cwe059\n\nclass CWE059LinkFollowingVulnerability(Trace t):\n    // Check if the trace t is of a vulnerable file operation type\n    FileOperation vulnerableFileOp = FileOperation.FileRead\n        or FileOperation.FileWrite\n        or FileOperation.FileExecute\n    if vulnerableFileOp.matches(t) then\n        // Check if the trace t is a link followed file operation\n        if t.isLinkFollowed() then\n            cwe059.report()\n        endif\n    endif\nend"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information is transmitted over a network in plain text, without encryption. This type of transmission can be intercepted and read by malicious actors, exposing the sensitive information in an insecure way. Attackers can use this vulnerability to gain access to confidential data such as passwords, financial information, and other sensitive information. This vulnerability can be prevented by using secure protocols such as TLS/SSL for communication, and encrypting sensitive information before it is sent over the network.",
      "vulnerable_code": "val url = \"http://example.com/data\"\nval connection = URL(url).openConnection()\nval response = connection.inputStream.bufferedReader().readText()",
      "remediation": "The remediation for CWE-319 is to encrypt the sensitive information before transmitting it. This can be done in Kotlin using the Java Cryptography Architecture (JCA). \n\nExample code for encrypting and decrypting data with JCA: \n\n//Encrypting data \nval cipher = Cipher.getInstance(\"AES\")\nval secretKeySpec = SecretKeySpec(key, \"AES\")\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec)\nval encryptedBytes = cipher.doFinal(dataToEncrypt)\n\n//Decrypting data\nval cipher = Cipher.getInstance(\"AES\")\nval secretKeySpec = SecretKeySpec(key, \"AES\")\ncipher.init(Cipher.DECRYPT_MODE, secretKeySpec)\nval decryptedBytes = cipher.doFinal(encryptedBytes)",
      "semgrep_rule": "rule = {\n  strings:\n    $HTTP_METHOD = \"GET\"\n    $SENSITIVE_INFO = /.*/\n  condition:\n    $HTTP_METHOD @rx /^GET$/ and\n    $SENSITIVE_INFO @rx /^[a-zA-Z0-9]+$/ and\n    $HTTP_METHOD and $SENSITIVE_INFO\n  message: \"CWE-319: Cleartext Transmission of Sensitive Information\"\n}",
      "codeql_rule": "import cwe319\n\nclass CWE319_Cleartext_Transmission_Sensitive_Info:\n\t// Rule to detect cleartext transmission of sensitive information\n\t// using functions that do not use encryption\n\t\n\t// Get all functions that are defined in the code\n\tquery functionDefinition\n\t\n\t// Get all functions that are used to transmit data\n\t// without using encryption\n\tquery transmissionWithoutEncryption {\n\t\t// Find functions that are used to transmit data\n\t\ttransmissionFunc = some(functionDefinition) such that\n\t\t\texists(CallExpr c, ClassInstanceCreationExpr e |\n\t\t\t\tc.getTarget().getName() == transmissionFunc.getName()\n\t\t\t\tand e.getType().matches(\"java.net.URL\")\n\t\t\t\tand c.getArgument(0).matches(\""
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 (Open Redirection) is a vulnerability that occurs when an application, such as a web application, allows a user to be redirected to an untrusted external domain. This can be exploited by a malicious user to redirect a user to an untrusted website, allowing the malicious user to steal the user's credentials or perform other malicious actions. In an application written in Kotlin, this vulnerability could be exploited by using the URL class to allow a user to enter a URL which is then used to redirect the user to an untrusted website.",
      "vulnerable_code": "fun redirectToUntrustedSite(url: String) {\n    val untrustedUrl = request.getParameter(\"url\")\n    \n    // Redirect to untrusted URL without any validation\n    response.sendRedirect(untrustedUrl)\n}",
      "remediation": "// Before\nval redirectUrl: String = request.getParameter(\"redirect\")\nresponse.sendRedirect(redirectUrl)\n\n// After\nval redirectUrl: String = request.getParameter(\"redirect\")\n// Validate the URL\nif (redirectUrl.startsWith(\"https://example.com\")) {\n    response.sendRedirect(redirectUrl)\n} else {\n    response.sendError(HttpServletResponse.SC_BAD_REQUEST)\n}",
      "semgrep_rule": "rule = {\n  pattern = \"HttpURLConnection.setFollowRedirects(true)\"\n  message = \"Potential CWE-601: URL Redirection to Untrusted Site ('Open Redirect') vulnerability detected\"\n  severity = \"WARNING\"\n}",
      "codeql_rule": "import cwe601\n\nclass CWE601OpenRedirectVulnerability {\n    // Finds instances of URL redirection that are not trusted\n    vulnerable_function = Entity.function(\"java.net.HttpURLConnection.setInstanceFollowRedirects\")\n\n    // Finds instances of URL redirection that are not trusted\n    untrusted_redirection = Vulnerability.cwe601.UntrustedRedirection\n\n    // Set the query\n    query CWE601OpenRedirectVulnerability {\n        // Finds functions that set URL redirection to an untrusted site\n        if (vulnerable_function.exists() && untrusted_redirection.exists()) {\n            vulnerable_function.where(untrusted_redirection.getCallee())\n        }\n    }\n}"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability related to the insertion of sensitive information into log files. This vulnerability occurs when an application or system logs sensitive user data, such as passwords, financial information, or other confidential information, to a log file without masking or encrypting it. As a result, any unauthorized user with access to the log file can view the sensitive data, potentially leading to data theft or misuse.",
      "vulnerable_code": "fun logData(data: String) {\n    val logFile = File(\"/var/log/log.txt\")\n    logFile.writeText(\"User data: $data\")\n}\n\nThis code is vulnerable to CWE-532 because it inserts sensitive data, such as user data, into a log file. This allows the data to be accessed by anyone who has access to the log file.",
      "remediation": "// Remediate CWE-532: Insertion of Sensitive Information into Log File\n\n// Disable logging of sensitive information\nLogger.getLogger(\"myLogger\").setFilter { record ->\n    if (record.message.contains(\"sensitiveInfo\")) {\n        return@setFilter false\n    }\n    true\n}",
      "semgrep_rule": "rule = {\n        meta:\n          author = \"Your Name\"\n          description = \"Detects the insertion of sensitive information into log files\"\n          severity = \"high\"\n        source:\n          patterns:\n            - pattern: 'log\\.info\\([\\s]*\"[\\w\\s\\d!-*_@#$%&.,;:(){}\\[\\]\\'/+\\\\]*\\b(password|key|credential|token)\\b[\\w\\s\\d!-*_@#$%&.,;:(){}\\[\\]\\'/+\\\\]*\"'\n              message: \"Found sensitive information in log file\"\n        }",
      "codeql_rule": "import cwe\nimport java\n\nclass InsertionOfSensitiveInformationIntoLogFile extends Rule {\n  // detect any logging of sensitive information\n  when {\n    call = cwe.LoggingOfSensitiveInformation() \n  } then {\n    // alert if the call is found\n    report(call.method, \"This call logs sensitive information. (CWE-532)\")\n  }\n}"
    }
  },
  "PHP": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of web application vulnerability that occurs when an attacker injects malicious code into a web page. This malicious code can be executed by a user's web browser and can be used to steal information, manipulate user interface elements, or redirect the user to malicious website. XSS exploits occur when an application does not properly neutralize user input before including it in output that is sent to a web browser. This can lead to the malicious code being interpreted and executed by the browser.",
      "vulnerable_code": "<?php\n$userInput = $_GET['input'];\necho \"<h1>Hello $userInput</h1>\";\n?>\n\nIn the above code, if a user provides malicious input through the \"input\" parameter, such as <script>alert('XSS')</script>, the code will execute the malicious JavaScript code in the user's browser. This can be used to steal user data or modify the page content.",
      "remediation": "// Before\necho $_GET['input'];\n\n// After\necho htmlspecialchars($_GET['input'], ENT_QUOTES, 'UTF-8');",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper neutralization of input during web page generation\"\n    severity = \"MEDIUM\"\n    author = \"Your Name\"\n \n  source:\n    language = \"php\"\n \n  detection:\n    input: \n      // Finds any input that is echoed to the page without proper escaping\n      pattern = 'echo $_[GET|POST|REQUEST|COOKIE]\\['{0,1}[^\\]^\\[]+\\]{0,1}'\n    condition: input\n}",
      "codeql_rule": "import cwe080\n\nclass VulnerabilityDetected extends Audit {\n  /**\n  * @description This rule detects if any user-supplied input is used in a web page without proper neutralization.\n  */\n \n  // The query will search for code blocks that take input from the user,\n  // and generate web page output without proper neutralization.\n \n  // Find code blocks that take user input and generate web page output\n  @Cwe080\n  def vulnerableCode(Input: Expr, Output: Expr): Bool {\n    \n    // Check if the Input is of a type that could contain malicious code\n    (Input.isKind(Expr.LiteralString) or \n    Input.isKind(Expr.LiteralNumber) or \n    Input.isKind(Expr.LiteralBoolean) or \n    Input.isKind("
    },
    "CWE-020: Improper Input Validation": {
      "description": "CWE-020 is a vulnerability related to improper input validation. This vulnerability occurs when user input is not properly validated and may allow malicious code to be executed. This can lead to a variety of security issues, including injection attacks, buffer overflow, and other attacks. Additionally, it can allow attackers to gain access to sensitive information or take control of system resources.",
      "vulnerable_code": "<?php\n$username = $_POST['username'];\n$password = $_POST['password'];\n\nif($username == \"admin\" && $password == \"password\") {\n    echo \"Welcome, Admin!\";\n} else {\n    echo \"Invalid credentials\";\n}\n?>\n\nThis code is vulnerable to CWE-020 because it does not perform any validation on the input provided by the user. An attacker could easily provide malicious input, such as a SQL injection attack, to gain access to the system.",
      "remediation": "//Preventing CWE-020\n$input = filter_input(INPUT_POST, 'input', FILTER_SANITIZE_STRING);\nif(!empty($input)) {\n    //Perform operations here\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper input validation\"\n    severity = \"CRITICAL\"\n  source:\n    languages = [\"PHP\"]\n  patterns:\n  - pattern: \"!preg_match($_GET[.*], .*)\"\n    message: \"Improper input validation detected\"\n}",
      "codeql_rule": "import php\n\nclass ImproperInputValidation extends Query {\n \n  // Finds any instances of an insecure input validation\n  predicate isVulnerableInputValidation() {\n    exists(FuncCall fc, Parameter p |\n      fc.getFunction() = \"filter_input\" and \n      p.hasDefaultValue() and\n      not p.hasSecurityConstraint()\n    )\n  }\n  \n  // Finds any instances of an insecure input validation\n  predicate isVulnerableInputValidation2() {\n    exists(FuncCall fc, Parameter p |\n      fc.getFunction() = \"filter_var\" and \n      p.hasDefaultValue() and\n      not p.hasSecurityConstraint()\n    )\n  }\n  \n  // Main query\n  query ImproperInputValidation() {\n    // Finds"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of vulnerability which occurs when an application does not properly sanitize user input before executing an operating system command. This allows an attacker to inject malicious commands that could be used to access sensitive data, modify the system, or execute arbitrary code on the system. The vulnerability can be exploited by sending specially crafted inputs to the application, which are then executed as commands on the underlying operating system.",
      "vulnerable_code": "$userInput = $_GET['input'];\n$command = 'dir ' . $userInput;\nsystem($command);\n\nThis code is vulnerable to OS command injection, as it takes user input directly and passes it to the system() function, without any sanitization. An attacker could craft a malicious input that would execute malicious code on the system.",
      "remediation": "To remediate this vulnerability, it is important to ensure that any user input is properly sanitized before being used in an OS command. This can be done by using a whitelisting approach that only allows specific known-safe characters or strings to be used in the command. For example, the following code snippet would ensure that only alphanumeric characters are used in the OS command:\n\n$user_input = preg_replace('/[^A-Za-z0-9]/', '', $user_input);\n$command = 'some_command ' . $user_input;\nsystem($command);",
      "semgrep_rule": "rule = {\n  strings:\n    $cmd = \"$_GET['cmd']\"\n  condition: $cmd\n}",
      "codeql_rule": "import cwe078\n\nclass CWE078CommandInjection extends Rule {\n  // Finds uses of functions vulnerable to command injection\n  // from https://cwe.mitre.org/data/definitions/78.html\n  //\n  // Note: This rule is not comprehensive.\n  //\n  // Examples:\n  //   system()\n  //   exec()\n  //   shell_exec()\n  //   passthru()\n  //   pcntl_exec()\n  //   popen()\n  //   proc_open()\n  //   backticks operator\n  //\n  // References:\n  // https://www.owasp.org/index.php/Command_Injection\n\n  // Find the vulnerable functions\n  predicate vulnerableFunctions(Expr e) {\n    e.hasAncestor(\n      call {\n        cal"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089 is a type of vulnerability which occurs when an attacker is able to inject malicious SQL commands into a web application. This can lead to data leakage, data manipulation, or other malicious activities. Attackers are able to exploit this vulnerability by inputting malicious data into an application and exploiting the lack of input validation. By manipulating the application, they can gain access to sensitive information, manipulate data, or cause other malicious activities.",
      "vulnerable_code": "$username = $_GET['username'];\n$password = $_GET['password'];\n\n$query = \"SELECT * FROM users WHERE username='$username' AND password='$password'\";\n\nmysqli_query($conn, $query);",
      "remediation": "// Remediation\n\n$search_term = filter_var($_GET['search_term'], FILTER_SANITIZE_STRING);\n$query = \"SELECT * FROM products WHERE name LIKE '%\".$search_term.\"%'\";\n\n// Prepared statement\n\n$stmt = $db->prepare('SELECT * FROM products WHERE name LIKE ?');\n$stmt->bind_param('s', $search_term);\n$stmt->execute();",
      "semgrep_rule": "rule = {\n\tid: \"cwe-089-sql-injection-detection\"\n\tpattern: $x := /(select|delete|update).*(from|into|where)/\n\tmessage: \"Possible SQL Injection detected at {{$x.start}}\"\n\tlevel: WARNING\n}",
      "codeql_rule": "import cwe089\n\nclass Vuln_CWE089_SQL_Injection extends Rule {\n    // Checks for improper neutralization of special elements in an SQL command\n    // used in an SQL query (SQL Injection).\n    //\n    // References:\n    // CWE-089: https://cwe.mitre.org/data/definitions/89.html\n    //\n    // Example of vulnerable code:\n    //\n    // $sql = \"SELECT * FROM users WHERE id = \" . $_GET['user_id'];\n    //\n    // Example of secure code:\n    //\n    // $user_id = mysqli_real_escape_string($_GET['user_id']);\n    // $sql = \"SELECT * FROM users WHERE id = \" . $user_id;\n    //\n    getInfo() {\n        return {\n            \""
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path Traversal is a type of vulnerability that occurs when an application does not properly restrict paths used for file operations. An attacker can use this vulnerability to gain access to sensitive files and data beyond the intended access privileges by supplying a maliciously crafted path, such as \"../\" or \"../../\", in a file operation, such as a file upload, file download, or include/require statement in PHP. This vulnerability allows an attacker to access files and directories outside of the intended directory structure, potentially leading to the exposure of sensitive data or system compromise.",
      "vulnerable_code": "$file = $_GET['file'];\n$path = '/var/www/html/'.$file;\nif (file_exists($path)) {\n    include $path;\n}\n\nIn this example, if a user passes a malicious value for the 'file' parameter in the URL, they can potentially access any file on the server. For example, if a malicious user passes in '../../../../etc/passwd', the application will include the contents of the system's passwd file.",
      "remediation": "The following example shows a PHP function which can be used to prevent path traversal attacks. This function takes a user-supplied path and uses realpath() to ensure the path is within an expected directory:\n\n<?php \nfunction is_valid_path($user_input)\n{\n    // Set the expected directory\n    $expected_dir = \"/var/www/uploads/\";\n\n    // Resolve the path\n    $path = realpath($user_input);\n\n    // Check if the path is within the expected directory\n    if (strpos($path, $expected_dir) === 0) {\n        // Path is valid\n        return true;\n    }\n    else {\n        // Path is invalid\n        return false;\n    }\n}\n?>",
      "semgrep_rule": "rule = {\n  meta:\n    severity = \"WARNING\"\n    author = \"security@example.com\"\n    description = \"Detects the improper limitation of a pathname to a restricted directory\"\n  patterns:\n    - pattern: '$_GET\\[.*\\]\\|\\|.*\\.\\.\\/'\n      message: \"Potential Path Traversal vulnerability detected.\"\n}",
      "codeql_rule": "import cwe022\n\nclass PathTraversalVulnerability : SecurityBug {\n  CWE022 c;\n\n  // Create a predicate to detect user-controlled inputs\n  predicate isUserControlled(string f) {\n    exists(string s; f == s)\n  }\n  \n  // Create a predicate to detect output locations\n  predicate isOutputLocation(string f) {\n    exists(string s; f == s)\n  }\n  \n  // Create a predicate to detect file functions\n  predicate isFileFn(Expr e) {\n    exists(CallExpr c; c.callee.matches(\"fopen\")\n      and isUserControlled(c.getArg(0).value)\n      and isOutputLocation(c.getArg(1).value))\n  }\n  \n  // Check if a function has a malicious user-controlled input"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site request forgery (CSRF) is a type of vulnerability that occurs when an attacker tricks a user into performing an undesired action on a web application that the user is currently authenticated to. This type of attack is commonly seen in PHP applications, where an attacker can craft a malicious request that masquerades as a legitimate request from the user. The malicious request can then be used to access or modify data on the web application, such as deleting or changing user accounts or making unauthorized purchases. In order to protect against this vulnerability, applications must implement measures to verify that the requests are coming from trusted sources and that the user's session is still active.",
      "vulnerable_code": "The following code example is vulnerable to a CSRF attack:\n\n<?php\nif (isset($_POST['action'])) {\n    if ($_POST['action'] == 'deleteUser') {\n        deleteUser($_POST['userId']);\n    }\n}\n?>\n\nIn this example, the deleteUser() function is called without any input validation or authentication. An attacker could craft a malicious link or form that would cause this code to be executed, resulting in the deletion of a user account even if the user was not logged in.",
      "remediation": "The most effective way to remediate a Cross-Site Request Forgery (CSRF) vulnerability is to implement a CSRF token. This is a unique identifier that is associated with each valid request and is used to verify that a request is legitimate. The token should be unpredictable and generated randomly on the server-side.\n\nThe following is an example of how to implement a CSRF token in a web application written in PHP:\n\n1. Generate a random token on the server-side (e.g. using the generate_random_string() function).\n\n2. Store the token in the user's session data.\n\n3. Add the token to all forms as a hidden field.\n\n4. Validate the token on the server-side before processing the request.\n\n5. Regenerate the token after each valid request.",
      "semgrep_rule": "rule = {\n    meta: \n        description = \"Detects Cross-Site Request Forgery (CSRF) vulnerability\"\n        severity = \"WARNING\"\n    source: \n        lang = \"php\"\n    patterns: \n        - pattern: '$_POST'\n        - pattern: '$_GET'\n        - pattern: '$_REQUEST'\n    filters: \n        - not: \n            pattern: 'token'\n}",
      "codeql_rule": "import cwe352\n\nclass CWE352CSRFVulnerability : Vulnerability{\n  CWE352CSRFVulnerability() {\n      super(\"CWE-352: Cross-Site Request Forgery (CSRF)\");\n  }\n  \n  // SQL query to detect an HTTP request method of POST\n  @Override\n  predicate isCandidate(){\n      HttpRequestMethod.matches(\"POST\")\n  }\n  \n  // SQL query to identify the lack of a CSRF token\n  @Override\n  predicate isVulnerable(){\n      exists(VariableDecl v |\n        v.hasName(\"CSRF_token\") and\n        not exists(Assignment a |\n          a.getLeft().getVariable() == v and\n          a.getRight().getType().matches(\"string\")\n        )\n      )\n  }\n  \n  @Override\n  vulnerableClasses"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability that occurs when an application allows an attacker to upload a file of a dangerous type, such as an executable. This type of vulnerability can be used to upload malicious code to a server, potentially allowing an attacker access to the system and data stored within. In addition, an attacker may be able to execute the uploaded file and cause damage to the system.",
      "vulnerable_code": "<?php \n \n// Get the filename and make sure it is valid\n$filename = basename($_FILES['uploaded_file']['name']);\n\n// Check if the file type is allowed\n$allowed = array('jpg','jpeg','gif','png');\nif(!in_array(substr($filename, strrpos($filename, '.') + 1), $allowed)){\n    die('Error: File type not allowed');\n}\n\n// Move the file to the uploads folder\n$destination = 'uploads/' . $filename;\nif(move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $destination)){\n    echo \"File successfully uploaded\";\n}\n?>\n\nThe code above is vulnerable to CWE-434 because it does not properly check the file type of the uploaded file and",
      "remediation": "//Perform checks on the file being uploaded to ensure it is of an accepted file type.\n//Check that the file is not a .php, .js, .htaccess, .sh, .asp, .cgi, .pl, .py, .exe, .bat, .cmd, .vbs, .reg, .bin, .scr, .com, .inf, .sys, .msi, .htm, .html, .js, .jsp, .swf, .jar, .cab, .jar, .msc, or .dll.\nif (in_array($file_extension, array('.php', '.js', '.htaccess', '.sh', '.asp', '.cgi', '.pl', '.py', '.exe', '.bat', '.cmd', '.vbs', '.reg', '.bin', '.scr', '.com', '.inf', '.sys', '.msi",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects CWE-434: Unrestricted Upload of File with Dangerous Type\"\n        severity = \"CRITICAL\"\n        tags = [\"cwe-434\", \"file-upload\"]\n    strings:\n        $dangerous_type = /\\.(php|asp|aspx|jsp|cgi|pl)$/\n    files:\n        $dangerous_file = /.*\\.$dangerous_type/\n    conditions:\n        $dangerous_file\n}",
      "codeql_rule": "import cwe434\n\nclass UnrestrictedUploadFileDangerousType : CodeQL.Vulnerability {\n  predicate isFileUpload() {\n    exists(FunctionCall fc | fc.getTarget().getName() = \"move_uploaded_file\")\n  }\n\n  predicate isDangerousType(string type) {\n    type matches \"php\"\n  }\n\n  // Check that the destination directory is outside of web root\n  predicate isOutsideWebRoot(Expr dir) {\n    exists(FileSystemReceiver fs | fs.getReceiver() = dir and not fs.isWithinWebRoot())\n  }\n\n  // Check if the uploaded file is of a dangerous type\n  predicate isDangerousUpload(Expr file, Expr dir) {\n    exists(StringLiteral s | s.getValue() = file and isDangerousType(s.getValue"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306 is a vulnerability that occurs when a critical function of an application, such as a financial transaction or a system configuration, does not have proper authentication measures in place. This means that any user, regardless of their level of authorization, is able to access and execute the critical function. This can lead to unauthorized access to data or resources, or even the complete compromise of the system.",
      "vulnerable_code": "<?php\n$user_id = $_GET['user_id'];\n$query = \"SELECT * FROM users WHERE id = $user_id\";\n$result = mysqli_query($conn, $query);\n\nif(mysqli_num_rows($result) > 0){\n\t// process data\n}\n?>\n\nIn this code example, there is no authentication check to make sure the user is authorized to access the user information. As a result, anyone who knows the URL can access the user data without proper authorization.",
      "remediation": "A remediation for CWE-306 would be to implement an authentication system that requires users to authenticate before they can access any critical functions. This can be done using a combination of password and user authentication, such as requiring a username and password, or using a two-factor authentication system. Additionally, the system should require users to re-authenticate after a certain period of time, or after performing any critical functions. Finally, access control measures should be put in place to ensure that only authorized users can access the critical functions.",
      "semgrep_rule": "rule = {\n    id: \"CWE-306-Missing-Authentication-For-Critical-Function\",\n    patterns: [\n        {\n            pattern: \"if ( $AUTHENTICATED != true ) {\",\n            message: \"Missing Authentication for Critical Function\"\n        }\n    ],\n    language: \"php\",\n    severity: \"warning\"\n}",
      "codeql_rule": "import php\n\nclass MissingAuthForCriticalFunctionRule extends SecurityRule {\n \n  // Finds instances of a critical function that is not properly authenticated\n  @Override\n  getCweId() {\n    return 306;\n  }\n \n  @Override\n  getDescription() {\n    return \"Detects instances of a critical function that is not properly authenticated\";\n  }\n  \n  @Override\n  getRiskLevel() {\n    return RiskLevel.HIGH;\n  }\n  \n  @Override\n  getDetectableIssues() {\n    return [DetectableIssue.VULNERABILITY];\n  }\n  \n  @Override\n  getHint() {\n    return \"Ensure that all critical functions are properly authenticated\";\n  }\n  \n  @Override\n  getName() {\n    return \"Missing authentication for critical function\";\n  }"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability that occurs when untrusted data is deserialized by an application. Deserialization is the process of reconstructing an object from its serialized form. When an application deserializes untrusted data, it can be manipulated by an attacker to execute malicious code or access sensitive information. This can lead to remote code execution, information disclosure, and other security issues.",
      "vulnerable_code": "//Example of vulnerable code\n$unserializedData = unserialize($_GET['data']);\necho $unserializedData;",
      "remediation": "The following code example shows how to remediate the CWE-502 vulnerability by using PHP's built-in unserialize() function with the allowed_classes parameter. This parameter allows us to specify which classes are allowed to be unserialized, preventing any malicious classes from being deserialized. \n\n$serialized_data = '...'; \n$allowed_classes = array('MyClass'); \n$unserialized_data = unserialize($serialized_data, array('allowed_classes' => $allowed_classes));",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects deserialization of untrusted data\"\n        id = \"CWE-502\"\n        author = \"@example\"\n    source:\n        language = \"php\"\n    strings:\n        $untrusted_data = \"*\"\n    condition:\n        $untrusted_data and any\n}",
      "codeql_rule": "import cwe502\n\nclass DeserializationVulnerability extends Rule {\n  Boolean isUntrustedDataType(Type type) {\n    return type.isSubtypeOf(\"untrusted data type\")\n  }\n  \n  query isVuln() {\n    Deserialization | \n    Deserialization.objectType(type) & \n    isUntrustedDataType(type)\n  }\n\n  vulnerable(Deserialization vuln) {\n    cwe502.report(vuln)\n  }\n}"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability in which an application does not adequately verify the identity of a user before allowing them access to certain functions or resources. This can leave the application vulnerable to attacks by malicious users, who can gain access to sensitive information or resources without the proper authentication. This vulnerability can be caused by a number of factors, such as weak or nonexistent password policies, lack of two-factor authentication, or improper access control configurations.",
      "vulnerable_code": "//Incorrect authentication code \nif(isset($_POST['username']) && isset($_POST['password']))\n{\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    \n    $sql = \"SELECT * FROM user WHERE username = '\".$username.\"'\";\n    $result = mysqli_query($conn, $sql);\n    $row = mysqli_fetch_assoc($result);\n    \n    if($row['password'] == $password)\n    {\n        //Successful authentication\n    }\n    else\n    {\n        //Authentication failed\n    }\n}",
      "remediation": "// Before \nif (isset($_POST['username']) && isset($_POST['password'])) {\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    //authentication logic\n    if ($username == 'admin' && $password == 'password') {\n        //user is authenticated\n    }\n}\n\n// After \nif (isset($_POST['username']) && isset($_POST['password'])) {\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    //authentication logic\n    $hashed_password = hash('sha256', $password);\n    if ($username == 'admin' && $hashed_password == 'HashedPasswordGoesHere') {\n        //user is authenticated\n    }\n}",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects improper authentication vulnerabilities\"\n      author = \"Semgrep\"\n    source:\n      languages = [\"PHP\"]\n    detection:\n      condition: all of them\n        - pattern: \"if\\s*\\(\\s*\\$_POST\\s*\\['username'\\]\\s*==\\s*\\$username\\s*\\&\\&\\s*\\$_POST\\s*\\['password'\\]\\s*==\\s*\\$password\\s*\\)\"\n          message: \"Improper authentication vulnerability detected\"\n          severity: \"CRITICAL\"\n}",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthenticationChecker extends Checker {\n  // Override the check method to detect the presence of this vulnerability\n  // in the given code\n  override check(Cwe287Query cwe287Query, Symbol sym) {\n    if (sym.hasAnnotation(\"cwe287\")) {\n      // Find any authentication checks in the code\n      foreach (Statement stmt in cwe287Query.findAuthenticationChecks(sym)) {\n        // Check if the authentication check is properly implemented\n        if (!cwe287Query.isAuthenticationCheckProperlyImplemented(stmt)) {\n          // Flag the code as vulnerable\n          reportIssue(stmt, \"Improper authentication detected\")\n        }\n      }\n    }\n  }\n}"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a type of vulnerability that occurs when an application stores credentials (such as usernames and passwords) in hard-coded form within the source code. This makes it easy for malicious actors to gain access to the application and its sensitive data, as the credentials are not protected or encrypted. This vulnerability can be especially dangerous if the application is exposed to the public, as anyone with access to the source code can view the credentials.",
      "vulnerable_code": "$username = \"admin\";\n$password = \"password\";\n\nif(isset($_POST['username']) && isset($_POST['password'])){\n\tif($_POST['username'] == $username && $_POST['password'] == $password){\n\t\t//allow user to log in\n\t}\n\telse{\n\t\techo \"Invalid login credentials\";\n\t}\n}",
      "remediation": "The best way to remediate a vulnerability related to hard-coded credentials is to remove the credentials from the code and store them in an external, secure location. This way, the credentials can be accessed only by authorized personnel and the code remains free from hard-coded credentials.\n\nFor example, an application could store its credentials in an encrypted configuration file and use a library to access the credentials. This way, the application can authenticate with the credentials without having to hard-code them in the source code.",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects hardcoded credentials\"\n        severity = \"CRITICAL\"\n        author = \"Security Team\"\n    strings:\n        $credential1 = /[a-zA-Z0-9]{3,20}/\n        $credential2 = /[a-zA-Z0-9]{3,20}/\n    condition:\n        (all of them) and (\n            $credential1@$credential2\n            or\n            $credential1:$credential2\n            or\n            $credential1 = $credential2\n        )\n}",
      "codeql_rule": "import cwe\n\nclass HardcodedCredential : CodeSmell {\n  // Finds hardcoded credentials in PHP code\n  // by looking for strings of the form `username:password`\n  // and `password`\n \n  @Override\n  predicate isSmell(TextNode text) {\n    text.hasString(\"[A-Za-z0-9]+:[A-Za-z0-9]+\") or\n    text.hasString(\"[A-Za-z0-9]+\")\n  }\n \n  @Override\n  void report(TextNode text) {\n    report (\"Hard-coded credentials found at: \", cwe`CWE-798`, text);\n  }\n}"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276: Incorrect Default Permissions is a vulnerability in which a web application or server is configured with default settings that grant access to resources or files that should be kept secure. This can be done by setting overly permissive file permissions, such as granting read and write access to all users on a file or directory. An attacker can exploit this vulnerability by accessing sensitive files or resources without proper authentication or authorization. In addition, if default accounts and passwords are not changed, an attacker can also gain access to the system using these accounts.",
      "vulnerable_code": "<?php\n// vulnerable code with incorrect default permissions\n$file = fopen(\"sensitive_file.txt\", \"r\");\n// the file is readable by anyone\n?>",
      "remediation": "To remediate this vulnerability, the code should check the permissions of each file and directory, and ensure that they are set to the most secure setting. This can be done using the chmod() function in PHP, which allows you to set the permissions of a file or directory. For example, to set the permissions of a file to '755', the following code could be used:\n\n$file = '/path/to/file.txt';\nchmod($file, 0755);",
      "semgrep_rule": "rule = {\n    id: \"cwe-276-incorrect-default-permissions\",\n    pattern: \"chmod($file, $mode) and $mode != 0600 and $mode != 0400\",\n    message: \"File permissions should not be set to 0600 or 0400 by default.\",\n    severity: \"warning\"\n}",
      "codeql_rule": "import php\n\nclass IncorrectDefaultPermissions implements Rule {\n  // Query to detect incorrect file/directory permissions\n  // that allow unauthorized access\n  //\n  // Finds all calls to chmod, chown, and chgrp\n  // that are used to set incorrect default permissions\n  // on files/directories\n  //\n  // @return  true if the call is setting incorrect permissions\n  //          false otherwise\n  private predicate isIncorrectPermissions(Expr callee, Expr fileName) {\n    exists(FuncCall call |\n      call.getCallee() = callee and\n      call.getArgument(0) = fileName and\n      call.getArgumentCount() > 1 and\n      (call.getArgument(1).isLiteral() and\n        call.getArgument(1).asLiteral().asInteger()"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that occurs when sensitive information is exposed to an actor that is not authorized to view or access it. This can occur through a variety of ways, such as an insecure configuration of a web application that allows unauthorized access to confidential data, or an application that does not properly sanitize user input. Sensitive information can include passwords, financial data, and other personally identifiable information. This vulnerability can have serious consequences for the organization and individuals affected, as their confidential data can be used for malicious purposes.",
      "vulnerable_code": "<?php\n$password = $_POST['password'];\necho \"Your password is \" . $password;\n?>\n\nIn this code example, the user-provided password is echoed out in plaintext. This exposes sensitive information to an unauthorized actor and is therefore vulnerable to the CWE-200 vulnerability.",
      "remediation": "The remediation for this vulnerability is to ensure that sensitive information is encrypted and stored securely. This could be done by implementing a secure encryption algorithm and storing the encrypted data in a secure database. Additionally, access to sensitive information should be limited and monitored, and access should only be granted to authorized actors. Finally, users should be provided with adequate training on how to protect sensitive information.",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detecting CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\"\n        id = \"CWE-200\"\n        severity = \"high\"\n    strings:\n        $sensitive_info = /password|credit card/\n    condition:\n        $sensitive_info\n}",
      "codeql_rule": "import cwe\n\nclass CWE200Vuln : Vuln {\n  // Rule to detect exposure of sensitive information\n  // to an unauthorized actor\n  when CWE.VulnerableFunctionCall(name:\"sensitive_function\", parameters:params, vulnerableParameter:vulnerableParam) \n  and CWE.UnauthorizedActor(actor:unauthorizedActor, vulnerableParameter:vulnerableParam)\n  then \n    report(\"Sensitive information is being exposed to an unauthorized actor at \" + \n           sourceLocation.toString())\n}"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a vulnerability that occurs when a web application or service stores sensitive credentials in plaintext or using an easily reversible encryption method. This makes it easy for an attacker to gain access to the credentials, often without the need for authentication or authorization. This can allow an attacker to access sensitive data or take control of the system.",
      "vulnerable_code": "// This code stores an unencrypted password in the database\n$password = $_POST['password'];\n$sql = \"INSERT INTO users (password) VALUES ('$password')\";\nmysql_query($sql);",
      "remediation": "Remediation for this vulnerability would be to ensure that all credentials are stored in an encrypted format, and that access to those credentials is restricted to only the most trusted users. Additionally, any stored passwords should use a strong hash algorithm with a unique salt value. Additionally, regularly audit and rotate the credentials to ensure they are not exposed and are up-to-date.",
      "semgrep_rule": "rule = {\n    meta:\n      id = \"CWE-522\"\n      desc = \"Detects insufficiently protected credentials\"\n      author = \"SecureCodeBox\"\n      reference = \"https://cwe.mitre.org/data/definitions/522.html\"\n    strings:\n       $cred_1 = \"username\"\n       $cred_2 = \"password\"\n       $cred_3 = \"access_token\"\n    condition:\n       any of ($cred_*) and not in_file(\"*.php\")\n}",
      "codeql_rule": "import cwe522\n\nclass InsufficientlyProtectedCredentials : CodeQL.Vulnerability {\n \n  // Finds any calls to functions that store credentials\n  // without sufficient protection\n  private predicate isStoringCredentials(Call c) {\n    exists(Function f,\n      c.getTarget() == f and\n      f.hasAnnotation(\"cwe522\")\n    )\n  }\n \n  // Finds any calls to functions that store credentials\n  // without sufficient protection\n  private predicate isStoringCredentials() {\n    exists(Call c, isStoringCredentials(c))\n  }\n \n  // Finds any calls to functions that store credentials\n  // without sufficient protection\n  private predicate isRetrievingCredentials(Call c) {\n    exists (Function f,\n      c.getTarget() == f and\n      f"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability that occurs when an application parses XML input and allows XML external entity references. This vulnerability allows an attacker to reference external resources, such as files or network services, within the XML document which can lead to information leakage, denial of service and potential remote code execution. This vulnerability can be especially dangerous if the application is not configured to use a secure XML parser that blocks all external entities.",
      "vulnerable_code": "<?php \n    $xml = simplexml_load_file(\"http://example.com/data.xml\");\n    $name = $xml->name;\n?>\n\nThe code above is vulnerable to CWE-611 because it does not properly restrict the XML external entity reference. If the data.xml file contains a malicious entity reference, it could potentially lead to server-side request forgery or other malicious behavior.",
      "remediation": "Remediation for CWE-611: Improper Restriction of XML External Entity Reference can be achieved by disabling external entity references in an XML processor. This can be done by setting the \"disable-external-entities\" option. In PHP, this can be done using the libxml_disable_entity_loader function, which disables the loading of external entities.\n\nExample: \n\nlibxml_disable_entity_loader(true);",
      "semgrep_rule": "rule = {\n    id: \"CWE-611-detection\",\n    patterns: [\n        {\n            pattern: \"libxml_set_external_entity_loader($_);\",\n            message: \"Improper Restriction of XML External Entity Reference detected\",\n            languages: [\"php\"],\n            severity: \"CRITICAL\"\n        }\n    ]\n}",
      "codeql_rule": "import cwe\nimport php\n\nclass VulnerableXMLExternalEntityRef extends Query {\n  // Finds any XML files that allow external entity references\n  @FileName(\"*.xml\")\n  file\n  \n  // Finds any PHP files that parse XML\n  @FileName(\"*.php\")\n  phpFile\n  \n  // Finds any calls to the PHP SimpleXML parser\n  SimpleXMLParser = php.function(\"SimpleXMLElement::__construct\")\n  \n  // Finds any calls to the PHP DOM parser\n  DOMParser = php.function(\"DOMDocument::loadXML\")\n  \n  // Finds any calls to the PHP XMLReader parser\n  XMLReaderParser = php.function(\"XMLReader::open\")\n  \n  // Finds any calls to the PHP XML parser\n  XMLParser = php.function(\"xml_parser_create\")"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-Side Request Forgery (SSRF) is a type of vulnerability in which a malicious actor is able to manipulate an application to make a request to any server or service that is accessible from the vulnerable application. This allows an attacker to access and manipulate internal resources, such as databases or file systems, that may not normally be accessible. Additionally, attackers may be able to access sensitive data such as passwords or other private information stored on the internal server. In some cases, attackers may even be able to execute arbitrary code on the internal server.",
      "vulnerable_code": "$url = $_GET['url'];\n$response = file_get_contents($url);\necho $response;",
      "remediation": "Remediating a Server-Side Request Forgery (SSRF) vulnerability in PHP involves validating user-supplied input to make sure it is not maliciously crafted to send a request to an external domain. This can be done by using a blacklist of domains to restrict requests to a specific set of approved domains.\n\nFor example, the following code validates user-supplied input to make sure it only sends requests to an approved list of domains:\n\n$url = $_GET['url'];\n$approved_domains = array('example.com', 'example2.com');\n\nif (in_array(parse_url($url, PHP_URL_HOST), $approved_domains)) {\n    // Send request\n} else {\n    // Error message\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-918-SSRF-detection\",\n  patterns: [\n    {\n      pattern: \"preg_match($_SERVER['HTTP_HOST'], $url)\",\n      message: \"Potential Server-Side Request Forgery (SSRF) issue detected\",\n      severity: \"warning\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe\nimport php\n\nclass ServerSideRequestForgeryVulnerability extends Rule {\n  // Identify the vulnerable code\n  Query vulnerableCode = \n    // Find a call to a function that can be used to issue an HTTP request\n    MethodCall.find(\n      \"curl_*\", \n      \"file_get_contents\", \n      \"fopen\"\n    )\n    // Ensure that the call is not whitelisted\n    .not(\n      MethodCall.withReceiver(\n        // List of whitelisted functions\n        Function.find(\"parse_url\", \"filter_var\", \"parse_str\")\n    ));\n\n  // Identify the vulnerable function parameters\n  Query vulnerableParams = \n    // Find any parameters to the vulnerable functions\n    vulnerableCode.params();\n\n  // Identify the risk of SSRF\n  Query potentialRisk ="
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of vulnerability where an attacker is able to inject arbitrary commands into a system. This type of attack occurs when user input is not properly sanitized and is used as part of a system command. This can be exploited to execute malicious code on the victim's system.",
      "vulnerable_code": "$userInput = $_GET['command'];\nexec($userInput);\n\nThis code is vulnerable to command injection as it takes user input which is then executed as a system command without any validation or filtering. An attacker could inject malicious commands which would be executed by the system.",
      "remediation": "// Before\n$userInput = $_GET['command'];\nsystem($userInput);\n\n// After\n$userInput = escapeshellcmd($_GET['command']);\nsystem($userInput);",
      "semgrep_rule": "rule = {\n        id: \"CWE-077-detection\",\n        pattern: \"$VAR:string <= `.*`\",\n        message: \"Possible Command Injection detected\",\n        level: \"CRITICAL\"\n}",
      "codeql_rule": "import cwe077\n\nclass CWE077_Command_Injection extends SecurityCodeScanRule {\n  CWE077_Command_Injection() {\n    super.description = \"Command injection vulnerability\";\n  }\n\n  // Find all assignment expressions\n  @Assignment\n  def assignmentExpr(expr) {\n    // Find all assignments of user input\n    expr.lhs.isUserInput()\n  }\n\n  // Find all function calls\n  @Call\n  def functionCall(call) {\n    // Find all function calls with user input in the arguments\n    call.hasArgumentUserInput()\n  }\n\n  // Warn when user input is used in a command or system call\n  @Report\n  def report(expr, call):\n    expr.isCWE077 || call.isCWE077\n}"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "Improper certificate validation is a vulnerability in which the application does not properly validate SSL/TLS certificates provided by a remote server. This allows attackers to spoof the server\u2019s identity and gain access to sensitive data, or hijack the connection and inject malicious content. This vulnerability can occur if the application does not properly validate the certificate against the server\u2019s expected certificate, or if the application does not check for any revoked certificates.",
      "vulnerable_code": "<?php\n$url = \"https://example.com/\";\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);\ncurl_setopt($ch, CURLOPT_URL, $url);\n$result = curl_exec($ch);\ncurl_close($ch);\n\n?>\n\nThe code above is vulnerable to CWE-295, Improper Certificate Validation, because the CURLOPT_SSL_VERIFYPEER option is set to false, which means that the SSL certificate for the server at example.com is not being validated. This leaves the connection open to man-in-the-middle attacks.",
      "remediation": "// Check the validity of a certificate\n$certificate = file_get_contents(\"certificate.crt\");\n$data = openssl_x509_read($certificate);\nif (!$data) {\n    throw new Exception('Invalid certificate');\n}\n\n// Validate the certificate against a known Certificate Authority\n$ca_certificate = file_get_contents(\"ca_certificate.crt\");\n$ca_data = openssl_x509_read($ca_certificate);\n\n$valid = openssl_x509_checkpurpose($data, X509_PURPOSE_ANY, array($ca_data));\nif (!$valid) {\n    throw new Exception('Certificate not issued by a valid Certificate Authority');\n}",
      "semgrep_rule": "rules:\n  - id: CWE-295\n    severity: warning\n    message: \"Improper Certificate Validation\"\n    patterns:\n      - pattern: |\n          $certificate = <<<EOD\n            ...\n          EOD\n        filters:\n          - not:\n              pattern: \"verify_peer\"\n              files:\n                - \"*.php\"",
      "codeql_rule": "import cwe\n\nclass ImproperCertificateValidationRule extends Rule {\n  // Rule metadata\n  meta = {\n    id = \"CWE-295: Improper Certificate Validation\",\n    author = \"MyCompany Security Team\",\n    description = \"Detected checking of certificates without verifying the identity of the remote server.\"\n    status = \"experimental\"\n  }\n\n  // Query to detect the vulnerability\n  query verifiesCertificateIdentity(){\n    // Query for functions that check for the certificate\n    CertificateCheckFunction = FunctionCall[\n      callee.name in [\"curl_exec\", \"openssl_verify\", \"preg_match\"]\n    ] \n\n    // Query for functions that don't verify the identity of the remote server\n    NonVerifiedCertificateCheckFunction = CertificateCheckFunction \n    and not FunctionCall[\n      callee.name in [\"openssl_"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability, which occurs when user input is not properly sanitized and is used to generate code or commands. This allows attackers to inject malicious code into a system, which can be used to gain unauthorized access, execute malicious functions, or compromise system security. It is a serious vulnerability as it can be used to gain access to sensitive data, execute malicious functions, or even modify system configurations.",
      "vulnerable_code": "<?php\n    $user_input = $_GET['input'];\n    eval($user_input);\n?>\n\nThis code is vulnerable to code injection attacks, as it takes user input and evaluates it as PHP code, without any kind of input validation or sanitization. This could allow an attacker to execute arbitrary code on the server.",
      "remediation": "A possible remediation for CWE-094 would be to use parameterized queries to prevent malicious input from being executed as code. This means that any user-contributed data is treated as a literal value and not as executable code. To do this in PHP, we can use the PDO library and its prepare() and execute() methods.\n\nExample:\n\n$sql = \"SELECT * FROM users WHERE username = :username AND password = :password\";\n\n$stmt = $pdo->prepare($sql);\n$stmt->execute(array(':username' => $username, ':password' => $password));\n\nThis code ensures that the data being passed into the query is treated as a literal value and not as executable code, thus mitigating the risk of code injection.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects code injection vulnerability\"\n    id = \"CWE-094\"\n    severity = \"CRITICAL\"\n  strings:\n    $user_input = /.*/\n  condition:\n    $user_input in any_function_call\n}",
      "codeql_rule": "import cwe094\n\nclass CodeInjectionVulnerability implements Vulnerability {\n  // Define any helper functions you need here\n \n  // The following method is called once for each source file\n  // in the repository\n  predicate isVulnerable(CWE094:CodeInjection vuln) {\n    // Check if the file contains vulnerable code\n    exists(Method m | vuln.getMethod() = m)\n  }\n}"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269: Improper Privilege Management is a vulnerability that occurs when an application fails to properly manage the privileges of users. This can be done by providing users with unnecessary privileges, not properly enforcing access control, or not properly separating privileged users from non-privileged ones. This vulnerability can lead to privilege escalation, where a user can perform actions not intended for them, as well as unauthorized access to sensitive data. In PHP, this vulnerability can be caused by improper authentication and authorization mechanisms, insecure configuration settings, or the use of insecure functions.",
      "vulnerable_code": "// Create a user with administrative privileges\n$username = $_POST['username'];\n$password = $_POST['password'];\n$isAdmin = (isset($_POST['isAdmin'])) ? true : false;\n\n// Create a new user\n$user = new User($username, $password);\n\n// Grant admin privileges if isAdmin is set\nif($isAdmin) {\n    $user->grantAdminPrivileges();\n}",
      "remediation": "In order to remediate this vulnerability, developers should establish a comprehensive system of privilege management. This includes setting up a system of roles and privileges, assigning privileges to specific users, and setting up access control mechanisms to ensure that only authorized users are granted access to certain resources. Additionally, developers should limit privileges to only the minimum required in order to perform a given task. They should also regularly audit and review privilege levels to ensure that users do not have excessive privileges that could be exploited.",
      "semgrep_rule": "rule = {\n  id: \"CWE-269-Improper-Privilege-Management\",\n  patterns: [\n    {\n      pattern: \"preg_match($pattern, $subject, $matches, $flags % 0)\",\n      message: \"Improper privilege management detected. Please ensure that the flags argument for preg_match() is being properly set.\",\n      severity: \"WARNING\",\n    },\n  ],\n  meta: {\n    author: \"Semgrep Team\",\n    description: \"This rule detects improper privilege management in PHP code.\",\n    references: \"https://cwe.mitre.org/data/definitions/269.html\",\n  },\n}",
      "codeql_rule": "import cwe269\n\nclass CWE269ImproperPrivilegeManagement extends Rule {\n  // ...\n\n  // Finds code that assigns privileges to a user\n  // without properly validating the user's credentials\n  // or identity.\n  @Checks({Check.CWE_269})\n  getCallsToAssignPrivileges() {\n    // Find calls to functions that assign privileges\n    // to a user, such as granting user access to a database.\n    return MethodCall.find(\"{ assignPrivileges(...) }\");\n  }\n\n  // Finds code that grants privileges to a user\n  // without properly validating the user's credentials\n  // or identity.\n  @Checks({Check.CWE_269})\n  getCallsToGrantPrivileges() {\n    // Find calls to functions that grant privileges\n    // to a user, such as granting user"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is an expression language injection vulnerability. An expression language injection vulnerability occurs when user input is not properly neutralized before being used as part of an expression language statement. This can allow an attacker to inject malicious code into a web application, which can then be executed by the web application. In some cases, this malicious code can allow an attacker to gain access to sensitive information or execute arbitrary code.",
      "vulnerable_code": "// vulnerable code\n$query = \"SELECT * FROM users WHERE id = {$_GET['user_id']}\";\n$result = mysqli_query($conn, $query); \n\n// Exploiting the vulnerability\n$_GET['user_id'] = \"1 OR 1=1\";\n$query = \"SELECT * FROM users WHERE id = {$_GET['user_id']}\";\n$result = mysqli_query($conn, $query); \n\n// Resulting query\nSELECT * FROM users WHERE id = 1 OR 1=1;",
      "remediation": "Use the PHP htmlspecialchars() function to escape any user-supplied data before using it in an expression language statement. \n\nFor example:\n\n$name = htmlspecialchars($_POST['name']);\n$expression = \"$name == 'admin'\";\n\nThis will ensure that the expression language statement is safe to use, as the user-supplied data has been escaped and is no longer able to execute malicious code.",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tdescription = \"Detects improper neutralization of special elements in an Expression Language statement\"\n\t\tauthor = \"Your Name\"\n\t\tdate = \"2020/02/13\"\n\t\treference = \"https://cwe.mitre.org/data/definitions/917.html\"\n\t\towasp = \"A4:2017-Insecure Direct Object References\"\n\t\ttags = [\"cwe-917\", \"expression-language-injection\"]\n\t\t\n\tsource:\n\t\tlanguages = [\"php\"]\n\t\t\n\t\t\n\tconstant:\n\t\tspecial_characters = [\"$\", \"{\"]\n\n\tpattern:\n\t\texpr_injection = special_characters in \".*\"\n\t\t\n\t\t\n\tdef vulnerability:\n\t\texpr_injection\n\t\t\n}",
      "codeql_rule": "import cwe\n\nclass ExpressionLanguageInjectionDetector extends Rule {\n  // ...\n \n  // Create a query to detect special elements being used in an expression language statement\n  query expressionLanguageInjection() {\n    // Find expression language statements\n    ExpressionLanguageStatement stmts as ExpressionLanguageStatement[] = \n      find ExpressionLanguageStatement[_]\n    \n    // Check for special elements in the statements\n    stmts.filter(stmt | \n      exists(ExpressionLanguageSpecialElement elem | \n        elem.parent == stmt)\n    )\n  }\n\n  // ...\n \n  // Create a query to detect improper neutralization of special elements\n  query improperNeutralization() {\n    // Find expression language statements\n    ExpressionLanguageStatement stmts as ExpressionLanguageStatement[] = \n      find ExpressionLanguageStatement[_]\n    \n    // Check for special elements"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability related to improper link resolution before file access, also known as 'Link Following'. This type of vulnerability occurs when a program follows a link or pathname without checking to see that the file or directory actually exists. This can lead to an attacker being able to access files or directories that they shouldn't have access to. A successful attack may allow an attacker to access sensitive information or execute malicious code on the system. It is important to properly validate any links or pathnames before following them, in order to prevent this type of attack.",
      "vulnerable_code": "$file_name = $_GET['file'];\n$file_path = '/var/www/files/' . $file_name;\nif (file_exists($file_path)) {\n    include($file_path);\n}\n\nThis code is vulnerable to CWE-059 because it does not properly validate the value of $file_name before attempting to include it. If an attacker is able to modify the value of the 'file' parameter, they can include any file on the server, regardless of its location. This is an example of improper link resolution before file access.",
      "remediation": "The following code uses the realpath() function to ensure that the requested file is within the given directory before attempting to access it:\n\n<?php\n// Get the requested file path\n$filePath = $_GET['file'];\n\n// Resolve the real path\n$realPath = realpath($filePath);\n\n// Check if the requested file is within the given directory\n$baseDir = '/var/www/files';\nif (strpos($realPath, $baseDir) === 0) {\n    // Read the file\n    $fileContents = file_get_contents($realPath);\n    // Do something with the file\n}\n?>",
      "semgrep_rule": "rule = {\n  pattern = \"{left:$file, right:$path}\",\n  message = \"Improper Link Resolution Before File Access detected.\",\n  severity = \"CRITICAL\"\n}",
      "codeql_rule": "import cwe059\n\nclass CWE059LinkFollowing extends Rule {\n  // Initialize the rule\n  CWE059LinkFollowing() {\n    super.name = \"CWE-059: Link Following\"\n    super.description = \"Detects improper link resolution before file access\"\n  }\n\n  // Match the call expression\n  // Look for the vulnerable code pattern\n  @Override\n  QueryPair getQuery() {\n    // Match the call expression\n    Expression accessExpression = \n      CallExpr.all(to: Method(\"java.io.File: java.io.File#<init>(java.lang.String)\"))\n    \n    // Look for the vulnerable code pattern\n    Query vulnerablePattern = \n      accessExpression.withAncestor(\n        VariableExpr.withName(\"fileName\"),\n        AnyOf(\n          AssignmentExpr.of(Variable"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a type of security vulnerability that occurs when sensitive information is transmitted over a network in plain text or unencrypted form. This means that anyone on the same network could potentially intercept or access the data being transmitted, leaving it vulnerable to theft or misuse. This type of vulnerability is especially dangerous when it involves the transmission of passwords, credit card numbers, or other sensitive information, as it could lead to identity theft or financial fraud.",
      "vulnerable_code": "$url = 'http://example.com/api/';\n$data = array('username' => 'user', 'password' => 'password');\n\n// Create the context for the request\n$context = stream_context_create(array(\n    'http' => array(\n        'method' => 'POST',\n        'header' => \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n        'content' => http_build_query($data)\n    )\n));\n\n// Send the request\n$response = file_get_contents($url, FALSE, $context);\n\n// Check for errors\nif($response === FALSE){\n    die('Error');\n}\n\n// Print the response\necho $response;\n\nThis code is vulnerable to CWE-319, since it is transmitting sensitive information in cleartext (HTTP) instead",
      "remediation": "// Before\n$url = 'http://example.com/login.php';\n\n// After\n$url = 'https://example.com/login.php';",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects CWE-319: Cleartext Transmission of Sensitive Information\"\n    author = \"john_doe\"\n    date = \"2020-09-13\"\n    version = \"1.0\"\n  strings:\n    $text = \"password\"\n  condition:\n    $text and not regex(r\"^[A-Za-z0-9]+$\")\n}",
      "codeql_rule": "import php\n\nclass CWE319CleartextTransmissionOfSensitiveInformationRule extends Rule {\n  // Query for finding cleartext transmissions of sensitive information\n  Query cleartextTransmissionQuery {\n    // Find all functions that handle sensitive information\n    Function func\n    where isSensitiveFunction(func)\n    \n    // Find all statements that transmit the sensitive information without encrypting it\n    Statement transmission\n    where\n    transmission.getEnclosingFunction() = func\n    and exists(TryStatement t | t.getBody() = transmission and isClearTextTransmission(t))\n  }\n  \n  // Override the method to return the query for this rule\n  override predicate getEvaluationPredicate() {\n    cleartextTransmissionQuery\n  }\n  \n  // Helper function to detect functions that handle sensitive information\n  predicate isSensitiveFunction(Function f) {"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601, or URL Redirection to Untrusted Site ('Open Redirect'), is a vulnerability that occurs when an application redirects a user to an external URL without validating or verifying the destination. This can be exploited by an attacker to redirect a user to a malicious website, allowing the attacker to gain access to sensitive information or perform malicious actions. If a vulnerable URL is accessed, attackers can craft a URL with a malicious destination and redirect a user to that malicious site.",
      "vulnerable_code": "<?php\n$redirect_url = $_GET['url'];\nheader('Location: ' . $redirect_url);\n?>\n\nThe code above allows an attacker to send a malicious URL as a GET request parameter, which is then used in the redirect. This can be used to redirect the user to a malicious website.",
      "remediation": "// Before\nheader(\"Location: $url\");\n\n// After\n$url = filter_var($url, FILTER_VALIDATE_URL);\nif ($url) {\n   header(\"Location: $url\");\n} else {\n   exit;\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-601-open-redirect\",\n  pattern: \"preg_replace($_SERVER['HTTP_HOST'], $vulnerable_url, $_SERVER['QUERY_STRING'])\",\n  message: \"preg_replace() is used to redirect to an untrusted URL. This may lead to open redirect vulnerability.\",\n  severity: \"WARNING\"\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass OpenRedirect extends TaintTracking::TrackingDomain {\n  OpenRedirect() {\n    super(\"OpenRedirect\")\n  }\n}\n\nclass UrlRedirect extends cwe::WeaknessType {\n  UrlRedirect() {\n    super(\"CWE-601\")\n  }\n  \n  override predicate isTracked(DataFlow::Node source) {\n    source.getAnAccess().hasOrigin(UrlOrigin)\n  }\n  \n  override predicate isVulnerable(DataFlow::Node sink, DataFlow::Node source) {\n    exists(AccessPath sourcePath,\n      source.asExpr() |\n      source.asAccessPath() => sourcePath \n    ) \n    &&\n    exists(AccessPath sinkPath,\n      sink."
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability where sensitive information is inserted into a log file. This can happen if the logging system is not configured correctly, and sensitive information is written to the log file without first being sanitized. This can allow an attacker to gain access to confidential information, such as passwords, financial data, or other sensitive information. It can also allow an attacker to gain access to the system by leveraging the information in the log file.",
      "vulnerable_code": "<?php\n$userInput = $_POST[\"input\"];\n\n// Log user input\nerror_log($userInput);\n\n?>",
      "remediation": "The remediation for this vulnerability is to ensure that any sensitive information is not added to log files. This can be done by using a logging library such as Monolog to filter out any sensitive information before it is written to the log file.\n\nThe following is an example of this remediation in PHP:\n\n<?php\n\nuse Monolog\\Logger;\nuse Monolog\\Handler\\StreamHandler;\n\n$logger = new Logger('myLogger');\n$logger->pushHandler(new StreamHandler('./logs/mylog.log', Logger::WARNING));\n\n// Add the sensitive information to a variable\n$sensitiveInfo = '123456';\n\n// Filter the sensitive information from the log\n$logger->addFilter(function ($record) use ($sensitiveInfo) {\n    if ($record['message'] === $sensitiveInfo) {\n        return false;\n    }\n\n    return",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects insertion of sensitive information into log files\"\n        author = \"Author name\"\n    strings:\n        $sensitive_info = /(password|username|token|key)/\n    condition:\n        any of ($sensitive_info) in log\n}",
      "codeql_rule": "import php\n\nclass SensitiveLogInsertion extends SecurityAudit.Check {\n  // Checks for the insertion of sensitive info into log files\n  // by searching for calls to PHP functions that write to log files\n  // such as error_log and log_error\n \n  // Allowed functions\n  // @var string[]\n  let allowed_functions = [\"error_log\", \"log_error\"]\n  \n  // Sensitive functions\n  // @var string[]\n  let sensitive_functions = [\"get_password\", \"get_secret\", \"get_token\"]\n  \n  // Main query\n  // @return Query\n  @Override\n  predicate audit() {\n    // Find calls to log functions\n    Expr log_functionCall = \n      CallExpr.forMethodName(allowed_functions);\n    \n    // Find calls to sensitive functions\n    Expr"
    }
  },
  "Rust": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of vulnerability that allows an attacker to inject malicious code into a web page through user input. This code is then executed in the user\u2019s browser, potentially allowing the attacker to access information and resources that the user may have access to. In Rust, this vulnerability can occur when user input is not properly sanitized before being generated into a web page. If the input is not correctly filtered, malicious code can be injected into the page, allowing an attacker to gain access to the user\u2019s resources.",
      "vulnerable_code": "```rust\nlet input_str = req.param(\"name\").unwrap_or(\"Guest\");\n\nlet output_str = format!(\"<h1>Welcome, {}!</h1>\", input_str);\n\nresp.send(output_str);\n```\n\nThis code is vulnerable to Cross-site Scripting as it does not properly sanitize the input before using it in the generated HTML. An attacker could provide a malicious input, such as `<script>alert('XSS')</script>`, which would cause arbitrary JavaScript to be executed when the page is loaded.\n\nTo prevent this, the code should sanitize the user input using a library such as the `html-escape` crate.\n\n```rust\nlet input_str = req.param(\"name\").unwrap_or(\"Guest\");\n\nlet output_str = format!(\"<h1>Welcome, {}",
      "remediation": "Solution:\n\nBy using Rust's built-in HTML escaping functions, such as html::escape, it is possible to neutralize any malicious input before it is used to generate a web page. This can be achieved by calling the html::escape function on any user input before using it to generate a web page.\n\nFor example, consider the following code that takes input from a user and generates a web page with it:\n\nlet input = get_user_input();\nlet page_content = format!(\"<h1>{}</h1>\", input);\n\nThis code is vulnerable to cross-site scripting attacks. To remediate this issue, the html::escape function should be used to neutralize any malicious input before it is used to generate the web page:\n\nlet input = get_user_input();\nlet escaped_input = html::escape(input);\nlet page_content = format!(\"<h1",
      "semgrep_rule": "rule = {\n\tstrings: $input = /(<script\\s+[^>]*>|<\\/script>)/\n\tcondition: $input\n}",
      "codeql_rule": "import cwe079\n\nclass CWE079Rule extends Rule {\n    // Rule body\n    // Query body\n    // Helper functions\n    \n    getQuery(){\n        return \n            // Query to detect potential XSS vulnerability\n            CWE079.query\n    }\n    \n    // Helper function to detect user-supplied data being used as part of an HTML page\n    detectPotentialXSSVulnerability(Class htmlClass){\n        //TODO\n    }\n    \n    // Helper function to detect user-supplied data being used for a URL redirect\n    detectPotentialURLRedirectVulnerability(Class urlClass){\n        //TODO\n    }\n    \n    // Helper function to detect user-supplied data being used for a cookie value\n    detectPotentialCookieVulnerability(Class cookieClass){\n        //TODO"
    },
    "CWE-020: Improper Input Validation": {
      "description": "CWE-020, also known as Improper Input Validation, is a vulnerability in which a program does not properly validate user input, allowing attackers to supply malicious inputs that could lead to a variety of issues, such as buffer overflows, SQL injections, and command execution. In Rust, improper input validation is often caused by using functions such as `str::from_utf8`, `str::from_utf16`, `str::from_utf32` without validating the input beforehand, which can lead to a buffer overflow.",
      "vulnerable_code": "fn main() {\n    let mut input = String::new();\n    println!(\"Please enter your username:\");\n    std::io::stdin().read_line(&mut input).expect(\"Failed to read line\");\n\n    // Vulnerable code below\n    let username = input.trim();\n    println!(\"Welcome, {}!\", username);\n}\n\nThe code is vulnerable because the input is not properly validated. It can be used to inject malicious code into the program.",
      "remediation": "Example code before remediation:\n\nfn get_user_input() -> String {\n    let user_input = stdin().read_line().expect(\"Error reading input\");\n    return user_input;\n}\n\nExample code after remediation:\n\nfn get_user_input() -> String {\n    let user_input = stdin().read_line().expect(\"Error reading input\");\n    let sanitized_input = user_input.trim().to_string(); // Add input validation\n    return sanitized_input;\n}",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detect Improper Input Validation\"\n        id = \"CWE-020\"\n    strings:\n        $input_var = /.*/\n    condition:\n        all of them\n}\n\n@rulerange[start]\n// Check for input validation specific functions\n$input_var = /.*/\n&& (\n    // Check for input sanitization\n    /sanitize_input\\(.*?$input_var.*?\\)/\n    || /validate_input\\(.*?$input_var.*?\\)/\n    || /escape_input\\(.*?$input_var.*?\\)/\n    || /filter_input\\(.*?$input_var.*?\\)/\n\n    // Check for input validation\n    || /validate_length\\(.*?$input_var.*?\\)/",
      "codeql_rule": "import cwe020\n\nclass CWE020_Vulnerability_Detector extends Query {\n  // Finds functions that do not validate user input\n  predicate isVulnerableFunction(func f) {\n    exists(Stmt s, Expr e | \n      f.hasStmt(s) and s.hasExpr(e) and cwe020.isVulnerable(e)\n    )\n  }\n  \n  query vulnerableFunctions() {\n    find isVulnerableFunction(_)\n  }\n}"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078 is a type of injection attack that occurs when an attacker is able to inject malicious code or commands into an operating system. This can be done by exploiting weaknesses in input validation and sanitization processes, or by exploiting other vulnerabilities such as insecure file permissions. When successful, the attacker can gain access to or modify files on the target system, or execute malicious code with elevated privileges. In Rust specifically, this vulnerability can be caused by unsafe code or functions such as exec, system, or popen that can be used to execute external commands. To prevent this vulnerability, input validation should be performed on all user-supplied data and any external calls should be properly sanitized.",
      "vulnerable_code": "fn execute_command(command: &str) {\n    let output = std::process::Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(command)\n        .output()\n        .expect(\"failed to execute command\");\n    println!(\"status: {}\", output.status);\n    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n}\n\n// This code is vulnerable to OS Command Injection because the `command` parameter is not sanitized before being passed to the shell. An attacker could inject malicious commands by passing them as part of the `command` parameter.",
      "remediation": "The best way to prevent command injection attacks is to properly validate and sanitize user input. In Rust, this can be achieved by using the static analysis tool cargo-audit, which can detect and alert developers to unsafe usage of user input.\n\nAdditionally, developers should use the standard process::Command API to safely execute external commands. This API provides a safe wrapper around the underlying system command, allowing developers to safely pass user input to external commands. The API also provides a safe way to capture the output of the command and handle it as needed.",
      "semgrep_rule": "rule = {\n    strings:\n        $cmd = /.*/\n    condition:\n        $cmd\n}",
      "codeql_rule": "import cwe_078\nimport semmle.code.cpp.dataflow::DataFlow\n\nclass OsCommandInjection extends Cwe_078\n{\n\t// Entry point for the rule\n\tpredicate vulnerable(DataFlow::Node src)\n\t{\n\t\t// Checks if the source node is an OS command\n\t\tsrc.hasStringLiteral() and\n\t\t\t// Checks if the command is not properly escaped\n\t\t\tnot src.sanitized()\n\t}\n}"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') is a vulnerability that occurs when user-supplied input is not properly sanitized before being used as part of an SQL query. This can allow an attacker to inject malicious SQL code into a query, giving them the ability to access, modify, or delete data from the underlying database.",
      "vulnerable_code": "fn fetch_data_from_database(username: &str) -> String {\n    let query_string = format!(\"SELECT * FROM users WHERE username='{}'\", username); \n    let result = db.query(&query_string); \n    return result; \n}\n\nThis code is vulnerable to SQL injection attacks because it does not properly neutralize user-supplied input before inserting it into the SQL query string. An attacker could exploit this by supplying malicious input to the username parameter that would cause the database to execute unintended commands.",
      "remediation": "The remediation for this vulnerability is to use parameterized queries instead of plaintext SQL queries. This can be done by using a database library that supports parameterized queries, such as the Rusqlite library. \n\nFor example, instead of writing:\n\nlet query = \"SELECT * FROM users WHERE username = '$username'\";\n\nWrite:\n\nlet query = \"SELECT * FROM users WHERE username = ?\";\nlet username = \"admin\";\nlet params = &[username];\nlet result = conn.query_row(query, params, |row| {\n    // Do something with the row\n});",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects potential SQL injection vulnerabilities\"\n        severity = \"WARNING\"\n    strings:\n        $sql_injection = \"SELECT * FROM\"\n    condition:\n        $sql_injection at 0\n}",
      "codeql_rule": "import cwe089\n\nclass VulnerableSQLQuery:\n    // Checks for the presence of an SQL query\n    // with potential injection vulnerabilities\n    // using the cwe089.SqlQuery pattern.\n    // The pattern matches a query string,\n    // and its parameters.\n    vulnerabilityPattern = cwe089.SqlQuery\n\n    // Checks if any of the parameters passed to the query\n    // can be used to inject malicious content.\n    // The query must be of type Select or Insert.\n    // The parameter must be of type Literal.\n    // The parameter must be placed within the query string.\n    @Filter(VulnerableSQLQuery.vulnerabilityPattern)\n    def vulnerableQuery(query: Query, param: Parameter):\n        query.kind == QueryKind.Select or\n        query.kind == QueryKind.Insert and\n        param.kind == ParameterKind.Lit"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal is a type of vulnerability that occurs when an application or system allows an attacker to access files and directories outside of the intended directory. This type of vulnerability can allow an attacker to view, modify, or delete files, as well as gain access to the system. It can also be used to gain access to sensitive data and other system resources. Path traversal vulnerabilities can be caused by improper input validation, insecure system configurations, and other security flaws. To prevent this vulnerability in Rust, developers should use the Path::canonicalize() and Path::strip_prefix() functions to ensure that paths are limited to the intended directory. Additionally, developers should ensure that input validation is in place to reject any malicious input that may lead to a path traversal attack.",
      "vulnerable_code": "fn read_file(path: &str) -> Result<String, std::io::Error> {\n    let mut buffer = String::new();\n    let mut file = std::fs::File::open(path)?;\n    file.read_to_string(&mut buffer)?;\n    Ok(buffer)\n}\n\n// The vulnerability occurs when the path argument is not properly validated before passing it to the File::open() function.\n// An attacker could inject \"../../../etc/passwd\" as the path argument to read the contents of the system's password file.\n\nfn read_file(path: &str) -> Result<String, std::io::Error> {\n    // Validate the path argument\n    if !path.starts_with(\"/safe/\") {\n        return Err(std::io::Error::new(std::io::ErrorKind::PermissionDenied",
      "remediation": "// Before\nlet filename = fs::canonicalize(req.query(\"file\")).expect(\"Error resolving filename\");\n\n// After\nlet filename = fs::canonicalize(req.query(\"file\"))\n    .expect(\"Error resolving filename\")\n    .strip_prefix(\"/restricted/directory\")\n    .expect(\"Error: File outside of restricted directory\");",
      "semgrep_rule": "rule = {\n    meta:\n        severity = \"medium\"\n        description = \"Detects potential Path Traversal vulnerability\"\n    strings:\n        $file_op_call = /\\b(file|open|read|write)\\(.*\\)$/\n        $path_component = /\\.{2,}/\n    condition:\n        $file_op_call and $path_component\n    }",
      "codeql_rule": "import cwe022\n\nclass CWE022Rule extends Rule {\n  // Checks for path traversal vulnerability\n  // by looking for improper limiting of pathname\n  // to a restricted directory.\n  def predicate(): Predicate {\n    cwe022.PathTraversal()\n  }\n}"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-Site Request Forgery (CSRF) is a type of attack that allows an attacker to send malicious requests to a website from a different domain, without the user\u2019s knowledge or consent. This type of attack allows an attacker to gain control over a user\u2019s session on the website, which can lead to unauthorized access to the user\u2019s data, account, and other sensitive information. In Rust, CSRF vulnerabilities can be introduced through the use of unsanitized user input, allowing an attacker to send malicious requests and gain access to the user\u2019s data.",
      "vulnerable_code": "fn process_form(req: &mut Request) -> Result<(), Error> {\n    let params = req.params();\n    let username = params.get(\"username\").unwrap();\n    let password = params.get(\"password\").unwrap();\n \n    // ... \n    \n    // vulnerable code\n    if username == \"admin\" && password == \"password\" {\n        // perform privileged action\n    }\n \n    Ok(())\n}",
      "remediation": "The following example shows how to use a unique, unpredictable token to prevent CSRF attacks:\n\n1. Generate a unique, unpredictable token for each user session, known as a CSRF token.\n\n2. Include the token in the form as a hidden field.\n\n3. When the form is submitted, check that the token sent in the request matches the one stored in the user's session.\n\n4. If the token does not match, reject the request and display an error message.",
      "semgrep_rule": "rule: \n\n//Detects potential Cross-Site Request Forgery\n\n@csrf_attack\n\n// look for any network request\n\nnetwork-request: *\n\n// if the request is a POST request\n\nif request.method == \"POST\"\n\n// and the request contains a Referer header value that doesn't match the host\n\nand request.headers['referer'] != request.host\n\n// alert\n\nalert",
      "codeql_rule": "// Vulnerability: CWE-352: Cross-Site Request Forgery (CSRF)\n\nimport http\n\nclass Request {\n  Request request;\n  String method;\n  String url;\n  String origin;\n}\n\nclass CsrfVulnerability {\n  Request request;\n}\n\nfrom Request req, CsrfVulnerability vuln\nwhere vuln.request = req and req.method != \"GET\"\nand not http.isSameOrigin(req.origin, req.url)\nselect vuln"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability that occurs when an application allows a user to upload a file of any type without adequate restrictions or validations. This can result in malicious files being uploaded which can then be used to compromise the application or the system it is running on. This vulnerability can occur in web applications, desktop applications, or any other type of application that allows users to upload files. In order to mitigate this vulnerability, file types should be restricted to only those that are known to be safe, and any uploaded files should be scanned for malicious content.",
      "vulnerable_code": "fn main() {\n    let file_name = \"/var/www/uploads/sample.pdf\";\n    let f = File::create(file_name).expect(\"Unable to create file\");\n    let mut data = Vec::new();\n\n    // Read in the file data\n    f.read_to_end(&mut data).expect(\"Unable to read file\");\n \n    // Write the file to the server\n    let _ = fs::write(file_name, &data).expect(\"Unable to write file\");\n}\n\nThe code above is vulnerable to CWE-434. It allows a user to upload any type of file, including potentially dangerous file types such as scripts, executable files, etc. without any restriction. This could lead to malicious code being uploaded to the server and executed.",
      "remediation": "The most effective way to remediate this vulnerability is to restrict the types of file uploads that are allowed. This can be done by implementing a whitelist of accepted file types, only allowing specific types of files to be uploaded. Additionally, it is important to check the file for any malicious content before allowing it to be uploaded. This can be done by running a virus scanner or other malware detection software on the file.",
      "semgrep_rule": "rules:\n  - id: CWE-434-unrestricted-upload-of-file-with-dangerous-type\n    message: \"Unrestricted Upload of File with Dangerous Type detected\"\n    severity: \"WARNING\"\n    pattern: |\n      |\n        let _ = std::fs::OpenOptions::new().write(true).open(\n            &\"$FILE$\"\n        )\n    metadata:\n      example: \"let _ = std::fs::OpenOptions::new().write(true).open(&<file>)\"\n      cwe: 434\n      cwe_name: Unrestricted Upload of File with Dangerous Type",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass UnrestrictedUploadOfFileWithDangerousType extends TaintTracking::Sink {\n  UnrestrictedUploadOfFileWithDangerousType() {\n    super(cwe`CWE-434`)\n  }\n\n  override predicate isVulnerable(DataFlow::PathState s) {\n    exists(DataFlow::Node source | source.hasSource() and\n    source.getTaint().hasExplicitTaint(Taint::UPLOADED_FILE)\n  )\n}"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306 is a vulnerability that occurs when a critical function does not have any authentication or authorization mechanisms in place. This means that anyone can access the function without any authentication or authorization, which can lead to security issues such as privilege escalation, data leakage, and more. In the context of Rust, this vulnerability can manifest itself in a variety of ways. For example, Rust applications might expose a function that requires a certain level of privilege, but without any authentication or authorization, anyone can access and use that function. Additionally, Rust programs might have functions that require user input but do not properly validate that input, allowing malicious actors to inject malicious payloads or otherwise manipulate the program to their advantage.",
      "vulnerable_code": "fn critical_function() -> bool {\n    // Do some critical action\n    return true;\n}\n\nfn main() {\n    let result = critical_function();\n    if result {\n        // Do some other action\n    }\n}\n\n// Vulnerable code: There is no authentication check before the critical function is executed. This means that anyone who can access the main() function can execute the critical_function without any authentication.\n\nfn critical_function() -> bool {\n    // Do some critical action\n    return true;\n}\n\nfn main() {\n    //Authentication check\n    if authorized() {\n        let result = critical_function();\n        if result {\n            // Do some other action\n        }\n    }\n}\n\n// Fixed code: The code now contains an authentication check before the critical_function is executed, thus ensuring only authorized users can execute the critical_function.",
      "remediation": "To remediate this vulnerability, the application should implement a system of authentication and authorization checks. Before allowing a user to perform any critical function, the application should first check that the user is authenticated, and then check the user's authorization level to make sure they have the necessary privileges to perform the action.\n\nFor example, a web application might use an authentication system such as OAuth2 to check the user's identity before allowing them to take certain actions. Additionally, the application should check that the user has the necessary privileges to perform the action. This can be done by assigning users to different roles, and then checking those roles when a user attempts to take an action. If the user does not have the necessary privileges, then the action should be denied.",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects critical functions missing authentication\"\n        author = \"Author Name\"\n    source:\n        language = \"Rust\"\n    detection:\n        condition:\n            any of them:\n                - pattern: \n                    regexp: 'fn [\\w_]+\\(\\)\\s*\\{.*?\\}'\n                    message: \"Function is missing authentication\"\n                - pattern:\n                    regexp: 'fn [\\w_]+\\(.*?\\)\\s*\\{.*?\\}'\n                    message: \"Function is missing authentication\"\n}",
      "codeql_rule": "import cwe\nimport semantic\n\nclass MissingAuthenticationForCriticalFunction extends Rule {\n    // Rule definition\n   \n    // Get all the functions that are marked with the critical annotation\n    // and check that each of these functions is preceded by an authentication check\n    getCriticalFunctions() {\n        let criticalFunctions = \n            find{\n                fun | \n                fun.hasAnnotation(\"critical\")\n            }else{\n                collect(Annotatable)\n            }\n        return criticalFunctions\n    }\n\n    getAuthenticationChecks(criticalFunctions: Annotatable[]) {\n        let authenticationChecks = \n            find{\n                check | \n                criticalFunctions.some(fun | \n                    check.encloses(fun) && \n                    check.hasAnnotation(\"authentication\"))\n            }else{\n                collect(Expr)"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability related to deserialization of untrusted data, a process which can result in potentially malicious code being executed. When an application deserializes untrusted data, it is possible for attackers to craft malicious code that can be executed on the system. This could lead to an attacker gaining access to sensitive data or executing arbitrary code on the system. To mitigate this vulnerability, organizations should practice secure deserialization techniques and ensure that all data deserialized is validated and sanitized before execution.",
      "vulnerable_code": "fn main() {\n    let data = b\"{\\\"name\\\": \\\"John Doe\\\",  \\\"age\\\": \\\"25\\\"}\";\n    let value: Value = serde_json::from_slice(data).unwrap();\n    println!(\"{}\", value.name);\n}\n\nIn this example, the code is deserializing untrusted data from a byte array without any validation. As a result, malicious code could be injected into the data, which could lead to an arbitrary code execution vulnerability.",
      "remediation": "The best way to prevent deserialization of untrusted data is to limit the types of data that can be deserialized. A good way to do this in Rust is to use the serde crate. This crate provides a number of macros and functions that can be used to restrict the deserialization of data to certain types. For example, the following code defines a struct that can only be deserialized from JSON if it contains a valid integer: \n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Struct {\n    #[serde(deserialize_with = \"validate_integer\")]\n    value: i32,\n}\n\nfn validate_integer<'de, D>(deserializer: D) -> Result<i32, D::Error>\nwhere\n    D: serde::Deserializer<'de",
      "semgrep_rule": "rule = {\n    \"id\": \"CWE-502\",\n    \"severity\": \"warning\",\n    \"pattern\": [\n        {\n            \"regexp\": \".*deserialize.*\",\n            \"includes\": [\n                {\n                    \"regexp\": \".*\\\\s+(untrusted|unverified)\\\\s+.*\"\n                }\n            ]\n        }\n    ]\n}",
      "codeql_rule": "import cwe502\n\nclass CWE_502_Deserialization_Vulnerability {\n  // Vulnerability Pattern\n  // 'Deserialize' is a function that takes untrusted data as an argument\n  // and deserializes it\n  private static prop deserialize_func: CodeTree;\n\n  // Function calls that use 'deserialize_func'\n  private static prop deserialize_call: Call;\n\n  // Functions that are called with untrusted data\n  private static prop untrusted_data_func: Call;\n\n  // Argument of the function call that is untrusted data\n  private static prop untrusted_data_arg: Argument;\n\n  // Initializing the CodeQL query\n  CWE_502_Deserialization_Vulnerability() {\n    deserialize_func :=\n      this.deserialize_func :=\n        (function (name"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability that can arise when an application fails to properly authenticate users before allowing them to access sensitive data or resources. This can lead to unauthorized access to the system and data, resulting in the disclosure of sensitive information or the modification of data without permission. Examples of this vulnerability include weak or nonexistent password policies, lack of multi-factor authentication, and inadequate logging of user activity.",
      "vulnerable_code": "fn authenticate_user(username: String, password: String) -> Result<(), String> {\n    if username == \"admin\" && password == \"password\" {\n        // Successfully authenticated\n        Ok(())\n    } else {\n        Err(\"Invalid username or password.\")\n    }\n}\n\nThe above code is vulnerable to CWE-287 as it uses a hard-coded username and password for authentication. A malicious user can easily guess the username and password to gain access to the system. A more secure approach would be to use a secure hashing algorithm to store user passwords and compare the hashed passwords during authentication.",
      "remediation": "The best way to remediate CWE-287: Improper Authentication is to ensure that authentication is properly implemented and enforced in your application. This means verifying that users are who they claim to be, and that they are only granted access to data and resources that are appropriate for their level of authority.\n\nSpecific steps to remediate CWE-287: Improper Authentication in Rust include:\n\n1. Implementing a secure authentication system such as OAuth2.0\n2. Using secure hashes and salts when storing passwords in the database.\n3. Limiting the number of failed login attempts allowed.\n4. Enforcing strong password requirements.\n5. Implementing two-factor authentication.\n6. Regularly monitoring authentication logs.\n7. Using secure transport protocols such as TLS/SSL.",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects improper authentication\"\n        severity = \"WARNING\"\n    strings:\n        $login = /login\\(.*\\)/\n        $authenticate = /authenticate\\(.*\\)/\n    condition:\n        $login and not $authenticate\n}",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthenticationCheck extends Cwe287\n{\n    /**\n     * Finds calls to authentication functions that do not perform proper authentication\n     */\n    predicate isAuthenticationCall(Callable callee) {\n        exists(CallExpr ce | ce.getCallee().getCanonicalDecl() == callee)\n    }\n    \n    /**\n     * Checks whether the call to an authentication function is properly authenticated\n     */\n    predicate isProperlyAuthenticated(CallExpr ce, Callable callee) {\n        ce.hasArgument(0, _) and\n        isAuthenticationCall(callee) and\n        ce.hasArgument(1, _) and\n        (ce.hasArgument(2, _) or \n        ce.argumentCount() == 3)\n    }\n    \n    /**"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability that occurs when an application or system uses hard-coded credentials, such as usernames and passwords, for authentication. This means that the credentials are stored in the source code of the application or system in plain text, making them easy for an attacker to retrieve. This type of vulnerability can allow an attacker to gain access to privileged accounts or data, and can be used to compromise an entire system.",
      "vulnerable_code": "fn main() {\n    let username = \"admin\";\n    let password = \"password\";\n    \n    // Authenticate user\n    if (username == \"admin\" && password == \"password\") {\n        println!(\"User authenticated!\");\n    } else {\n        println!(\"Authentication failed!\");\n    }\n}\n\nIn the above example, the username and password are hard-coded into the program, meaning that anyone with access to the code can easily discover the credentials and use them to gain access to the application. This is a security vulnerability because it means that the application is not verifying the identity of the user in a secure way.",
      "remediation": "The remediation for this vulnerability is to ensure that all credentials are stored securely, preferably not in the source code. This can be done by storing credentials in environment variables or in an encrypted credential store. For example, in Rust, the dotenv crate can be used to create a .env file with environment variables that are accessible in code. Additionally, the encrypt crate can be used to store and encrypt credentials in an encrypted file.",
      "semgrep_rule": "rule = {\n  id: \"cwe-798-detection\",\n  patterns: [\n    pattern: \"username = \\\"*\\\"\",\n    pattern: \"password = \\\"*\\\"\"\n  ],\n  message: \"Potential use of hard-coded credentials detected\"\n}",
      "codeql_rule": "import cwe798\n\nclass HardcodedCredentialVulnerability {\n    // Detects the usage of hardcoded credentials\n    // in variable declarations\n    predicate isHardcodedCredential(credential: Expr) {\n        exists(Expr value | value.isConstant() && credential.hasDescendants(value))\n    }\n\n    // Detects the usage of hardcoded credentials\n    // in function calls\n    predicate isHardcodedCredentialArgument(arg: Expr, index: int) {\n        exists(Expr value | value.isConstant() && arg.hasDescendants(value) && arg.getArgumentIndex() == index)\n    }\n\n    // Detects the usage of hardcoded credentials\n    // in data structures\n    predicate isHardcodedCredentialElement(element: Expr) {\n        exists(Expr value | value.isCon"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 is a type of software vulnerability that occurs when a system is installed with incorrect default permissions, allowing users or groups access to sensitive data or resources that they should not have. This can result in unauthorized access to private data, or the ability to modify or delete important files or resources. In the case of Rust, this vulnerability can occur if the code is written without proper permissions in place, or if the default permissions are not correctly configured.",
      "vulnerable_code": "fn create_file() {\n    let mut f = File::create(\"test.txt\").expect(\"Failed to create file\");\n    f.write_all(b\"Hello World\").expect(\"Failed to write to file\");\n}\n\n// The file is created with the default permissions of the user, which may not be secure.\nfn create_file_securely() {\n    let mut f = OpenOptions::new()\n        .write(true)\n        .mode(0o600)\n        .create(true)\n        .open(\"test.txt\")\n        .expect(\"Failed to create file\");\n    f.write_all(b\"Hello World\").expect(\"Failed to write to file\");\n}",
      "remediation": "A remediation for CWE-276: Incorrect Default Permissions would be to ensure that all files and directories created by the application have the correct permissions set. This can be accomplished by setting the umask of the application\u2019s environment before creating any files or directories. The following example shows how to set the umask to 022 in Rust:\n\n// Set the umask to 022\nlet umask = 0o022;\nunsafe { libc::umask(umask as _) };",
      "semgrep_rule": "rule = {\n  id: \"cwe-276-incorrect-default-permissions\",\n  patterns: [\n    {\n      pattern: \"File::open(path, _, Permissions::Mode::all(_))\",\n      message: \"Incorrect default permissions set on the file opened at 'path'.\"\n    }\n  ],\n  severity: \"WARNING\"\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.security.InsecurePermissions\n\nclass CWE276IncorrectDefaultPermissions extends InsecurePermissions {\n    CWE276IncorrectDefaultPermissions() {\n        super(cwe `CWE-276`)\n    }\n}"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a type of security vulnerability that occurs when sensitive information is exposed to an unauthorized actor. This vulnerability can occur when data is not securely stored, an attacker gains access to a system, or when there is a lack of access control. If a malicious actor is able to access confidential information such as passwords, credit card numbers, or other sensitive data, they can use this information to gain access to accounts and commit fraud. This vulnerability can also lead to identity theft and other forms of financial fraud.",
      "vulnerable_code": "fn main() {\n    let sensitive_data: String = \"my_password\".to_string();\n    let public_data: String = \"public_data\".to_string();\n\n    let mut data = sensitive_data + &public_data;\n\n    println!(\"Data: {}\", data);\n}\n\nIn the above code, sensitive data (e.g. a password) is stored in a variable and then concatenated with public data to form a single string. This string is then printed to the console, thus exposing the sensitive data to an unauthorized actor.",
      "remediation": "The most effective way to remediate CWE-200 would be to ensure that only authorized users have access to sensitive information. This can be done by implementing access control measures such as authentication, authorization, and encryption. \n\nFor authentication, use of multi-factor authentication can be used to verify the identity of users before granting access to sensitive information. Authorization can be used to ensure that only certain users have access to certain information, and encryption can be used to protect the data from unauthorized access.\n\nAdditionally, implementing monitoring and logging systems can help to detect and alert administrators of any suspicious activities related to access of sensitive information.",
      "semgrep_rule": "rule = {\n    strings:\n        $sensitive_info = /.*/\n    condition:\n        $sensitive_info != \"\"\n    message: \"Sensitive information is exposed to an unauthorized actor\"\n}",
      "codeql_rule": "import cwe200\n\nclass CWE200_ExposureOfSensitiveInformationToUnauthorizedActorRule extends Rule {\n  // Declare rule meta data\n  meta:\n    author = \"Your Name\"\n    description = \"This rule detects when sensitive information is exposed to an unauthorized actor.\"\n    severity = \"High\"\n\n  // Declare the query pattern\n  query anyAccessToSensitiveInformation {\n    // Find code that accesses sensitive information\n    AccessToSensitiveInformation = cwe200.AccessToSensitiveInformation()\n    // Find code that is executed by an unauthorized actor\n    ExecutedByUnauthorizedActor = cwe200.ExecutedByUnauthorizedActor()\n\n    // Check that both the access and the unauthorized actor are present\n    AccessToSensitiveInformation and ExecutedByUnauthorizedActor\n  }\n\n  // Declare the alert message\n  //"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522: Insufficiently Protected Credentials is a vulnerability that occurs when an application fails to protect user credentials, such as passwords and usernames, against unauthorized access or manipulation. This vulnerability allows an attacker to gain access to a user's account or sensitive data stored in the application. It is important to ensure that credentials are stored securely and properly encrypted to mitigate this vulnerability. In the case of Rust, developers should use a library such as bcrypt to securely store and validate user passwords.",
      "vulnerable_code": "fn main() {\n    let mut username = String::from(\"admin\");\n    let mut password = String::from(\"password\");\n    // ...\n    // Some code\n    // ...\n    let user_input = get_user_input();\n    if user_input == username && user_input == password {\n        // Access granted!\n    }\n}\n\nIn the code above, the user is able to gain access to the application by entering both the username and password as the same string. This is vulnerable to CWE-522: Insufficiently Protected Credentials because there is no check to ensure that the user input is not the same as the credentials stored in the username and password variables.",
      "remediation": "The most effective way to remediate this vulnerability is to use a secure credential storage system. This could be anything from a dedicated password manager to an encrypted file system, such as a virtual private network (VPN). This storage system should ensure that all credentials are encrypted, and the encryption key is kept safe and secure. Additionally, multi-factor authentication should be used whenever possible to mitigate the risk of credentials being compromised.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects the use of insufficiently protected credentials\"\n    severity = \"MEDIUM\"\n    tags = [\"security\"]\n  strings:\n    $creds = /(username|password):\\s*\\S+/\n    $salt = /salt:\\s*\\S+/\n    $hash = /hash:\\s*\\S+/\n  condition:\n    $creds and not $salt and not $hash\n}",
      "codeql_rule": "import cwe522\n\nclass InsufficientlyProtectedCredentials:\n  // Find all the functions, methods or classes that are used for handling user credentials\n  query credential_handlers {\n    // Identify all the variables of type String, File, or IO\n    let credential_types = type(\"std::string\") + type(\"std::ofstream\") + type(\"std::ifstream\") + type(\"std::fstream\") + type(\"std::iostream\")\n    // Find all functions, methods, or classes that take such variables as parameters\n    let credential_handlers = \n      // Functions\n      function \n        param.type anyof(credential_types)\n    + \n      // Methods\n      method\n        param.type anyof(credential_types)\n    +\n      // Constructors\n      ctor\n        param.type anyof(c"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a type of XML injection vulnerability where malicious XML code is able to access resources outside of the application\u2019s control. It occurs when an application processes XML input without properly restricting or disabling external entity references within the document. By exploiting this vulnerability, an attacker can gain access to sensitive data, cause denial of service, or even execute malicious code on the system. In Rust, this can be caused by the use of unsafe code when working with XML, which can allow a malicious user to inject external entity references and gain access to resources outside the application\u2019s control.",
      "vulnerable_code": "fn main() {\n    let parser = sax::Parser::new();\n    let mut reader = File::open(\"data.xml\").unwrap();\n    parser.parse(&mut reader).unwrap();\n}\n\nThe above code is vulnerable to CWE-611, as it does not validate or restrict the external entity references in the XML file (data.xml) before parsing it. This could allow an attacker to inject malicious code into the XML file, which could then be executed when the parser attempts to parse it.",
      "remediation": "An example of remediation for CWE-611 could be to disable external entity expansion when parsing XML documents. This can be done by setting the \"resolve_entities\" option to false when configuring the XML parser. For example, if you are using the Rust XML-rs library, you would configure your parser like this:\n\nlet parser = ParserConfig {\n    resolve_entities: false,\n    ..Default::default()\n};\nlet reader = EventReader::new_with_config(file, parser);",
      "semgrep_rule": "rules:\n  - id: CWE-611\n    patterns:\n      - pattern: '<!ENTITY\\s+[^>]*\\s+SYSTEM\\s+[\"\\'][^>]*>'\n    message: 'Improper Restriction of XML External Entity Reference (CWE-611) detected'\n    severity: WARNING",
      "codeql_rule": "import cwe611\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass CWE611Vulnerability extends Vulnerability {\n\tCWE611Vulnerability() {\n\t\tthis.id = \"CWE-611\";\n\t\tthis.name = \"Improper Restriction of XML External Entity Reference\";\n\t\tthis.description = \"An application improperly processes XML files containing references to external resources and fails to properly restrict the access of those external entities.\";\n\t\tthis.vulnerableSystem = \"XML processing\";\n\t\tthis.severity = Severity.HIGH;\n\t\tthis.likelihoodOfExploit = LikelihoodOfExploit.HIGH;\n\t\tthis.cwe = cwe611;\n\t}\n\n\t@Override\n\tboolean isVulnerable(TaintTracking.TaintPath path) {"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-Side Request Forgery (SSRF) is a security vulnerability that occurs when an attacker tricks a server into sending a malicious request to an arbitrary external system. This can allow attackers to gain access to sensitive information, send malicious requests to internal systems, and perform other malicious activities. In Rust, SSRF is typically caused by an application failing to properly validate user input before using it to construct a request. This can allow an attacker to craft a malicious request that targets a different server or port than the intended destination.",
      "vulnerable_code": "fn fetch_data_from_url(url: &str) {\n    let client = reqwest::blocking::Client::new();\n    let mut res = client.get(url).send().unwrap();\n\n    // ... process response\n}\n\nfn main() {\n    let url = \"http://example.com/data.txt\";\n\n    // Vulnerable code:\n    // Fetch data from URL without validating that it's safe\n    fetch_data_from_url(url);\n}\n\nIn this example, the code is vulnerable to SSRF because it does not validate that the URL provided is safe. An attacker can use this vulnerability to make requests to internal services or cause unintended side effects.",
      "remediation": "Remediation of this vulnerability involves checking the validity of any URLs received from a client before attempting to access them. This can be accomplished by ensuring that all URLs are validated against a whitelist of approved sites.\n\nFor example, a Rust program to validate URLs against a whitelist might look like this:\n\n// Create a whitelist of approved URLs\nlet approved_urls = [\n    \"https://example.com/\",\n    \"https://example.org/\",\n];\n \n// Parse the URL from the client\nlet url_from_client = url::Url::parse(&client_url).unwrap();\n\n// Check if the URL is in the approved list\nif approved_urls.contains(&url_from_client.as_str()) {\n    // If it is, proceed with the request\n    // ...\n} else {\n    // Otherwise, respond with an error\n    //",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects Server-Side Request Forgery (SSRF) vulnerability\"\n        severity = \"CRITICAL\"\n        author = \"Your Name\"\n    source:\n        // Patterns that indicate SSRF vulnerability\n        patterns: [\n            'http.get(', \n            'http.post(',\n            'http.request(',\n            'curl(',\n            'fetch('\n        ]\n    detection:\n        // Detects if the patterns were used in a suspicious context\n        condition: patterns\n}",
      "codeql_rule": "import cwe918\n\nclass CWE918Rule extends Rule {\n  // Query to detect code that makes a network request using\n  // user-supplied data without proper validation\n  query non_validated_network_request {\n    let url: Expr\n    let client: Expr\n    \n    // Find a call to a function that creates a network request using\n    // user-supplied data\n    call_expression = {\n      // Find a function call\n      let callee: Expr\n      callee = CallExpr.callee\n      \n      // Check if the function is a network request\n      callee.matches(\"http::request\") or\n      callee.matches(\"http::client::request\") or\n      callee.matches(\"reqwest::get\") or\n      callee.matches(\"reqwest::post\") or\n      callee"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of vulnerability that occurs when an attacker is able to execute arbitrary commands on a system by sending malicious input through a vulnerable application. In Rust, this vulnerability can occur when user input is not properly sanitized before being used in a command. This can allow an attacker to inject malicious code into the application, which can be used to gain access to sensitive information or to perform malicious activities.",
      "vulnerable_code": "fn exec_command(command: &str) {\n    let output = std::process::Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(command)\n        .output()\n        .expect(\"failed to execute command\");\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    println!(\"output: {}\", stdout);\n}\n\nfn main() {\n    let user_input = std::env::args().nth(1).expect(\"Missing user input\");\n    exec_command(&user_input);\n}\n\nThe code above is vulnerable to command injection because it takes user input and passes it directly to the operating system without any validation or sanitization. This means an attacker could enter malicious input that would be executed as a command on the system, potentially leading to a variety of security issues.",
      "remediation": "The best way to prevent this type of vulnerability is to use proper input sanitization. This can be done by validating any user input against a whitelist of acceptable characters, and rejecting any input that does not match the whitelist. For example, a function for sanitizing user input in Rust might look like this:\n\nfn sanitize_input(input: &str) -> Option<String> {\n    let whitelist = \"abcdefghijklmnopqrstuvwxyz0123456789\".to_string();\n    if input.chars().all(|x| whitelist.contains(x)) {\n        Some(input.to_string())\n    } else {\n        None\n    }\n}",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects improper neutralization of special elements used in a command\"\n      severity = \"high\"\n    strings:\n      $func1 = /system|popen|exec|fork|execv/\n      $func2 = /system|popen|exec|fork|execv/\n      $cmd = /.*/\n    condition:\n      $func1 and $func2 and ($cmd)\n}",
      "codeql_rule": "import cwe077\n\nclass CWE_077_Vuln extends Rule {\n  // Match calls to functions that are vulnerable to command injection\n  // (e.g. system, popen, exec)\n  // without proper sanitization\n \n  // A call chain that contains at least one call to a vulnerable function\n  // and does not contain a call to a sanitizing function\n  vulnerableCallChain() {\n    VulnerableFunctionCall ->\n      !SanitizingFunctionCall\n      *\n  }\n \n  // Match any combination of vulnerable call chain and assignment to a\n  // user-controlled value\n  vulnerableCallChainAssignment() {\n    AssignmentExpr ->\n        Expr.asLeft\n        vulnerableCallChain()\n        Expr.asRight\n  }\n \n  // Match any vulnerable call chain\n  vulnerableCallChainStatement() {"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295: Improper Certificate Validation occurs when a program or system fails to adequately validate a certificate that is presented from a remote host. This can lead to a malicious user being able to spoof the identity of the remote host, potentially allowing them to gain access to sensitive information or resources. In the case of Rust, this vulnerability can be particularly dangerous as Rust's memory safety guarantees make it easier for an attacker to exploit the vulnerability.",
      "vulnerable_code": "fn verify_certificate(certificate: &Certificate) -> bool {\n    // This code does not validate the supplied certificate.\n    true\n}",
      "remediation": "// Validate the certificate chain\nlet certificate_chain = &mut root_certificate_chain;\nlet valid = validate_chain(certificate_chain, true);\nif !valid {\n    return Err(Error::InvalidCertificate);\n}",
      "semgrep_rule": "rule CWE_295_Improper_Certificate_Validation {\n    meta:\n        description = \"Detects improper certificate validation\"\n        author = \"Semgrep\"\n        severity = \"CRITICAL\"\n    strings:\n        $a1 = /TLSContext.*set_verify/\n        $a2 = /TLSContext.*set_verify_depth/\n        $a3 = /TLSContext.*set_verify_hostname/\n        $a4 = /TLSContext.*set_verify_mode/\n    condition:\n        all of them\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.security.CertificateValidation\n\nclass ImproperCertificateValidationVulnerability extends SecurityBug\n{\n    // Need to use this constructor to indicate a CWE\n    constructor() {\n        super(cwe`CWE-295`)\n    }\n\n    // Check if the application fails to properly validate a certificate\n    predicate isVulnerable(CertValidationRoutine cvr) \n    {\n        exists(Call c | cvr.getCaller() = c and CertificateValidation.failsValidation(c))\n    }\n}"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is an improper control of code injection vulnerability. Code injection is when an attacker is able to inject code into an application, often through user input, that can be executed without the application's authorization. This can allow an attacker to gain access to the application and its data, or to execute malicious code on the system. In Rust, this can occur when user input is not properly sanitized or validated, and is used as part of a dynamic string or code generation process. This can allow an attacker to inject malicious code into a dynamic string or code that is executed by the application.",
      "vulnerable_code": "fn main() {\n    let user_input = std::env::args().nth(1).unwrap_or_default();\n    let command = format!(\"echo {}\", user_input);\n    std::process::Command::new(\"sh\").arg(\"-c\").arg(&command).spawn().unwrap();\n}\n\nThis code is vulnerable to code injection because it takes user input and executes it as a shell command without any filtering or sanitization. This means that an attacker could input malicious code into the program which would be executed with elevated privileges.",
      "remediation": "Remediation of code injection vulnerabilities can be achieved by using a whitelisting approach. Specifically, any user input should be checked against an allowed list of characters and strings. If the input does not match any of the allowed values, it should be discarded. In addition, any user input should be escaped properly to ensure that malicious code does not get executed. \n\nFor example, in Rust, user input should be sanitized using the `.sanitize()` method in the `std::string` library. This method will escape any characters that could potentially be used in code injection attacks.",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: '{var} = os.exec({str})',\n      message: 'Improper control of generation of code detected',\n      metadata: {\n        type: 'CWE-094',\n        description: 'Improper Control of Generation of Code',\n      },\n    },\n  ],\n}",
      "codeql_rule": "import cwe094\n\nclass CWE094_Improper_Control_of_Generation_of_Code_Injection:\n    def vulnerable_functions():\n        // Find functions that are vulnerable to code injection\n        return cwe094.vulnerableFunctions()\n    \n    def get_sink_calls(func):\n        // Get all calls to the vulnerable functions\n        return func.calls(vulnerable_functions())\n    \n    def get_tainted_data():\n        // Find all data sources that could be used for code injection\n        return cwe094.taintedData()\n    \n    def is_tainted_parameter(call, parameter):\n        // Check if the given parameter for the given call is tainted\n        return call.getArg(parameter).sources().intersects(get_tainted_data())"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 is a vulnerability related to improper privilege management. It occurs when an application or system fails to properly manage user privileges, leading to a situation where an unauthorized user is granted access to sensitive data, functions, or resources. This can include the granting of privileged access to a user who should not be allowed such access, or the granting of privileges to a user that are not appropriate for their level of authorization. CWE-269 can lead to data breaches and other malicious activities, such as stealing credentials and performing unauthorized activities.",
      "vulnerable_code": "fn main() {\n    let user_name = \"administrator\";\n    let admin_level = 3;\n\n    // Get the user input\n    let user_input = get_input();\n\n    // Check if the user is an admin\n    if user_name == user_input && admin_level > 0 {\n        // Grant the user admin privileges\n        grant_admin_privileges();\n    }\n}\n\nfn grant_admin_privileges() {\n    // Grant access to all system resources including files, databases, etc.\n    // without checking the user's access level.\n}",
      "remediation": "Using Rust's Access Control feature, one can enforce proper privilege management. For example, the following code can be used to restrict access to a resource to only certain users:\n\n// Declare a new type to represent a user\nstruct User {\n    username: String\n}\n\n// Declare a new resource type that requires a user to access\nstruct Resource {\n    owner: User\n}\n\n// Create a function that checks if a user has access to a resource\nfn has_access(user: &User, resource: &Resource) -> bool {\n    user == &resource.owner\n}\n\nfn main() {\n    // Create a new user\n    let user = User {\n        username: \"John\".to_string(),\n    };\n\n    // Create a new resource that is owned by the user\n    let resource = Resource {\n        owner: user,\n    };\n\n    // Check if the user",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detect improper privilege management\"\n    severity = \"WARNING\"\n    tags = [\"security\", \"privilege-management\", \"rust\"]\n\n  source: \n    languages = [\"Rust\"]\n\n  patterns:\n    - pattern: |\n        unsafe {\n            |\n            .*\n            |\n            libc::setuid(\n              $args:expr\n        )\n      message: \"Improper privilege management detected\"\n}",
      "codeql_rule": "import cwe269\n\nclass ImproperPrivilegeManagementVulnerability {\n    // find functions that are granting privileges\n    // to a user or group\n    // without proper checks\n    predicate grantPrivilege(funcName: string, user: string, privilege: string) {\n        // find function calls that grant privileges\n        // to a user\n        exists(Call c |\n            c.getTarget().getName() == funcName &&\n            c.hasArgument(user) &&\n            c.hasArgument(privilege)\n        )\n    }\n\n    // find functions that are revoking privileges\n    // from a user or group\n    // without proper checks\n    predicate revokePrivilege(funcName: string, user: string, privilege: string) {\n        // find function calls that revoke privileges\n        // from a user\n        exists(Call c |\n            c.getTarget().get"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is an expression language injection vulnerability in which an attacker is able to inject malicious code into a web application through its use of an expression language statement. This attack is dangerous as it can be used to manipulate program execution and access sensitive data. The vulnerability occurs when an application fails to properly neutralize special elements used in an expression language statement, such as user-controlled input. This can allow an attacker to inject malicious code into the application, potentially allowing access to sensitive data or allowing manipulation of program execution.",
      "vulnerable_code": "fn process_input(user_input: &str) {\n    let query = format!(\"SELECT * FROM users WHERE name='{}'\", &user_input);\n    // Query the database using the user-provided input\n    // ...\n}\n\nThis code is vulnerable to expression language injection as it does not sanitize the user-provided input before using it in a query. An attacker could use this vulnerability to inject malicious code into the query, which could allow them to gain access to sensitive information or modify the database.",
      "remediation": "One way to remediate an expression language injection vulnerability is to validate user input against a whitelist of valid characters. This can be done by using the Rust standard library\u2019s regex library to create a regular expression that matches only the valid characters, and then validating user input against that expression. For example, if we wanted to validate a username, we could use the following regular expression:\n\nlet username_regex = Regex::new(r\"^[A-Za-z0-9_]{1,20}$\").unwrap();\n\nThis regular expression matches only upper and lowercase letters, numbers, and underscores, and also has a character limit of 20 characters. To validate a username, we could use the regex::is_match() method as follows:\n\nif !username_regex.is_match(&username) {\n    // username is invalid\n}\n\nThis method allows us to validate user input",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects potential CWE-917 vulnerability - Improper Neutralization of Special Elements used in an Expression Language Statement\"\n    author = \"VulnDetect\"\n    maturity = \"stable\"\n  strings:\n    $expr = /[\\$#]{1,2}\\{.*\\}/\n  condition:\n    $expr\n}",
      "codeql_rule": "import cwe917\n\nclass ExpressionLanguageInjection_CWE917 extends SecurityCodeScannerRule {\n  MetaData getInfo() {\n    return MetaData.builder()\n      .id(\"CWE-917\")\n      .title(\"Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\")\n      .description(\"This rule detects code that does not properly neutralize special elements used in an expression language statement, which can lead to expression language injection.\")\n      .kind(Kind.VULNERABILITY)\n      .cwe(cwe917)\n      .leaveNoTrace(true)\n      .build();\n  }\n\n  // Matches any code that does not properly neutralize special elements used in expression language statements\n  // such as SQL queries, JavaScript, etc.\n  pattern exprInjection() {\n    ExpressionStatement.allInst"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability related to improper link resolution before file access. This vulnerability occurs when a program follows a link that is provided by an untrusted source, without first verifying the validity of the link. This can lead to an attacker gaining access to files or resources that they should not have access to. In the Rust language, this vulnerability can occur if links are provided to the open() function in the standard library without first being checked for validity.",
      "vulnerable_code": "fn open_file(file_path: &str) -> Result<(), std::io::Error> {\n    let mut file_path = std::path::PathBuf::from(file_path);\n    if !file_path.is_absolute() {\n        // This line is vulnerable, as it allows a malicious user to\n        // manipulate the relative path to open files outside of the\n        // intended directory.\n        file_path = std::env::current_dir()?.join(file_path);\n    }\n\n    let file = std::fs::File::open(file_path)?;\n    // Do something with the file\n\n    Ok(())\n}",
      "remediation": "The simplest way to remediate this vulnerability is to ensure that all links are fully resolved before accessing the file. This can be accomplished by using the canonicalize() function in Rust. This function will take a path as an argument and return the fully resolved path that points to the file. For example:\n\nlet path = Path::new(\"../some/path/file.txt\");\nlet resolved_path = canonicalize(path).unwrap();\n\nThis code will take the path \"../some/path/file.txt\" and return the fully resolved path to the file, which can then be used to access the file.",
      "semgrep_rule": "rule = {\n    meta:\n        severity = \"medium\"\n        description = \"Detects improper link resolution before file access\"\n    strings:\n        $link_follow = /[^\\s]+\\.[^\\s]+/\n    condition:\n        any of (\n            $link_follow\n        )\n}",
      "codeql_rule": "import cpp\nimport semmle.code.cpp.security\n\nclass ImproperLinkResolution extends SecurityFeature {\n\n  CWE059_LinkFollowing() {\n    // Vulnerability occurs when a program follows a link to a file\n    // without first checking if the link points to a valid location.\n    when File.followLink() as link\n    where link.isValid() == false\n    then report(\"Improper link resolution before file access detected\")\n  }\n\n}"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability which occurs when sensitive information such as passwords, credit card numbers, or other confidential data is transmitted over an unencrypted connection. This means that any hacker with access to the network can intercept the data in plaintext and use it for malicious purposes. This vulnerability is especially dangerous if the data is transmitted over a public network such as the internet, or a mobile network, as these networks are not secure. In Rust, this vulnerability can be prevented by using secure protocols such as TLS or SSL. Additionally, authentication and encryption techniques can also be used to protect data while it is being transmitted.",
      "vulnerable_code": "fn main() {\n    let message = \"This is a very sensitive message!\";\n    let mut stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n\n    // This is the vulnerable code, as it transmits the message in cleartext.\n    stream.write(message.as_bytes()).unwrap();\n}",
      "remediation": "Example:\n\n// Before\nlet username = \"JohnDoe\";\nlet password = \"1234\";\n\n// After\nlet username = \"JohnDoe\";\nlet password = encrypt(key, \"1234\");",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects cleartext transmission of sensitive information\"\n        severity = \"CRITICAL\"\n        authors = [\"Your Name\"]\n    strings:\n        $s1 = /http:\\/\\//\n        $s2 = /https:\\/\\//\n    condition:\n        all of them\n}",
      "codeql_rule": "import cwe319\nimport semmle.code.cpp.security.taint\n\nclass CleartextTransmissionOfSensitiveInfo extends SecurityFlow {\n    CleartextTransmissionOfSensitiveInfo() {\n        super(cwe319.CleartextTransmissionOfSensitiveInfo)\n    }\n\n    override predicate getDataFlowPredicate() {\n        // data flow from a tainted source to an untainted sink\n        return this.TaintedSource() && this.UntaintedSink()\n    }\n}\n\nfrom CleartextTransmissionOfSensitiveInfo ctsosf, DataFlow df\nwhere ctsosf.getDataFlowPredicate() and df.taintFlow(ctsosf)\nselect ctsosf, \"Cleartext transmission of sensitive information detected\""
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 is a vulnerability that occurs when an attacker is able to redirect a user from a trusted website to an untrusted website. This vulnerability can be exploited by an attacker to take advantage of the trust relationship between the user and the trusted website. This can be done by providing a malicious URL in the form of a redirect link which, when clicked, will redirect the user to an untrusted website. The untrusted website may contain malicious content or code that can be used to steal sensitive information or launch other attacks.",
      "vulnerable_code": "// This function takes a URL and redirects the user to the given URL.\nfn redirect(url: &str) {\n    println!(\"Redirecting...\");\n    println!(\"Location: {}\", url);\n}\n\n// This function takes user input, which is a URL, and attempts to redirect the user to that URL.\nfn vulnerable_redirect() {\n    let input_url = std::env::var(\"URL\").expect(\"URL must be set\");\n    redirect(&input_url);\n}",
      "remediation": "Before:\n\nfn redirect(url: &str) -> Redirect {\n    Redirect::to(url)\n}\n\nAfter:\n\nfn redirect(url: &str) -> Redirect {\n    if is_valid_url(url) {\n        Redirect::to(url)\n    } else {\n        Redirect::to(\"/\")\n    }\n}\n\nfn is_valid_url(url: &str) -> bool {\n    let parsed_url = Url::parse(url);\n    parsed_url.is_ok() && parsed_url.unwrap().host_str().is_some()\n}",
      "semgrep_rule": "rule = {\n  strings:\n    $url_redirect = /(?P<url>.*?)/\n  condition:\n    $url_redirect\n}",
      "codeql_rule": "import cwe601\n\nclass OpenRedirectVulnerability extends Vulnerability {\n  OpenRedirectVulnerability() {\n    super.name = \"Open Redirect Vulnerability\";\n  }\n\n  predicate isVulnerable() {\n    exists(Call c, Method m |\n      c.getTarget().getName() = \"redirect\" and\n      c.getArgument(0)?.getValue() != null and\n      cwe601.isOpenRedirect(m, c)\n    )\n  }\n}"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability that occurs when sensitive information is inserted into a log file. This can happen if a user input is unintentionally logged, or if a log file is configured to store sensitive data. If an attacker is able to access the log file, they can view the sensitive data and use it to gain access to other parts of the system. This can lead to data theft, identity theft, or other malicious activities. Additionally, the sensitive information may be used to create a false sense of security, allowing the attacker to bypass authentication mechanisms or other security measures.",
      "vulnerable_code": "fn log_user_information(user_info: String) {\n    // Create a log file\n    let mut log_file = File::create(\"app.log\").expect(\"Unable to create log file\");\n\n    // Write the user information to the log file\n    log_file.write_all(user_info.as_bytes()).expect(\"Unable to write to log file\");\n}\n\n// Invoke the function with sensitive data\nlog_user_information(\"username=admin&password=123456\");\n\n// The log file now contains the user's sensitive information\n// CWE-532: Sensitive information has been inserted into a log file without proper protection",
      "remediation": "The following code example shows one way of remediating the vulnerability of inserting sensitive information into log files. The code uses the log crate to create loggers with different levels of security. For example, a secure logger is created with the log::LevelFilter::Off level filter, which will prevent any sensitive information from being logged.\n\n```rust\nextern crate log;\n\nuse log::{LogRecord, LogLevelFilter, LogMetadata};\n\nstruct SecureLogger;\n\nimpl log::Log for SecureLogger {\n    fn enabled(&self, metadata: &LogMetadata) -> bool {\n        metadata.level() <= LogLevelFilter::Off\n    }\n\n    fn log(&self, record: &LogRecord) {\n        if self.enabled(record.metadata()) {\n            println!(\"{} - {}\", record.level(), record.args());\n        }\n    }\n}",
      "semgrep_rule": "rule = {\n    meta:\n        description = \"Detects insertion of sensitive information into log files\"\n        author = \"Your name\"\n        id = \"CWE-532\"\n        severity = \"high\"\n    strings:\n        $sensitive_info = /(credit_card_number|social_security_number|login_credential|password)/\n    condition:\n        // checks for log functions with sensitive information as parameter\n        $sensitive_info and (\n            (func(\"log::*\") and parameter.contains($sensitive_info))\n            or\n            // checks for logging of sensitive information\n            (expr and expr.contains($sensitive_info))\n        )\n}",
      "codeql_rule": "import cwe532\n\nclass LogInsertionVulnerability extends Rule {\n  // Look for calls to logging functions\n  predicate isLoggingFunction(Expr e) {\n    e.match(\n      // Detect calls to logging functions\n      fn: FunctionCall { callee.hasName(\"log\") }\n    )\n  }\n  \n  // Find the arguments being passed to the logging functions\n  predicate isLoggingArgument(Expr e) {\n    e.match(\n      // Find calls to logging functions\n      fn: FunctionCall { callee.hasName(\"log\") },\n      // Check the arguments being passed to the logging functions\n      arg: Expr { parent: fn }\n    )\n  }\n\n  // Check if sensitive information is being passed as argument\n  predicate isSensitiveInformation(Expr e) {\n    e.match(\n      // Look for references"
    }
  },
  "Go": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of vulnerability that occurs when malicious code is injected into a web page or application. This code can be used to execute malicious scripts on the user's web browser, potentially allowing the attacker to steal information, hijack sessions, or even take control of the user\u2019s computer. XSS is a type of injection attack, where the attacker injects malicious code into an input field. The code is then executed when the user visits the webpage, allowing the attacker to access information stored on the user\u2019s computer.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Vulnerable code:\n\t\tname := r.URL.Query().Get(\"name\")\n\t\tfmt.Fprintf(w, \"<h1>Hello, %s!</h1>\", name)\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nThe code above is vulnerable to Cross-site Scripting (CWE-079) because it does not properly sanitize the user input from the URL query parameter \"name\". In this case, if a malicious user sets the \"name\" parameter to a malicious script, then the script would be executed when the code generates the web page.",
      "remediation": "// Before\nfunc writePage(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(r.FormValue(\"input\")))\n}\n\n// After\nfunc writePage(w http.ResponseWriter, r *http.Request) {\n    input := html.EscapeString(r.FormValue(\"input\"))\n    w.Write([]byte(input))\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-079\",\n  patterns: [\n    {pattern: \"echo $1 | %{word} | html.EscapeString()\", message: \"Potential Cross-site Scripting (XSS) vulnerability detected!\"}\n  ],\n  severity: \"medium\"\n}",
      "codeql_rule": "import cwe\nimport go\n\nclass CrossSiteScriptingVulnerability(cwe.Vulnerability):\n \n  // Detects a Cross-site Scripting (XSS) vulnerability in Go code\n \n  // Finds uses of the 'html/template' package\n  GoTemplateTemplatePackageCall = go.Call(\"html/template.Template\")\n  \n  // Finds uses of the 'html/template' Execute method\n  GoTemplateExecuteMethodCall = GoTemplateTemplatePackageCall.member(\"Execute\")\n  \n  // Finds usage of a variable in the Execute method call\n  GoTemplateExecuteMethodCallWithVariable = GoTemplateExecuteMethodCall.withArgs(go.Variable)\n  \n  // Raises an issue when the Execute method is called with a variable\n  // as an argument\n  def rule():\n    cwe.Vulnerability.register(Cross"
    },
    "CWE-020: Improper Input Validation": {
      "description": "Improper input validation is a vulnerability that occurs when an application fails to properly validate user input. This can lead to the application being exposed to malicious code or unexpected behavior, which can potentially allow an attacker to gain control of the application or lead to data breaches. Improper input validation can occur when user input is not checked for correctness, accuracy, completeness, or consistency with other inputs, or when any input is accepted without proper validation. This vulnerability can also occur if the application fails to validate input from external sources, such as a web API, or data from a database.",
      "vulnerable_code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t//Get user input\n\tuserInput := 0\n\tfmt.Print(\"Please enter a number: \")\n\tfmt.Scan(&userInput)\n\n\t//Do something with user input\n\tfmt.Println(\"You entered: \", userInput)\n}\n\n//This code is vulnerable to CWE-020, because it does not validate the input of the user. A malicious user may enter a string instead of a number, which can cause unexpected behavior in the program.",
      "remediation": "// Remediation example\n\nfunc validateInput(input string) bool {\n\tif input == \"\" || len(input) > 256 {\n\t\treturn false\n\t}\n\n\t// Use a whitelist of accepted characters\n\tvalidChars := \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"\n\tfor _, char := range input {\n\t\tif !strings.Contains(validChars, string(char)) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Perform additional checks, if necessary\n\t// ...\n\n\treturn true\n}",
      "semgrep_rule": "rule = {\n\tmeta:\n   \t\tseverity = \"CRITICAL\"\n   \t\tdescription = \"Improper input validation vulnerability detected\"\n\tsource:\n    \t\tlang = \"go\"\n\tpattern: |\n    \t\t$param := param(\"*\")\n    \t\t!validate($param)\n}",
      "codeql_rule": "import cwe020\nimport Go\n\nclass VulnerableInputValidation extends Go.Expr {\n    Go.CallExpr callExpr\n    Go.BasicLit basicLit\n}\n\nclass Vulnerability extends VulnerableInputValidation  {\n    // CodeQL does not yet support building string literals,\n    // so we cannot check for the exact strings that indicate\n    // unsafe input validation.\n    // Instead, this rule will raise an alarm if input validation is \n    // not present in a function call.\n    exists(Go.CallExpr call) {\n        callExpr = call\n        not exists(Go.BasicLit basic)\n        // We don't want to raise an alarm for this type of basic literal\n        not basic.val == \"nil\"\n    }\n}\n\nfrom Vulnerability vuln, Go.CallExpr call, Go.Func"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "CWE-078, also known as OS Command Injection, is a vulnerability that occurs when an attacker is able to inject malicious commands into an application. This vulnerability is often exploited to gain access to a system or network, allowing an attacker to execute remote code or even modify system files. The vulnerability arises when the application does not properly validate or sanitize user input, allowing malicious code to be executed without the user's knowledge. This can be done via malicious scripts, command-line arguments, environment variables, and other methods. If successful, the attack can allow the attacker to gain access to sensitive data, control the application, or even take control of the system.",
      "vulnerable_code": "package main\n\nimport (\n  \"fmt\"\n  \"os\"\n)\n\nfunc main() {\n  // Get the user input\n  userInput := os.Args[1]\n  \n  // Run the command with the user input\n  result, err := exec.Command(\"/bin/bash\", \"-c\", userInput).Output()\n  if err != nil {\n    fmt.Println(err)\n  }\n  \n  fmt.Println(string(result))\n}",
      "remediation": "// Remediation example\nfunc executeCommand(command string) (string, error) {\n\t// Use cmd.StrictQuote to sanitize the command string\n\targs := cmd.StrictQuote(command)\n\n\t// Use exec.Command to execute the command\n\tcmd := exec.Command(args[0], args[1:]...)\n\n\t// Use StdoutPipe to capture the output\n\tout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Start the command\n\tif err := cmd.Start(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Read the output\n\tbuf := new(bytes.Buffer)\n\tif _, err := io.Copy(buf, out); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Wait for",
      "semgrep_rule": "rule = {\n    id: \"CWE-078-OS-Command-Injection\",\n    patterns: [{\n        pattern: \"exec(\\\"{{$CMD}}\\\")\",\n        message: \"Potential OS Command Injection vulnerability detected\",\n        languages: [\"Go\"],\n    }],\n}",
      "codeql_rule": "import os\n\nfrom BaseQuery import BaseQuery\n\nclass CWE078_OSCommandInjection(BaseQuery):\n\tdef __init__(self):\n\t\tself.description = \"Detects OS command injection\"\n\t\tself.query = \"\"\"import Go\n\nlet cmd := __OS_Command__\nlet inputs := __Data_Flow__.dataFlowsTo(cmd)\n\ninputs.hasAny(inp | inp.hasValueOfType(Go.String) and\n    cmd.contains(inp.asExpr()))\"\"\"\n\n\tdef validate(self, query_result):\n\t\treturn len(query_result) > 0"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089 is an SQL injection vulnerability that occurs when a malicious user is able to execute arbitrary SQL code on a vulnerable system. This type of attack can be used to gain access to sensitive data, modify existing data, or even delete data from the system. This can be accomplished by inserting special characters or keywords into a web form, URL parameter, or other user input field. If the application fails to properly sanitize and neutralize this input, the malicious user can gain access to the system's SQL database and run arbitrary code.",
      "vulnerable_code": "import \"database/sql\"\n\nfunc main() {\n\tdb, _ := sql.Open(\"mysql\", \"user:password@/dbname\")\n\tdefer db.Close()\n\n\t// Vulnerable code\n\tvar username string\n\terr := db.QueryRow(\"SELECT user FROM users WHERE id = \" + username).Scan(&username)\n\tif err != nil {\n\t\t// Handle error\n\t}\n}\n\nThe code above is vulnerable to SQL injection as the value of the username variable is directly concatenated to the SQL query without being properly escaped or parameterized. This can allow an attacker to craft a malicious input that modifies the intended query and, as a result, access or modify data in the database.",
      "remediation": "// Before Remediation\nquery := \"SELECT * FROM products WHERE productID = \" + id\n\n// After Remediation\n// Use prepared statement\nquery := \"SELECT * FROM products WHERE productID = ?\"\nstmt, err := db.Prepare(query)\nif err != nil {\n    return err\n}\ndefer stmt.Close()\n\n// Execute query with id as parameter\nrows, err := stmt.Query(id)\nif err != nil {\n    return err\n}\ndefer rows.Close()",
      "semgrep_rule": "rule = {\n    strings:\n      $sqlQuery = /.*/\n    condition:\n      $sqlQuery\n}",
      "codeql_rule": "import cwe089\n\nclass CWE089SQLInjectionRule extends Rule {\n  CWE089SQLInjectionRule() {\n    super(\"CWE-089-SQL-Injection-Rule\");\n  }\n\n  @Override\n  Query query() {\n    // Finds functions that accept user input as a parameter and are used to create an SQL query\n    MethodCall[] mcs =\n      MethodInvocation.all()\n      .withReceiver()\n      .select(mci => mci.getMethodName().matches(\"execute|query|prepare|open\"))\n      .where(mci =>\n        // Checks that user input is used as a parameter\n        mci.getArgument(0).any(f => UserInput.matches(f))\n        // Checks that the return type of the method is a query\n        && Query.matches(mci.getMethod"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path traversal is a type of security vulnerability which occurs when an attacker is able to use directory traversal characters such as \"../\" to access files and directories that are outside of the intended directory. This can allow the attacker to gain access to sensitive files and data, execute malicious code, or even delete files. In Go, a path traversal vulnerability can occur when an application does not properly restrict access to files and directories, allowing the attacker to access files and directories outside of the intended application directory.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfileName := r.URL.Query().Get(\"file\")\n\t\tdata, err := ioutil.ReadFile(fileName)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(w, \"Unable to read file: %s\", fileName)\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprintf(w, string(data))\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nThis code is vulnerable to Path Traversal because it does not check to see if the fileName",
      "remediation": "In Go, path traversal can be prevented by properly sanitizing user input.\n\nFor example, if a user is allowed to provide a file path, one can use the filepath.Clean() function to ensure that the file path is within the specific directory that the application allows.\n\nFor example:\n\nfunc sanitizePath(userPath string) string {\n\treturn filepath.Clean(userPath)\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-022-detection\",\n  patterns: [\n    {\n      pattern: \"os.Chdir(`$DIR`)\",\n      message: \"Potential Path Traversal vulnerability detected!\",\n      severity: \"WARNING\",\n    },\n  ],\n  languages: [\"Go\"],\n}",
      "codeql_rule": "import cwe022\n\nclass PathTraversalVulnerability(cwe022.Vulnerability):\n    // Rule to detect improper limitation of a pathname to a restricted directory\n    // (CWE-022)\n\n    // Find file operations that take user input as a parameter\n    private FileOperation readFileOperation\n    private FileOperation writeFileOperation\n\n    // Find user input that is used as a parameter for file operations\n    private Expression userInput\n\n    // Find folders that are restricted for file operations\n    private Expression restrictedFolder\n\n    // Find function calls that have user input parameters\n    FileOperation.call(userInput) => readFileOperation, writeFileOperation {\n        \n        // Find file operations with restricted folder as a parameter\n        FileOperation.call(restrictedFolder) => readFileOperation, writeFileOperation {\n            // Flag if user input is used as a parameter for a file operation in a restricted folder"
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site Request Forgery (CSRF) is a type of vulnerability in which an attacker can send a malicious request to a web application on behalf of a user. The malicious request could be used to perform an action that the user did not intend to perform, such as transferring money or changing a password. This vulnerability can be exploited by an attacker who tricks a user into clicking on a malicious link or opening a malicious attachment. The malicious request will then be sent to the web application, and the application will execute the request without the user's knowledge or consent. In Go, CSRF vulnerabilities can be mitigated by using anti-CSRF tokens, which are randomly generated strings that are sent to the client and used to verify the validity of the request.",
      "vulnerable_code": "package main\n\nimport (\n\t\"net/http\"\n\t\"fmt\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"POST\" {\n\t\t\t// Process the POST request\n\t\t\t// Here is the vulnerability\n\t\t\tfmt.Fprintln(w, \"POST request processed\")\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nThis code is vulnerable to CSRF because it does not check for a valid CSRF token before processing the POST request.",
      "remediation": "One way to remediate Cross-Site Request Forgery (CSRF) vulnerabilities in Go is to use CSRF tokens. These tokens are generated randomly and are stored in the server\u2019s session. When the client sends a request to the server, the server validates the CSRF token before processing the request. \n\n// Generate a CSRF token\nfunc generateCsrfToken() string {\n\t// Generate a random string\n\tb := make([]byte, 32)\n\trand.Read(b)\n\treturn base64.StdEncoding.EncodeToString(b)\n}\n\n// Store the CSRF token in the server\u2019s session\nfunc setCsrfToken(r *http.Request) {\n\tcsrfToken := generateCsrfToken()\n\tsession, _ := store.Get(r, \"session\")\n\tsession.Values[\"csrf_token",
      "semgrep_rule": "rule = \n    forall $req, $resp:\n        http.request($req) and\n        http.response($resp) and\n        $req.method == \"POST\" and\n        not $resp.header[\"X-CSRF-Token\"]\n       \n    =>\n        message = \"Possible Cross-Site Request Forgery (CSRF) vulnerability detected. Missing X-CSRF-Token header in response.\"\n        severity = \"WARNING\"",
      "codeql_rule": "import cwe352\n\nclass CWE352_CSRF_Vulnerability:\n    def __init__(self):\n        self.vuln_functions = [\n            \"http.PostForm\",\n            \"http.Get\",\n            \"http.Post\",\n            \"http.Put\"\n        ]\n        self.anti_csrf_headers = [\"X-CSRF-Token\",\"X-XSRF-Token\",\"X-Requested-With\"]\n   \n    def vulnerable(self, call):\n        if call.getFunctionName() in self.vuln_functions:\n            for header in self.anti_csrf_headers:\n                if not call.hasArgument(header):\n                    return True\n        return False\n\nfrom CWE352_CSRF_Vulnerability import CWE352_CSRF_Vulnerability\n\nclass CWE352_CS"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a vulnerability that occurs when a web application allows unrestricted upload of files with dangerous types, such as executable files (.exe), to the server. This allows attackers to upload malicious code that can be used to exploit the system, bypass security measures, and gain unauthorized access. The vulnerability can be exploited by an attacker who is able to upload malicious files to the server, thus bypassing any security measures that may have been put in place.",
      "vulnerable_code": "package main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/upload\", uploadHandler)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\t// Unrestricted Upload of File with Dangerous Type\n\tif r.Method == \"POST\" {\n\t\tf, _, err := r.FormFile(\"file\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\n\t\t// Unrestricted File Upload - could be malicious\n\t\tfname := \"./uploaded_file\"\n\t\tout, err := os.Create(fname",
      "remediation": "One way to remediate this vulnerability is to limit the types of file uploads that are allowed and validate the files to ensure they are what they claim to be. For example, you could check the file extension and ensure it matches the expected file type. Additionally, you could implement a whitelisting approach to only allow files of certain types. You could also require a review of the file before it is uploaded or impose a maximum file size limit on the uploads.",
      "semgrep_rule": "rule = {\n\tid: \"CWE-434-unrestricted-upload-of-file-with-dangerous-type\",\n\tseverity: \"error\",\n\tmetadata: {\n\t\tdescription: \"Detects the unrestricted upload of a file with a dangerous type\",\n\t\treferences: [\"https://cwe.mitre.org/data/definitions/434.html\"]\n\t},\n\tpattern: statements: [{\n\t\tlhs: {\n\t\t\t// Match a function call to an upload function\n\t\t\t// with a file type that is restricted\n\t\t\tfunction_calls: [{\n\t\t\t\tid: /upload/\n\t\t\t}, {\n\t\t\t\targuments: [{\n\t\t\t\t\ttype: /(exe|bat|js|cmd|vbs|sh)/\n\t\t\t\t}]",
      "codeql_rule": "import sys\n\nclass CWE_434:\n    def __init__(self):\n        self.vulnerability_name = \"CWE-434: Unrestricted Upload of File with Dangerous Type\"\n\n    def vulnerable_file_types(self):\n        return [\".exe\", \".dll\", \".bat\", \".com\", \".vbs\", \".js\", \".reg\", \".cmd\"]\n\n    def detect(self, file):\n        for vulnerable_file_type in self.vulnerable_file_types():\n            if file.endsWith(vulnerable_file_type):\n                return True\n        return False\n\nclass CWE_434_Rule(CodeQL):\n    def __init__(self):\n        self.vulnerability = CWE_434()\n        self.query = \"\"\"\n            import File\n            import FileSystem\n            import Path\n\n            class FileUpload {\n                File file"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306 is a vulnerability that occurs when a critical function, such as access to sensitive data or a critical system process, does not require authentication. This means that anyone can access the function without having to provide any credentials. This can lead to a wide range of security issues, from unauthorized access to data and system processes, to even malicious code being executed on the system.",
      "vulnerable_code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\t// This function allows a user to delete a file without authentication.\n\tdeleteFile := func(fileName string) {\n\t\tfmt.Println(\"Deleting file\", fileName)\n\t\t// Delete file code here\n\t}\n\n\t// Call the deleteFile function\n\tdeleteFile(\"my_file.txt\")\n}",
      "remediation": "The first step in remediation for CWE-306 is to ensure that all critical functions require authentication. This can be done by implementing an authentication system such as OAuth 2.0, which provides a secure way for users to authenticate their identity. Additionally, any sensitive data should be encrypted and stored in a secure database or file system. Additionally, access control should be implemented to ensure that only authorized personnel can access the data. Finally, a logging system should be implemented to track any access attempts and to detect any possible malicious activities.",
      "semgrep_rule": "rule = {\n    strings:\n    $function1 = /(?i)function\\s+\\w+\\s*\\(/\n    $function2 = /(?i)function\\s+\\w+\\s*\\(\\s*[^)]*\\s*auth\\s*=\\s*false/\n    condition: all of them\n}\n\nimpact: critical\nmessage: \"Critical function missing authentication\"",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.security.Argument\n\nclass Vulnerability_CWE_306 extends SecurityHardcoded {\n    predicate vulnerable(Argument arg) {\n        arg.getFunction() instanceof cwe.MissingAuthenticationForCriticalFunction and\n        arg.getValue().isHardcoded()\n    }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability relating to the deserialization of untrusted data. This vulnerability occurs when data is deserialized from an untrusted source and can lead to malicious code execution. This is particularly dangerous when the data is deserialized into an executable language such as Go, as the malicious code can be executed directly by the program. To protect against this vulnerability, developers should always validate all data received from untrusted sources before deserializing it.",
      "vulnerable_code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\n\t//untrusted data\n\tuntrustedData := `{\"Name\":\"Bob\",\"Age\":30}`\n\n\t// Unmarshal the untrusted data\n\tvar user map[string]interface{}\n\tjson.Unmarshal([]byte(untrustedData), &user)\n\n\tfmt.Println(user)\n}",
      "remediation": "The following example shows how to use the Go encoding/json package to safely unmarshal JSON data from a trusted source:\n\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t// Define a struct to hold the data.\n\ttype Data struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\t// Unmarshal the JSON data into the struct.\n\tvar data Data\n\terr := json.Unmarshal([]byte(`{\"Name\":\"John Doe\",\"Age\":42}`), &data)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Print the result.\n\tfmt.Printf(\"Name: %s, Age: %d\", data.Name, data.Age)\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-502-deserialization-of-untrusted-data\",\n  patterns: [\n    {\n      pattern: 'encoding/gob.NewDecoder(io.Reader)',\n      message: 'Potential deserialization of untrusted data'\n    }\n  ]\n}",
      "codeql_rule": "import go\n\nclass DeserializationVulnerability extends Vulnerability {\n  // Declare the class of the vulnerability\n  let kind = \"deserialization-vulnerability\"\n  \n  // Construct a query to find vulnerable code\n  query vulnerableCode {\n    // Find calls to functions or methods which deserialize untrusted data\n    deserializeCall as call where deserializeCall.getTarget().matches(\"*\") \n    \n    // Find the untrusted data being deserialized\n    untrustedData as var where untrustedData.valueOf() = deserializeCall.getArgument(0) \n    \n    // Find the source of the untrusted data\n    untrustedDataSource as decl where untrustedData.isInitializedBy(untrustedDataSource) \n    \n    // Find sources of untrusted data which are not trusted"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287: Improper Authentication is a vulnerability that occurs when authentication controls are not properly implemented in a software application. This can lead to an attacker being able to access the application with unauthorized credentials, or a user being able to access the application without proper authentication. In Go, this can occur if a developer does not properly validate user input or does not enforce secure authentication methods. Attackers can exploit this vulnerability to gain unauthorized access to data or resources.",
      "vulnerable_code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tusername := \"admin\"\n\tpassword := \"\"\n\n\tif username == \"admin\" && password == \"password\" {\n\t\tfmt.Println(\"Welcome Admin!\")\n\t} else {\n\t\tfmt.Println(\"Access Denied\")\n\t}\n}\n\nIn the above code, the authentication is improper because there is no validation of the password input, meaning any user can gain access by simply providing the username \"admin\" without a password.",
      "remediation": "The most effective way to remediate CWE-287 is to implement strong authentication methods. This includes using two-factor authentication (2FA) or multi-factor authentication (MFA) when users log in. This means that users will be required to provide at least two pieces of evidence in order to authenticate, such as a username and a password, or a username and a one-time code sent to their phone. Additionally, organizations should implement strong password policies, such as requiring passwords of a certain length and complexity. Finally, organizations should also implement regular checks to ensure that users are not sharing their credentials with others.",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tdescription = \"Detects improper authentication\"\n\t\tauthor = \"Your Name\"\n\t\tdate = \"2020-08-10\"\n\tsource: \n\t\tlanguage = \"Go\"\n\t\texclude = [\"vendor/*\"]\n\t\tinclude = [\"*.go\"]\n\t\t\n\tconstant:\n\t\tlogin = [\"authenticate\", \"log in\", \"logon\", \"sign in\", \"signon\"]\n\t\tnoAuth = [\"without authentication\", \"unauthenticated\",]\n\t\t\n\tdetection:\n\t\tany_call:\n\t\t\tpatterns:\n\t\t\t\t- pattern: \"{login}({noAuth})\"\n\t\t\t\t  message: \"Improper authentication detected\"\n\t\t\t\t  confidence: high\n\t\t\t\t  severity: critical",
      "codeql_rule": "import cwe287\n\nclass ImproperAuthenticationDetector {\n    // Checks for insecure authentication mechanisms\n    vulnerabilty pattern ImproperAuthentication {\n        // Identify calls to authentication functions with weak parameters\n        AuthenticationMechanism(p)\n        where p.isWeak()\n    }\n\n    // Reports instances of weak authentication\n    from ImproperAuthentication\n    report(\"Weak authentication mechanism detected at line @{line}\")\n}"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability where a developer has hard-coded credentials into a program. This means that the credentials are stored in the program's source code, rather than being stored in an external repository where they can be changed or updated. This can leave the system vulnerable to attack, as the credentials could be used to access the system or its data without proper authorization. As well, hard-coded credentials can be difficult to change or update if necessary, making the system even more vulnerable.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Welcome!\")\n\t})\n\n\t// Hardcoded credentials\n\tusername := \"admin\"\n\tpassword := \"password123\"\n\n\thttp.ListenAndServe(\":8080\", nil)\n}",
      "remediation": "// Before Remediation\nusername := \"admin\"\npassword := \"password\"\n\n// After Remediation\n// Read credentials from environment variables\nusername := os.Getenv(\"USERNAME\")\npassword := os.Getenv(\"PASSWORD\")",
      "semgrep_rule": "rule = {\n  id: \"CWE-798-hardcoded-credentials\",\n  patterns: [\n    {\n      pattern: 'password=\"(.*?)\"',\n      message: \"Hard-coded credentials detected\",\n      severity: \"WARNING\"\n    }\n  ]\n}",
      "codeql_rule": "import go\n\nclass HardCodedCredentials extends Query {\n  predicate isHardCodedCreds(s: string) {\n    s contains(\"username\") or\n    s contains(\"password\")\n  }\n\n  predicate isLiteralString(e: Expr) {\n    e instanceof go.StringLiteral\n  }\n\n  predicate isHardCodedCredsLiteral(e: Expr) {\n    isLiteralString(e) and isHardCodedCreds(e.value)\n  }\n\n  predicate isCredsPassedToAPI(f: Function, e: Expr) {\n    f.name = \"api\" and\n    f.hasParameter(\"username\") and\n    f.hasParameter(\"password\") and\n    f.calls(e)\n  }\n\n  // Vulnerability detect\n  vulnerability as V"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "The CWE-276 vulnerability is caused by granting permissions to a file or resource that are too broad. This allows any user to access the resource without the proper credentials or authorization. This can result in unauthorized users having access to files or resources that should be restricted, leading to a potential security breach. Additionally, this could allow malicious users to modify or delete files, or access sensitive data.",
      "vulnerable_code": "package main \n\nimport \"os\"\n\nfunc main() {\n\n  //This is vulnerable code since it creates a file with default permissions of 0666\n  f, err := os.Create(\"test.txt\")\n  if err != nil {\n    panic(err)\n  }\n  defer f.Close()\n}",
      "remediation": "Remediation for this vulnerability would involve setting the appropriate permissions for any files or directories that have been set with incorrect default permissions. This can be accomplished by using the chmod command. For example, if a directory needs to have read, write, and execute permissions for the owner, execute permissions for the group, and no permissions for other users, the command would be:\n\nchmod 750 /path/to/directory",
      "semgrep_rule": "rule = {\n  strings: $file_create = /open\\s*\\(.*,\\s*os\\.O_CREATE/\n  condition: $file_create\n  message: \"Incorrect default permissions on file creation detected\"\n  severity: \"warning\"\n}",
      "codeql_rule": "import go\n\nclass BadPermissions extends GoChecker {\n  // Rule to detect incorrect default permissions set on files or directories\n  predicate isWrongPerm(f File) {\n    exists(p : Permission | p.file == f && p.hasPerm != 0644)\n  }\n  \n  // This predicate will detect any files or directories with incorrect permissions\n  predicate findBadPermissions() {\n    exists(f : File | isWrongPerm(f))\n  }\n  \n  // Check for the wrong permission\n  checkers {\n    // Check for incorrect default permissions\n    check findBadPermissions()\n      description(\"Check if incorrectly set default permissions have been found.\")\n      hasProblem\n  }\n}"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that exposes sensitive information to an unauthorized actor. This vulnerability can occur when an application does not have proper authentication and authorization controls in place. An attacker can then gain access to this sensitive information, which can lead to data breaches, identity theft, and more. Sensitive information can include passwords, credit card numbers, and other personal data. To mitigate this vulnerability, organizations should implement strong authentication and authorization controls to ensure that only authorized users can access sensitive information.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tusername := r.URL.Query().Get(\"username\") // Vulnerable code\n\t\tpassword := r.URL.Query().Get(\"password\")\n\t\t\n\t\tfmt.Fprintf(w, \"Username: %s\\nPassword: %s\", username, password)\n\t})\n\t\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nThis code is vulnerable because it is passing the username and password in plaintext in the URL query string. This means that the username and password can be captured by anyone who is monitoring the network traffic, which is an unauthorized actor.",
      "remediation": "The best way to remediate this vulnerability is to ensure that sensitive information is only accessible to authorized users. This can be done by implementing robust authentication protocols, such as two-factor authentication, and enforcing strong passwords. Additionally, data should be encrypted whenever possible, and access to sensitive information should be restricted to only those who need it. Finally, regular audits should be performed to ensure that the access controls are still in place and working correctly.",
      "semgrep_rule": "rule = {\n  id: \"CWE-200-exposure-of-sensitive-information\",\n  patterns: [\n    {\n      pattern: \"* := * <- *\",\n      message: \"Access of sensitive information without proper authorization\",\n      severity: \"warning\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe200\n\nclass CWE_200_Vulnerability:\n\t// Matches if a sensitive data is exposed to an unauthorized actor\n\t// via a function call\n\t@Cwe200\n\tpredicate isVulnerable(funcName, dataName){\n\t\tExpr.call(funcName) and Expr.member(dataName) and \n\t\t!Authorization.authorized(dataName)\n\t}\n}"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 is a vulnerability that occurs when credentials or other security-critical data is stored in a manner that allows it to be accessed by unintended parties. This can occur when credentials are stored in plain text or with insufficiently strong encryption, or if authentication systems are not sufficiently secure. Attackers can gain access to these credentials, potentially allowing them to access sensitive information or carry out malicious actions.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tusername := \"admin\"\n\tpassword := \"password123\" // This password is insufficiently protected\n\n\tfmt.Println(\"Username:\", username)\n\tfmt.Println(\"Password:\", password)\n}",
      "remediation": "One remediation approach for CWE-522 is to ensure that all credentials used to access sensitive data are encrypted. This can be done by using encryption libraries and secure protocols when storing, transmitting, and receiving credentials. Additionally, any user-generated passwords should be hashed using a secure algorithm before being stored in the database. Finally, access to credentials should be restricted to only those who absolutely need it.",
      "semgrep_rule": "rule = {\n  id: \"CWE-522-Insufficiently-Protected-Credentials\",\n  patterns: [\n    // matches hardcoded credentials\n    pattern: \"const %{var:credential} = %{string:value}\",\n    // matches credentials in plaintext\n    pattern: \"var %{var:credential} = %{string:value}\",\n    // matches credentials stored in plaintext\n    pattern: \"storage.%{var:credential} = %{string:value}\"\n  ],\n  message: \"CWE-522: Insufficiently Protected Credentials found in {{$credential}}\",\n  severity: \"CRITICAL\"\n}",
      "codeql_rule": "import Go\nimport Security\n\nclass InsufficientlyProtectedCredentials extends Go.CallGraph {\n  Expr authFunction\n  \n  predicate isAuthFunction(Function f) {\n    f.hasAnnotation(\"auth\")\n  }\n  \n  InsufficientlyProtectedCredentials() {\n    authFunction := this.getFunction(\"auth\")\n  }\n  \n  // Checks if a variable is hardcoded\n  predicate isHardcodedCredential(Expr e) {\n    e.isLiteral() or e.isStringLiteral()\n  }\n  \n  // Checks if a variable is passed as a parameter\n  predicate isParameterCredential(Expr e) {\n    e.isParameter()\n  }\n  \n  // Checks if a variable is stored in a global variable\n  predicate isGlobalCredential(Expr e) {"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability that occurs when an application parses XML input without properly restricting the ability of malicious actors to reference external entities. This can allow attackers to gain access to sensitive system files, or cause denial-of-service attacks. An attacker can exploit this vulnerability by crafting malicious XML input that contains external entity references, which if left unchecked, can lead to the execution of arbitrary code or disclosure of sensitive information.",
      "vulnerable_code": "package main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\nfunc main() {\n\turl := \"http://example.com/data.xml\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Vulnerable code\n\t// XML external entity reference\n\tvar v struct {\n\t\tXMLName xml.Name\n\t\tData    string `xml:\"data\"`\n\t}\n\tif err := xml.",
      "remediation": "The most effective way to prevent XML External Entity (XXE) attacks is to disable the processing of external entities altogether. This can be done by setting the XML parser's \"resolveExternalEntities\" option to false. For example, in Go's xml package, this can be done as follows:\n\ndecoder := xml.NewDecoder(r)\ndecoder.ResolveEntity = func(publicID, systemID string) (xml.Entity, error) {\n    return nil, fmt.Errorf(\"XXE disabled\")\n}",
      "semgrep_rule": "rule = {\n\tid: \"CWE-611-XML-External-Entity-Reference\",\n\tpattern: \"xml.Unmarshal(data)\",\n\tmessage: \"Improper Restriction of XML External Entity Reference (CWE-611)\",\n\tseverity: \"warning\"\n}",
      "codeql_rule": "import cwe\nimport go\n\nclass Vuln_CWE_611 : go.GoCheck {\n \n  // Checks for XML documents that are parsed by the Go language\n  // and that contain an external entity reference\n  predicate isXMLDoc() {\n    exists(go.FuncCall cal | \n      cal.getTarget().matches(\"encoding/xml.|Unmarshal\")\n    )\n  }\n  \n  // Checks if a given expression contains an external entity reference\n  predicate hasExternalEntityRef(go.Expr e) {\n    exists(go.XmlExpr xml | \n      xml.getKind() = go.XmlExprKind.EntityRef\n      and e = xml.getExpr()\n    )\n  }\n  \n  // Checks if any of the function calls being analyzed contain an external entity reference\n  predicate is"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "CWE-918 is a type of vulnerability that occurs when an application makes a server-side request to a URL or file that is outside of its control. The malicious request can be used to access resources that the application should not have access to, such as internal network services or other applications. This vulnerability can be exploited to gain unauthorized access to data, or to cause a denial of service.",
      "vulnerable_code": "package main\n\nimport (\n    \"net/http\"\n    \"log\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    // Read in the contents of a URL \n    resp, err := http.Get(\"http://example.com\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    defer resp.Body.Close()\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(string(body))\n}\n\nThe code above is vulnerable to Server Side Request Forgery (SSRF) because it does not validate the URL supplied by the user, allowing them to request arbitrary URLs. This could be exploited to access internal services that should not be publicly exposed.",
      "remediation": "1) Implement a whitelist of allowed IP addresses and/or domains to limit requests to known, trusted sources.\n2) Use parameterized requests to ensure that requests cannot be modified in transit.\n3) Perform input validation and output encoding to mitigate against malicious payloads.\n4) Implement rate limiting to reduce the likelihood of brute-force attacks.\n5) Monitor logs for suspicious requests.\n6) Utilize web application firewalls to block malicious requests.",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"CWE-918: Server-Side Request Forgery (SSRF)\"\n      author = \"Semgrep\"\n    strings:\n      $url = /[a-zA-Z]+:\\/\\/[a-zA-Z0-9:._~%#?&=+/-]+/\n    condition:\n      $url\n}",
      "codeql_rule": "import cwe_918\n\nclass SSRFVulnerability(cwe_918.Vulnerability):\n    def __init__(self):\n        cwe_918.Vulnerability.__init__(self)\n\n    def predicate(self, q):\n        return q.FindFunction(\"http.NewRequest\").HasCall(\"net/http.Client.Do\")"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a type of vulnerability that allows attackers to inject malicious commands into a program or system. This can be done by manipulating user input and sending it to a program or system in a way that it is executed as a command. This can lead to data being compromised or malicious code being executed. It is considered a serious security risk and should be addressed as soon as possible.",
      "vulnerable_code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tuserInput := \"\"\n\tfmt.Print(\"Please enter a command: \")\n\tfmt.Scan(&userInput)\n\t\n\t// Vulnerable code:\n\tresult := exec(userInput)\n\tfmt.Println(result)\n}\n\nfunc exec(command string) string {\n\t// Execute command here\n}",
      "remediation": "// Before remediation\ncommand := fmt.Sprintf(\"run cmd %s\", userInput)\nexec.Command(command)\n\n// After remediation\ncommand := fmt.Sprintf(\"run cmd %s\", sanitize(userInput))\nexec.Command(command)\n\n// Function for sanitizing user input\nfunc sanitize(input string) string {\n    // Replace all special characters with a space\n    return strings.ReplaceAll(input, \"[^a-zA-Z0-9]\", \" \")\n}",
      "semgrep_rule": "rule = {\n  id: \"CWE-077\",\n  patterns: [\n    {\n      pattern: \"exec(\\\"${{param}}\\\")\",\n      message: \"Potential command injection detected\",\n      severity: \"WARNING\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe077\n\nclass CWE_077_Command_Injection:\n  string command\n \n  // Find any command-executing functions that are passed user-controlled inputs\n  // without proper sanitization\n  query command_injection_sources {\n    Call c\n    CommandExecution cce\n    cce.targets(c)\n    c.receiver.type.name = \"os/exec\"\n    c.argument.value.sources(input)\n  }\n \n  // Report issues for sources that are not properly sanitized\n  vulnerability as Vulnerability cwe077.CommandInjection(command_injection_sources, command) {\n    message = \"Command injection vulnerability detected.\"\n  }\n}"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295 is an improper certificate validation vulnerability that occurs when an application fails to properly validate the authenticity and validity of digital certificates. This type of vulnerability can allow an attacker to bypass authentication or encryption using a malicious, invalid, or self-signed digital certificate. It can also allow an attacker to impersonate a valid user or service by using a valid digital certificate. This vulnerability can be particularly dangerous when used in conjunction with a man-in-the-middle attack.",
      "vulnerable_code": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\t// Create an insecure client\n\tclient := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t}\n\n\t// Make a request to an HTTPs endpoint\n\tresp, err := client.Get(\"https://example.com\")\n\tif err != nil {\n\t\tfmt.Println(\"Error making request:\", err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Print the response\n\tfmt.Println(resp)\n}\n\nIn the code above, the client is configured to skip certificate validation. This could",
      "remediation": "// Before:\nresp, err := http.Get(url)\n\n// After:\ntr := &http.Transport{\n    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n}\nclient := &http.Client{Transport: tr}\nresp, err := client.Get(url)",
      "semgrep_rule": "rule = {\n\tid: cwe-295-certificate-validation-vuln,\n\tseverity: error,\n\tpattern: (\n\t\t\t\t(tls | crypto)\\.\n\t\t\t\t(\n\t\t\t\t\tVerifyPeerCertificate |\n\t\t\t\t\tInsecureSkipVerify\n\t\t\t\t)\n\t\t\t),\n\tmessage: \"Insecure certificate validation detected.\"\n}",
      "codeql_rule": "import cwe295\nimport go\n\nclass CWE295_ImproperCertificateValidation implements Rule {\n  // List of packages which should be excluded from analysis\n  // to prevent false positives\n  private static readonly excludedPackages = [\"crypto/x509\"]\n\n  // Finds calls to certificate validation methods\n  private predicate ValidateCertificateCall(Expr node) {\n    return\n      (node instanceof go.CallExpr) and\n      (node.func.name == \"VerifyHostname\" or\n       node.func.name == \"VerifyPeerCertificate\" or\n       node.func.name == \"VerifyCertificate\") and\n      not excludedPackages.contains(node.func.pkg)\n  }\n\n  // Finds declarations of certificates\n  private predicate CertDeclaration(Expr node) {\n    return\n      (node instanceof"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability which occurs when user-supplied input is not properly sanitized, allowing malicious code to be injected into the application. In the context of Go, this vulnerability can occur when user-supplied input is passed to functions like exec.Command() or template.Execute() without proper validation, allowing the attacker to inject malicious code into the application. This can lead to the application executing arbitrary code, resulting in a serious security breach.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\turl := r.URL.Query().Get(\"url\")\n\t\texecCommand := \"curl \" + url\n\t\tfmt.Println(execCommand)\n\t\tfmt.Fprintln(w, execCommand)\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nIn this example, the application is vulnerable to code injection. The application is taking an input from the URL query parameter \"url\" and executing a curl command with that input. If an attacker is able to craft an appropriate input, they can inject malicious code into the application.",
      "remediation": "// Remediation example\n\npackage main\n\nimport (\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Get user input\n\tinput := os.Args[1]\n\t\n\t// Sanitize user input to avoid code injection\n\tsafeInput := strings.ReplaceAll(input, \";\", \"\")\n\t\n\t// Pass safe input to the program\n\t// ...\n}",
      "semgrep_rule": "rule = {\n    strings:\n        $cmd = /.*/\n    condition:\n        $cmd\n}",
      "codeql_rule": "import cwe094\n\nclass CWE094Rule extends Rule {\n    // Rule definition\n    meta {\n        // Rule metadata\n        // The following example is for a rule that detects CWE-094\n        // Improper Control of Generation of Code ('Code Injection')\n        // For more information, see https://cwe.mitre.org/data/definitions/94.html\n        id = \"CWE-094\"\n        description = \"Improper Control of Generation of Code (Code Injection)\"\n        author = \"Example company\"\n        severity = Severity.CRITICAL\n        references = [\"https://cwe.mitre.org/data/definitions/94.html\"]\n    }\n    \n    // Query definition \n    predicate isInjection(stmt: Statement) {\n        // Statement is considered a code injection if it is an invocation of an"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 is a type of vulnerability related to improper privilege management. It occurs when an application fails to properly manage user privileges, allowing users with lower privileges to access or modify data or files that should be restricted to users with higher privileges. This could include allowing users to modify system files, access confidential data, or perform other actions that should not be allowed by their user level.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc main() {\n\tcmd := exec.Command(\"/bin/sh\", \"-c\", `cat /etc/shadow`)\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(string(output))\n}\n\nIn this code, the application is executing a command as a privileged user without proper authentication or authorization, allowing users with access to the application to gain unauthorized access to privileged files.",
      "remediation": "One example of remediation for CWE-269 would be to ensure that the privileges assigned to each user are tailored to the user's specific job duties. For example, if a user only needs to access certain files, they should only be granted access to those specific files instead of being given general administrative privileges. Additionally, any unused privileges should be revoked and access control lists should be set up to ensure that only authorized users can access the system.",
      "semgrep_rule": "rule = \"\n\nimport \"syscalls\"\n\nsyscall.setgid as x\n\n+\n\nsyscall.setuid as y\n\n-\n\nsyscall.setresgid as z\n\n\"\nmessage = \"Improper privilege management detected: using setgid and setuid without using setresgid\"\nseverity = \"warning\"",
      "codeql_rule": "import cwe269\n\nclass CWE269ImproperPrivilegeManagement:\n    // Detects code where an application mismanages user privileges\n    // to perform an action that should only be available to certain \n    // users or processes.\n    //\n    // The rule flags functions that grant access or privileges to \n    // users or processes without proper checks.\n    def vulnerable_functions():\n        // Retrieves functions that grant access or privileges\n        // to users or processes.\n        return cwe269.getVulnerableFunctions()\n    \n    def vulnerable_code():\n        // Retrieves vulnerable code from the functions\n        // identified above.\n        return cwe269.getVulnerableCode()\n    \n    // Flags code that is vulnerable to CWE-269\n    vulnerable_code() {\n      message(\"Improper privilege management detected\")\n    }"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is a type of injection vulnerability which occurs when an application fails to properly validate or neutralize special elements used in an expression language statement. It allows an attacker to inject malicious code into an application or system which can be used to manipulate or extract data from the system. This vulnerability is particularly dangerous as it can be used to inject malicious code with access to sensitive information.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Vulnerable code\n\t\tqueryParam := r.URL.Query().Get(\"username\")\n\t\tfmt.Fprintf(w, \"Hello %s!\", queryParam)\n\t})\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nIn this example, the code is vulnerable to Expression Language Injection because it is directly using the query parameter, `queryParam`, in the `fmt.Fprintf` call without properly sanitizing the input. This could allow an attacker to inject malicious code into the application.",
      "remediation": "In Go, the most common way to remediate Expression Language Injection vulnerabilities is to use the html.EscapeString() function. This function takes a string as an argument and returns a string where any special characters have been replaced with their HTML escaped equivalents. \n\nFor example, suppose a user input is stored in a variable called \"userInput\". To prevent expression language injection, the following code should be used:\n\nescapedUserInput := html.EscapeString(userInput)",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Detects potential Expression Language Injection\"\n      severity = \"CRITICAL\"\n    source:\n      language = \"go\"\n    patterns:\n      - pattern: |\n          template.Parse(string)\n        message: \"Potential Expression Language Injection detected\"\n        contexts:\n          - context:\n              source:\n                binary:\n                  function: \"template.Parse\"\n}",
      "codeql_rule": "import cwe917\n\nclass CWE917ExpressionLanguageInjection:\n\t\n\t// Finds suspicious uses of the expression language\n\t// which may be vulnerable to injection\n\t@CWE917\n\t@CxPCQuery(\"CWE917ExpressionLanguageInjection\")\n\tdef getVulnerableExpressions():\n\t\t\n\t\t// Finds suspicious uses of the expression language\n\t\t// which may be vulnerable to injection\n\t\texpr = Find.allExpressions(Go.Expression)\n\t\t\t.where(e | e.isExpressionLanguage())\n\t\t\t\n\t\t// Finds suspicious uses of the expression language\n\t\t// which may be vulnerable to injection\n\t\treturn expr.select(e | e.containingFunction())"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability that occurs when an application fails to properly check the location of a file before accessing it. This can allow an attacker to manipulate the program by redirecting the access to a malicious file, which can be used to exploit the application. This can happen when an application follows a link to a file without validating the link, which can lead to the application accessing a file from an unexpected location.",
      "vulnerable_code": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tpwd, _ := os.Getwd()\n\tfileName := \"../../../../../../etc/passwd\"\n\tfilePath := pwd + fileName\n\tdata, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(string(data))\n}\n\nIn the above example, the code is vulnerable to CWE-059 because the file path used to read the file is not properly normalized, allowing an attacker to navigate outside the intended directory. This can lead to information disclosure, or overwrite of sensitive files.",
      "remediation": "The following code snippet shows an example of remediation for CWE-059. The code checks whether a file is a symbolic link before accessing it to ensure that the link target is safe:\n\n// Check if the file is a symbolic link\nif fi, err := os.Lstat(filePath); err == nil && fi.Mode()&os.ModeSymlink != 0 {\n\t// Resolve the link target\n\tif target, err := os.Readlink(filePath); err == nil {\n\t\t// Check if the link target is safe\n\t\tif isSafeLinkTarget(target) {\n\t\t\t// Access the link target\n\t\t\t// ...\n\t\t}\n\t}\n}",
      "semgrep_rule": "rule = {\n    meta:\n      name = \"CWE-059: Improper Link Resolution Before File Access ('Link Following')\"\n      description = \"Detects attempts to follow links without proper access checks first\"\n      author = \"Your Name\"\n      references = [\"https://cwe.mitre.org/data/definitions/59.html\"]\n      id = \"CWE-059\"\n      severity = \"CRITICAL\"\n      tags = [\"CWE\", \"security\"]\n    source:\n      lang = \"go\"\n    detection:\n      condition: all\n      patterns:\n        - pattern: |\n            os.Open(\n            (\n              (\n                \"|'.*\n              )\n            )\n          message: |\n            Use of os.Open() without proper access checks before following a link.\n          source:\n            - \"**/*.go\"",
      "codeql_rule": "import cwe059 from CWE-059\n\nclass GoImproperLinkResolutionVulnerability implements CodeQLAnalysis {\n  CWE059LinkResolutionIssue() {\n    // Find code that follows a link\n    File f1 = ...;\n    File f2 = f1->followLink();\n   \n    // Find code that accesses the link without verifying its validity\n    if (f2.exists()) {\n      // Trigger a CWE-059 issue\n      cwe059.trigger();\n    }\n  }\n}"
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information is transmitted in plaintext over a network. This means that the data is not encrypted and can be easily intercepted and read by anyone on the network. This type of vulnerability can lead to the theft of confidential data such as passwords, financial information, or other sensitive data. It is important to always encrypt sensitive data before sending it over a network to ensure that it remains secure.",
      "vulnerable_code": "package main\n\nimport (\n    \"net/http\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        username := r.FormValue(\"username\")\n        password := r.FormValue(\"password\")\n\n        // Vulnerable code\n        resp, _ := http.Get(\"http://example.com/login?username=\" + username + \"&password=\" + password)\n    })\n    http.ListenAndServe(\":8080\", nil)\n}\n\nIn this example, the username and password are sent over the network as plaintext, which is vulnerable to interception and can lead to a security breach.",
      "remediation": "The best way to remediate CWE-319 is to encrypt all sensitive information before transmitting it over the network. In Go, this can be done using the crypto/tls package to establish a TLS connection and encrypt the data before sending it. Here's an example of how to do this:\n\n// Create a TLS configuration\ntlsConfig := &tls.Config{\n\tMinVersion: tls.VersionTLS12,\n\tCipherSuites: []uint16{\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_",
      "semgrep_rule": "rule = {\n\tseverity: \"warning\"\n\tpattern: \"http://* || ftp://*\"\n\tmessage: \"Cleartext transmission of sensitive information detected\"\n}",
      "codeql_rule": "import cwe319\n\nclass CWE319_CleartextTransmissionOfSensitiveInfo:\n    // Rule to detect cleartext transmission of sensitive information\n    // as defined in CWE-319\n    // https://cwe.mitre.org/data/definitions/319.html\n   \n    // Get list of sensitive information variables\n    let sensitiveInfo = cwe319.getSensitiveInfo()\n\n    // Get list of functions used to transmit data\n    let transmissionFunctions = cwe319.getTransmissionFunctions()\n\n    // Get list of functions used to encrypt data\n    let encryptionFunctions = cwe319.getEncryptionFunctions()\n\n    // Get list of functions used to decrypt data\n    let decryptionFunctions = cwe319.getDecryptionFunctions()\n\n    // Get list of functions used to check for encryption\n    let encryptionCheckFunctions = cwe"
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601, also known as an Open Redirect vulnerability, is a vulnerability that occurs when an application or website redirects an unsuspecting user to a malicious or untrusted website. This type of vulnerability is often used in phishing attacks to lure users to a malicious website, where they may be asked to enter personal information or be exposed to malicious code. Attackers may also use this vulnerability to redirect users to malicious sites that contain malware, viruses, or other malicious content.",
      "vulnerable_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc redirect(w http.ResponseWriter, r *http.Request) {\n\t// Get the URL to redirect to\n\tredirectURL := r.URL.Query().Get(\"url\")\n\n\t// Redirect to the URL\n\thttp.Redirect(w, r, redirectURL, http.StatusFound)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/redirect\", redirect)\n\tfmt.Println(\"Listening on port 8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n\nThe code above contains a vulnerability because the URL parameter is not validated before being used for a redirect. This allows attackers to redirect users to malicious sites, which can be used for phishing attacks, malware distribution, or other malicious activities.",
      "remediation": "The following example shows how to prevent open redirects in a Go web application. \n\n// Parse the URL\nurl, err := url.ParseRequestURI(req.URL.String())\nif err != nil {\n    // Handle the error\n    return\n}\n\n// Check if the URL contains an external domain\nif url.Host != req.Host {\n    // Redirect to a safe URL\n\thttp.Redirect(w, r, \"https://www.example.com/safe-url\", http.StatusSeeOther)\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects CWE-601: URL Redirection to Untrusted Site ('Open Redirect')\"\n    severity = \"WARNING\"\n  strings:\n    $redir_func = /http\\.Redirect/\n    $redir_url = /[a-zA-Z]+\\:\\/\\/.+/\n  condition:\n    $redir_func and $redir_url\n}",
      "codeql_rule": "import go\n\nimport semmle.code.go.ast.expressions.StringLiteral\n\nclass UrlRedirectionToUntrustedSite extends Query {\n  /**\n  * Finds methods that contain a URL redirection to an untrusted site\n  */\n  vulnerableMethod() {\n    MethodCall m1;\n    StringLiteral redirectionUrl;\n\n    m1 = this.methodCallThatInvokesRedirection()\n    redirectionUrl = m1.getArgumentExpr(0)\n    // Finds methods that contain a URL redirection to an untrusted site\n    //  (i.e. URLs that have not been whitelisted)\n    redirectionUrl.isUntrustedUrl()\n    m1@isVulnerable\n  }\n\n  methodCallThatInvokesRedirection() {\n    // Finds methods that could cause a redirection"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is a vulnerability in which sensitive information is inadvertently inserted into a log file. This can occur if a log file does not have proper protections in place and allows for sensitive information to be inadvertently stored in the log file. Sensitive information can include usernames and passwords, session tokens, credit card numbers, and other confidential information. An attacker can exploit this vulnerability to gain access to sensitive information, potentially leading to data breaches or other malicious activity.",
      "vulnerable_code": "f, err := os.OpenFile(\"log.txt\", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Write sensitive information to the log file\nfmt.Fprintln(f, \"username: admin, password: password123\")\n\n// Close the file\ndefer f.Close()",
      "remediation": "One way to remediate this vulnerability is to use an application that allows for the filtering of sensitive information from log files. This will ensure that any sensitive information is not included in the log files and is kept secure. Additionally, the application should include a feature to alert the system administrator when a log file has been created that contains sensitive information. This will allow the system administrator to take appropriate action in order to protect the sensitive information.",
      "semgrep_rule": "rule = {\n    id: cwe-532-insertion-of-sensitive-information-into-log-files\n    patterns:\n     - pattern: log.Print(...)\n       message: \"Sensitive information is being inserted into a log file\"\n       severity: WARNING\n    meta:\n     author: \"Your Name\"\n}",
      "codeql_rule": "import sys\nimport cwe532\n\nclass CWE532LogInsertionRule(cwe532.LogInsertionRule):\n  def __init__(self):\n    cwe532.LogInsertionRule.__init__(self)\n\n  def get_vulnerability_entries(self, file, language):\n    if language != \"Go\":\n      return []\n    \n    entries = []\n    # Look for functions that write to log files\n    for func in cwe532.get_write_functions(file):\n      # Look for calls to functions that take sensitive data as parameters\n      for call in func.called_functions():\n        for param in call.parameters():\n          if cwe532.is_sensitive_data(param):\n            entries.append(call.location)\n    return entries"
    }
  },
  "JavaScript": {
    "CWE-079: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')": {
      "description": "Cross-site scripting (XSS) is a type of vulnerability that occurs when a malicious website or script injects malicious code into a web page. The vulnerability occurs when user input is not properly sanitized or validated, allowing the malicious code to be executed in the user's browser. This can lead to a variety of malicious activities, such as hijacking user accounts, stealing user data, or redirecting the user to a malicious website. XSS is particularly dangerous because it can be used to spread malware and malicious code, and can even be used to conduct phishing attacks.",
      "vulnerable_code": "// This code is vulnerable to Cross-site Scripting\nlet userInput = document.getElementById('userInput').value;\ndocument.write('<h1>' + userInput + '</h1>');",
      "remediation": "// Before\n<script>\nvar userInput = prompt('Please enter your name');\ndocument.write('Hello ' + userInput + '!');\n</script>\n\n// After\n<script>\nvar userInput = prompt('Please enter your name');\ndocument.write('Hello ' + escapeHTML(userInput) + '!');\n\nfunction escapeHTML(unsafeText) {\n    return unsafeText\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\n</script>",
      "semgrep_rule": "rule = {\n\tmeta:\n\t\tauthor = \"John Doe\"\n\t\tdescription = \"Detects improper neutralization of input during web page generation\"\n\t\tseverity = \"high\"\n\t\tconfidence = \"high\"\n\t\n\tstrings:\n\t\t$input_1 = /<[^>]*[^\\/]>.*[^<\\/]$/\n\t\t\n\tcondition:\n\t\t$input_1\n}",
      "codeql_rule": "import cwe080\nimport semmle.code.cpp.security.InputValidation\n\nclass XSSVulnerability extends SecurityFlow {\n  XSSVulnerability() {\n    this = XSSVulnerability.generateStartFlow()\n  }\n\n  predicate isVulnerableInput(InputValidation::SanitizedData data) {\n    not data.isTrusted()\n  }\n\n  predicate isSanitization(InputValidation::Sanitization sanitization) {\n    sanitization.sanitizes(this.getArgument(0))\n  }\n\n  // Find flows from tainted input to sink\n  from TaintedInput = InputValidation::TaintedData.all()\n  to XSSSink = cwe080.XSSSink()\n  such that\n    // Require vulnerable input\n    isVulnerableInput(TaintedInput) and\n    // Require"
    },
    "CWE-020: Improper Input Validation": {
      "description": "Improper input validation is a vulnerability that occurs when an application does not properly validate or sanitize user input. This can lead to malicious code being injected into the application, allowing an attacker to gain access to sensitive data or perform malicious activities. In JavaScript, this vulnerability can occur if user input is used in any sort of dynamic evaluation, such as an eval() statement, or if user input is used as a parameter in a function call.",
      "vulnerable_code": "function handleInput(inputData) {\n  // Do some processing\n  // ...\n\n  // Store input without any kind of validation\n  const result = storeInput(inputData);\n\n  return result;\n}",
      "remediation": "// Before\nlet userInput = req.body.input;\nlet result = doSomething(userInput);\n\n// After\nlet userInput = req.body.input;\nlet sanitizedInput = sanitizeInput(userInput);\nlet result = doSomething(sanitizedInput);",
      "semgrep_rule": "rule = {\n  id: \"CWE-020-Improper-Input-Validation\",\n  patterns: [\n    // detect if input is not being sufficiently validated\n    pattern: \"if (input == * || input != *)\"\n  ],\n  message: \"Improper input validation detected\",\n  severity: \"error\"\n}",
      "codeql_rule": "import javascript\n\nclass ImproperInputValidation extends Rule {\n  // Query to detect the vulnerability\n  query vulnerableCode() {\n    // Finds all instances of user input being used without proper input validation\n    UserInput ui | \n    // Finds all instances of eval being used with the input\n    EvalCall ec where ec.argument = ui\n  }\n  \n  // Reports a warning when the vulnerability is detected\n  meta:\n    severity = \"warning\"\n    description = \"Improper input validation can lead to remote code execution vulnerability\"\n}"
    },
    "CWE-078: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')": {
      "description": "OS Command Injection is a type of vulnerability that occurs when an attacker is able to inject malicious commands into an operating system via a vulnerable application. It allows the attacker to gain access to the system and run unauthorized code with the privileges of the vulnerable application. This type of attack can be used to gain access to confidential data, manipulate files, or even take control of the system.",
      "vulnerable_code": "// Vulnerable code\nlet userInput = req.query.input;\nlet cmd = `rm -rf ${userInput}`;\nexec(cmd);",
      "remediation": "// BEFORE\nconst userInput = req.body.command;\n\nconst result = execSync(userInput);\n\n// AFTER\n// Sanitize user input\nconst userInput = req.body.command.replace(/[^a-zA-Z ]/g, \"\");\n\n// Escape any special characters\nconst escapedInput = userInput.replace(/[\\W]/g, \"\\\\$&\");\n\n// Execute the command\nconst result = execSync(escapedInput);",
      "semgrep_rule": "rule = {\n  id: \"CWE-078-OS-Command-Injection-Detection\",\n  patterns: [\n    {\n      pattern: \"(exec|spawn|system|popen|passthru|shell_exec|proc_open|`) *\\\\(\",\n      message: \"Possible OS Command Injection detected.\",\n      severity: \"CRITICAL\"\n    }\n  ]\n}",
      "codeql_rule": "import os\n\nclass CWE078_OS_Command_Injection:\n \n  // Detect when an application invokes a system command without properly\n  // sanitizing user-supplied input\n \n  os.exec*\n  and not sanitize*\n  and not whitelist*"
    },
    "CWE-089: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')": {
      "description": "CWE-089 is a type of injection attack in which a malicious user is able to insert arbitrary SQL code into a web application and use it to access, modify or delete data in a database. This vulnerability is caused by a lack of proper input validation, allowing an attacker to inject code into an application and manipulate the underlying database. This can result in data being leaked, modified, or deleted, and can lead to other security issues such as privilege escalation.",
      "vulnerable_code": "//This code allows user input to be directly inserted into a SQL query without proper encoding or sanitization\n\nlet userInput = req.body.userInput;\n\nlet query = `SELECT * FROM users WHERE name = ${userInput}`;\n\nconn.query(query, (err, result) => {\n  if (err) {\n    console.log(err);\n  } else {\n    console.log(result);\n  }\n});",
      "remediation": "// Before Remediation\nconst query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n\n// After Remediation\nconst query = \"SELECT * FROM users WHERE username = ?\";\nconst usernameParam = [username];\nconnection.query(query, usernameParam);",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects SQL injection vulnerability\"\n    severity = \"CRITICAL\"\n    author = \"Semgrep\"\n  strings:\n    $sqli_pattern = /(\\bconcat\\b.*\\bselect\\b|\\bselect\\b.*\\bconcat\\b|\\bunion\\b.*\\bselect\\b|\\bselect\\b.*\\bunion\\b|\\bupdate\\b.*\\bset\\b|\\bset\\b.*\\bupdate\\b)/\n  condition:\n    $sqli_pattern\n}",
      "codeql_rule": "import cwe089\n\nclass CWE089_Vulnerability:\n  // finds queries that have not been properly escaped\n  // or use parameterized queries\n  // to prevent SQL injection\n  // https://cwe.mitre.org/data/definitions/89.html\n \n  // find all SQL queries\n  sql_query_literal = regex \"\\\\b(SELECT|INSERT|UPDATE|DELETE|CREATE|DROP)\\\\b\"\n \n  // find assignments to variables\n  assignment_expression = \n    // find right hand side expression\n    expr rhs \n    // followed by assignment operator\n    where rhs.contains(sql_query_literal) \n    // and left hand side as a variable\n    where rhs.hasAssignee()\n \n  // find function calls\n  function_call = \n    // find"
    },
    "CWE-022: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')": {
      "description": "Path Traversal is a vulnerability that occurs when an attacker is able to access files and directories that are outside of the intended directory structure. In JavaScript, this vulnerability can be caused by applications that allow user input to modify the path of a file or directory that is accessed. For example, if an application requests a file from a specific directory and the user input is used to modify the path, an attacker can craft a malicious input that would allow them to access files outside of the intended directory.",
      "vulnerable_code": "// vulnerable code\nconst path = require('path');\n\nconst userInput = '/../../etc/passwd';  // user controlled input\n\nconst filePath = path.join(__dirname, userInput);\n\nfs.readFile(filePath, (err, data) => {\n  // potentially malicious code\n});",
      "remediation": "//Before\nlet filePath = req.query.path;\n\n//After\nlet filePath = path.join(__dirname, req.query.path);",
      "semgrep_rule": "rule = {\n  id: \"CWE-022\",\n  patterns: [\n    // Detects attempts to access a restricted directory\n    pattern: 'file.open(**/*)',\n    message: 'Accessing a restricted directory is not allowed',\n    severity: 'warning'\n  ]\n}",
      "codeql_rule": "import cwe022\n\nclass PathTraversalVulnerability extends Vulnerability {\n  PathTraversalVulnerability() {\n    super(cwe022.CWE_022);\n  }\n\n  @Override\n  predicate isVulnerable(Node node) {\n    // Check for calls to functions that could lead to a path traversal vulnerability\n    return exists(node,\n      // Functions that accept a file path as an argument\n      call(\"fopen\", _)\n        or call(\"fread\", _)\n        or call(\"readlink\", _)\n        or call(\"exec\", _)\n        or call(\"system\", _)\n        or call(\"popen\", _)\n        or call(\"opendir\", _)\n        or call(\"open\", _)\n      // Functions that accept a directory path as an argument\n      or call(\"mkdir\", _)\n        or call(\""
    },
    "CWE-352: Cross-Site Request Forgery (CSRF)": {
      "description": "Cross-site request forgery (CSRF) is a type of attack that occurs when a malicious website, email, or program causes a user\u2019s web browser to perform an unwanted action on a trusted site for which the user is currently authenticated. This type of attack takes advantage of the trust that a website has for a user\u2019s browser, forcing the user\u2019s browser to send requests to the trusted site without the user\u2019s knowledge or consent. This type of attack can be used to perform various malicious actions such as updating account information, making purchases, or transferring funds.",
      "vulnerable_code": "<script>\n  function submitForm() {\n    var form = document.getElementById(\"form\");\n    form.action = \"https://vulnerable-website.com/process\";\n    form.submit();\n  }\n</script>\n<form action=\"\" id=\"form\" method=\"post\">\n  <input type=\"hidden\" name=\"user_name\" value=\"hacker\">\n  <input type=\"hidden\" name=\"password\" value=\"12345\">\n  <input type=\"submit\" onclick=\"submitForm()\" value=\"Submit\">\n</form>\n\nIn this code, an attacker can craft a malicious link or an image that points to this form and automatically submit it without the user's knowledge. This is because the form submission is triggered by the onclick event and the form is automatically submitted without any user input. This is an example of a Cross-Site Request Forgery (CSRF)",
      "remediation": "The best way to remediate a CSRF vulnerability is to use the Synchronizer Token Pattern. This requires the application to generate a unique token for each request and to verify the token on the server-side before processing the request.\n\nFirst, the application must generate a unique token for each request. This token should be cryptographically strong, randomized, and unpredictable. The token should also have an expiration time.\n\nNext, the application should include the token with each request as a hidden input field in the form or as a query parameter.\n\nFinally, the application should verify the token on the server-side before processing the request. The server should check that the token is valid, has not expired, and that it matches the token stored in the user's session. If the token is invalid, the request should be rejected.",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects Cross-Site Request Forgery (CSRF) vulnerability\"\n    id = \"RULE_ID\"\n    severity = \"high\"\n  source:\n    languages = [\"JavaScript\"]\n  patterns:\n    - pattern: '<form[^>]*method=\"post\"[^>]*>'\n      message: \"Possible CSRF vulnerability detected\"\n}",
      "codeql_rule": "import cwe\n\nclass CWE352_CrossSiteRequestForgery_Detector extends SecurityCodeScannerRule {\n\n  // rule to detect cross-site request forgery (CSRF)\n  CWE352CrossSiteRequestForgery() {\n    when {\n        // checks if request is coming from a different origin\n        cwe.OriginCheck()\n    }\n    then {\n        // raises a security warning if the request is coming from a different origin\n        report SecurityWarning(\"Cross-site request forgery detected\")\n    }\n  }\n\n}"
    },
    "CWE-434: Unrestricted Upload of File with Dangerous Type": {
      "description": "CWE-434 is a type of vulnerability that allows an attacker to upload a file with a dangerous type such as a malicious script, executable code, or other type of malicious file, to a web application or server. The application does not properly validate the file type or restrict the types of files that can be uploaded. This allows malicious users to upload malicious files onto the server, which can then be used to gain access to the server, execute malicious code, or exfiltrate data from the application or server.",
      "vulnerable_code": "let fileInput = document.getElementById(\"fileInput\");\nlet fileData = fileInput.files[0];\nlet fileName = fileData.name;\n\n// extract the file extension\nlet fileExtension = fileName.substr(fileName.lastIndexOf(\".\") + 1);\n\n// create an array of allowed file types\nlet allowedFileTypes = ['.jpg','.gif','.png'];\n\n// check if the file extension is allowed\nif(allowedFileTypes.includes(fileExtension)){\n    // upload file\n    let fileURL = uploadFile(fileData);\n}",
      "remediation": "The best way to remediate this vulnerability is to restrict the types of files that can be uploaded to the application. This can be done by adding a whitelist of allowed file types and rejecting any files that do not match the whitelist. For example, the following code could be used to ensure that only JPG and PNG files are allowed to be uploaded:\n\n// Whitelist of allowed file types\nconst allowedTypes = [\".jpg\", \".png\"];\n\n// Check if the uploaded file matches a whitelisted type\nif (allowedTypes.includes(file.type)) {\n    // Upload file\n    ...\n} else {\n    // Reject file\n    ...\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects unrestricted upload of file with dangerous type\"\n    severity = \"WARNING\"\n    id = \"CWE-434\"\n    tags = [\"security\", \"cwe-434\"]\n  source: \n    languages = [\"JavaScript\"]\n  detection:\n  \tcondition: |\n      (call (id \"fopen\") (string.contains_re \".*\\.(bat|exe|com|sh|reg|vbs|scr|js|php)$\") )\n}",
      "codeql_rule": "import cwe434\n\nclass CWE434_Unrestricted_Upload_of_File_with_Dangerous_Type extends Rule {\n  // Query identifies code that allows unrestricted file uploads of dangerous types\n  // such as executable files\n  //\n  // This query looks for calls to functions that allow file uploads,\n  // such as a web form or API, and checks if the file type is not restricted\n  // to only safe files, such as images and text files.\n  //\n  // If the file type is not restricted, this query raises an issue.\n  //\n  // This rule is marked as CWE-434, Unrestricted Upload of File with Dangerous Type.\n \n  // Find any calls to functions that allow file uploads\n  // such as web forms or API functions\n  predicate isFileUploadFunctionCall(CallExpr ce) {\n    // ...\n  }"
    },
    "CWE-306: Missing Authentication for Critical Function": {
      "description": "CWE-306 is a vulnerability where a critical function on a website, application, or system does not have authentication enabled to protect it from unauthorized access. This means that anyone can access the function, regardless of their credentials or access privileges, and can potentially use it to cause damage or to steal sensitive data. This type of vulnerability is particularly dangerous because it can be used to gain access to confidential information or to manipulate data in a malicious way.",
      "vulnerable_code": "let username = \"\";\nlet password = \"\";\n\nfunction performCriticalOperation() {\n    // perform action that requires authentication\n}\n\nif (username !== \"\" && password !== \"\") {\n    performCriticalOperation();\n}",
      "remediation": "// Before Remediation\n\nfunction deleteRecord(recordId) {\n  const record = findRecordById(recordId);\n  deleteFromDatabase(record);\n}\n\n// After Remediation\n\nfunction deleteRecord(recordId, userId) {\n  const record = findRecordById(recordId);\n  if (record.ownerId === userId) {\n    deleteFromDatabase(record);\n  }\n}",
      "semgrep_rule": "rule = { \n  meta: \n    description = \"Detects missing authentication for critical functions\" \n    id = \"CWE-306\" \n  strings: \n    $function_call = \"critical_function\" \n  condition: \n    not all of them ($function_call) at (parameters.count == 0)\n}",
      "codeql_rule": "import cwe\nimport semmle.CodeGen.CGlobals\n\nclass MissingAuthForCriticalFunction extends SecurityChecker {\n    // Checks for functions that lack authentication\n    // when access to them should be restricted\n    predicate isCriticalFunction() {\n        //Enter here the name of the functions that should be restricted\n        //with authentication\n    }\n    \n    @Override\n    check(CFunctionCallExpr call) {\n        if (call.getTarget().matches(isCriticalFunction())) {\n            //Check if the function call lacks authentication\n            //If authentication is missing, raise an issue\n            if (!call.hasAuthentication()) {\n                report(call.getTarget(), \"Missing authentication for critical function\", cwe.CWE_306);\n            }\n        }\n    }\n}"
    },
    "CWE-502: Deserialization of Untrusted Data": {
      "description": "CWE-502 is a vulnerability related to the deserialization of untrusted data. This vulnerability occurs when an application or system attempts to deserialize data from an untrusted source, such as user input or a remote source, without properly validating the data. Attackers can exploit this vulnerability by modifying the data before it is deserialized, allowing them to inject malicious code into the application or system. This can lead to remote code execution, access to sensitive data, and other malicious activities.",
      "vulnerable_code": "let userData = JSON.parse(req.body.userData);\n\n// vulnerable code\nlet adminAccess = userData.admin;\nif (adminAccess) {\n   // grant admin privileges\n   grantAdminPriviledges();\n} \n\nIn this example, userData is parsed from an untrusted source, which could contain malicious code. If the malicious code sets adminAccess to true, the application will grant admin privileges without verifying that the user is actually an administrator. This can lead to arbitrary code execution and other security issues.",
      "remediation": "// Example of serialization\nconst dataToSerialize = {\n    id: 123,\n    name: \"John Doe\"\n};\n\n// Serializing the data\nconst serializedData = JSON.stringify(dataToSerialize);\n\n// Example of deserialization\n// Remediation using try/catch\ntry {\n    const deserializedData = JSON.parse(serializedData);\n} catch (err) {\n    console.error('Unable to deserialize data');\n}",
      "semgrep_rule": "rule = {\n  meta: {\n    id: \"CWE-502\",\n    description: \"Deserialization of untrusted data\",\n    severity: \"critical\"\n  },\n  pattern: [\n    {\n      regexp: /JSON\\.parse\\(.*\\)/\n    }\n  ]\n}",
      "codeql_rule": "import cwe\n\nclass DeserializationOfUntrustedDataVulnerability(cwe.Vulnerability):\n  def __init__(self):\n    self.id = 502\n    self.name = \"Deserialization of Untrusted Data\"\n    self.description = \"The application deserializes untrusted data without properly validating it, allowing an attacker to inject malicious objects into the application\"\n    \nclass DeserializationOfUntrustedDataQuery(cwe.Query):\n  def __init__(self):\n    self.vulnerability = DeserializationOfUntrustedDataVulnerability()\n  \n  def getQuery(self):\n    return (\n      from deserializationCall in Call\n      where deserializationCall.getTarget().hasAnnotation(\"java.io.ObjectInputStream.readObject\")\n      select deserializationCall\n    )"
    },
    "CWE-287: Improper Authentication": {
      "description": "CWE-287 is a vulnerability related to authentication. It occurs when authentication procedures are not properly implemented or enforced, allowing unauthorized users to gain access to restricted resources. This vulnerability can allow malicious users to gain access to a system, including gaining access to confidential or sensitive information. Additionally, improper authentication can also allow attackers to bypass authentication mechanisms or modify authentication data.",
      "vulnerable_code": "// This code assumes that the 'username' and 'password' variables have been set somewhere else in the program\n\nlet authenticated = false;\n\nif (username === \"admin\" && password === \"password\") {\n  authenticated = true;\n}\n\nif (authenticated) {\n  // Execute code that requires authentication\n}",
      "remediation": "// Before Remediation\n\nconst user = getUserFromRequest();\n\nif (user.name) {\n  // Perform an action\n}\n\n// After Remediation\n\nconst user = getUserFromRequest();\n\nif (user.name && user.authenticated) {\n  // Perform an action\n}",
      "semgrep_rule": "rule = [\"source.lang.js\", rule_id: \"CWE-287-Improper-Authentication\", message: \"Improper Authentication detected\",\n\t      condition: \"if (auth !== user && auth !== pass) { return false; }\"]",
      "codeql_rule": "import cwe287\n\nclass CWE287ImproperAuthenticationRule extends Rule {\n  // Look for authentication attempts\n  // where the username or password is not\n  // securely checked\n \n  // Find authentication attempts\n  // where the username or password is not\n  // securely checked\n \n  // This query looks for use of login()\n  // methods which are not using a secure\n  // authentication method\n  query LoginCall {\n    LoginCall = call(\"login\")\n    where not exists (\n      Method m \n      such that m.id = LoginCall.callee \n      and m.hasAnnotation(\"cwe287\")\n    )\n  }\n \n  // This query reports the vulnerability\n  // if a login() call is found without\n  // using a secure authentication method\n  vulnerability CWE287ImproperAuthentication {\n    when = LoginCall"
    },
    "CWE-798: Use of Hard-coded Credentials": {
      "description": "CWE-798 is a vulnerability in which an application or system uses hard-coded credentials that are stored in the code. This means that secure information, such as usernames and passwords, are stored directly in the source code, making them visible to anyone who has access to the code. This can expose the system to potential hackers or malicious actors who can use the credentials to access sensitive data or change system settings. This vulnerability can be especially dangerous if the credentials are used in multiple systems, as a breach in one system can lead to a breach in all systems.",
      "vulnerable_code": "//Example of vulnerable code \nlet username = \"admin\";\nlet password = \"password123\";\n\nif (username == \"admin\" && password == \"password123\") {\n    //Allow user access\n} else {\n    //Deny access\n}",
      "remediation": "// Before \nconst username = 'admin';\nconst password = 'password123';\n\n// After \nconst username = process.env.USERNAME;\nconst password = process.env.PASSWORD;",
      "semgrep_rule": "rule = id:\"CWE-798-hardcoded-credentials\"\n     message:\"Possible use of hard-coded credentials detected\"\n     severity:\"WARNING\"\n     patterns:[\n         {pattern:\"const username = \\\"[a-zA-Z0-9]+\\\"\", kind: \"literal\"},\n         {pattern:\"const password = \\\"[a-zA-Z0-9]+\\\"\", kind: \"literal\"}\n     ]",
      "codeql_rule": "import cwe\nimport javascript\n\nclass HardcodedCredentialsVulnerability extends Rule {\n  // Query to detect instances of hardcoded credentials\n  // where a string literal is assigned to a variable\n  // inside a javascript file\n  getMatches() {\n    let strings = VariableAssignment.objects({\n      rhs: StringLiteral\n    })\n    .select(s => s.parent.parent.parent)\n    .filter(f => f instanceof javascript.File)\n  \n    return strings.filter(s => {\n      return s.hasDescendant(d => d.isInstanceOf(StringLiteral) &&\n        (d.string.contains(\"username\") || d.string.contains(\"password\") || \n        d.string.contains(\"passcode\")));\n    })\n  }\n  \n  // Report instances of hardcoded credentials"
    },
    "CWE-276: Incorrect Default Permissions": {
      "description": "CWE-276 Incorrect Default Permissions is a vulnerability that occurs when a software application assigns incorrect default permissions for files and directories. This could include granting non-privileged users access to sensitive resources, or granting an overly broad set of permissions to files or directories. This vulnerability can be used to gain unauthorized access to files or system resources, and can lead to other security issues such as data leakage or data manipulation.",
      "vulnerable_code": "fs.chmodSync(\"/tmp/myfile.txt\", 0755);\n\nThe code above sets the permissions for the file \"/tmp/myfile.txt\" to 0755. This may be too permissive and allow anyone to read and write to the file. To reduce the risk, it is best to set the permissions to a more secure value, such as 0644 or 0600.",
      "remediation": "// Before remediation\nfs.writeFile('data.txt', 'This is some data', (err) => {\n  if (err) {\n    console.error(err);\n  }\n});\n\n// After remediation\nfs.writeFile('data.txt', 'This is some data', { mode: 0o600 }, (err) => {\n  if (err) {\n    console.error(err);\n  }\n});",
      "semgrep_rule": "rule = {\n  meta: {\n    id: \"CWE-276\",\n    description: \"Incorrect Default Permissions\",\n    author: \"Example Security Team\"\n  },\n  strings: {\n    // Detects when file permissions are set to 777\n    $permissions = /777/\n  },\n  condition: $permissions\n}",
      "codeql_rule": "import cwe276\n\nclass IncorrectDefaultPermissions extends Rule {\n  // Rule definition\n  getQuery() {\n    return (\n      // Get all assignments of the target to a new object\n      // with an incorrect permission\n      Query.fromIndex(\"assignments\", cwe276.IncorrectPermissionsAssignment)\n    )\n  }\n \n  // Rule body\n  afterQuery(query) {\n    query.forEach(result => {\n      // Warn about the incorrect permission\n      const permission = result.permission;\n      this.report(result.target, \"Incorrect permission: \" + permission);\n    });\n  }\n}"
    },
    "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor": {
      "description": "CWE-200 is a vulnerability that occurs when sensitive information is exposed to an unauthorized actor. This can include information such as passwords, financial data, health records, or other confidential information. This vulnerability can occur when an application is not properly secured, allowing a malicious actor to access sensitive data without proper authentication or authorization. Additionally, this vulnerability can occur when data is sent over an insecure network connection, or when data is stored in an unprotected environment.",
      "vulnerable_code": "// Vulnerable code\nlet userInfo = {\n  name: 'John Doe',\n  address: '123 Main Street',\n  ssn: '123-45-6789'\n};\n\n// Assume this is a public API endpoint\napp.get('/userInfo', (req, res) => {\n  res.json(userInfo);\n});",
      "remediation": "// Before\nconst userData = {\n  name: 'John Smith',\n  ssn: '123-45-6789'\n};\n\n// After\nconst userData = {\n  name: 'John Smith'\n};\n\nconst ssn = '123-45-6789';\n\n// Ensure that ssn is not exposed to an unauthorized actor\nif (userData.ssn === ssn) {\n  // Perform sensitive action\n}",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects exposure of sensitive information to unauthorized actors\"\n    severity = \"high\"\n    reference = \"CWE-200\"\n  strings:\n    $sensitive_info = /(private|confidential)/\n  condition:\n    $sensitive_info\n}",
      "codeql_rule": "import javascript\n\nclass SensitiveInfoExposure extends Rule {\n  // Query to detect the sensitive information exposure\n  Query exposureQuery {\n    // Find all variable declarations\n    VarDecl[kind]\n    // and assignments to them\n    (AssignExpr[left](_, VarRef[name == kind.name]))\n    // which contain data whose value could be considered sensitive\n    | (AssignExpr[left] (_, StringLiteral[value contains \"password\"]))\n    | (AssignExpr[left] (_, NumberLiteral[value contains \"credit card\"]))\n    | (AssignExpr[left] (_, BooleanLiteral[value contains \"sensitive\"]))\n    // and which are not within a try/catch block\n    where not getAncestor(TryStmt)\n  }\n\n  // Report any matches of the query\n  get"
    },
    "CWE-522: Insufficiently Protected Credentials": {
      "description": "CWE-522 occurs when credentials are stored in an insecure manner, such as in plain text or with weak encryption. This can allow an attacker to gain access to the credentials and use them for malicious purposes. Without adequate protection, attackers can easily access the credentials and use them to gain access to sensitive resources.",
      "vulnerable_code": "// Vulnerable code example\nlet username = 'admin';\nlet password = 'admin123';\n\n// This code sends the username and password to an API endpoint\nlet apiEndpoint = 'http://www.example.com/api/login';\nlet response = fetch(apiEndpoint, {\n    method: \"POST\",\n    body: JSON.stringify({ username: username, password: password })\n});",
      "remediation": "When storing credentials, they should always be encrypted and stored securely. For example, instead of storing plaintext passwords, use a library like bcrypt or PBKDF2 to hash the passwords before storing them. Additionally, make sure to use a secure encryption algorithm and key for encrypting the credentials. Finally, it's best practice to use two-factor authentication (2FA) when available to add an extra layer of security.",
      "semgrep_rule": "rule = {\n    meta:\n      description = \"Insufficiently Protected Credentials\"\n      severity = \"WARNING\"\n    strings:\n      $cred1 = /(username|password|passcode|pin|token|hash|key)/\n    condition:\n      $cred1 @/[^A-Za-z0-9$&+,:;=?@#|'<>.^*()%!-]/\n}",
      "codeql_rule": "import cwe522\n\nclass InsufficientlyProtectedCredentialsRule extends Rule {\n  // rule definition\n  Boolean vulnerable(Credential c) {\n    return exists(Method m, \n      m.getName() == \"checkCredentials\" \n      && m.getParameters().includes(c)\n      && !m.hasAnnotation(cwe522.SecureCredentialStorage)\n    )\n  }\n\n  // query definition\n  query InsufficientlyProtectedCredentials() {\n    Credential c\n    vulnerable(c)\n  }\n}"
    },
    "CWE-611: Improper Restriction of XML External Entity Reference": {
      "description": "CWE-611 is a vulnerability involving the improper restriction of XML External Entity References. This vulnerability allows an attacker to access files and other resources on the system by leveraging an XML document that contains a reference to an external entity. By doing so, the attacker can gain access to data that should otherwise be restricted. The attacker can also execute malicious code on the system by exploiting the vulnerability.",
      "vulnerable_code": "let parser = new DOMParser();\nlet xml = '<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [ <!ELEMENT foo ANY >\n<!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\n<foo>&xxe;</foo>';\n\nlet doc = parser.parseFromString(xml, \"text/xml\");\n\nconsole.log(doc.documentElement.firstChild.nodeValue);",
      "remediation": "// Before\nlet parser = new DOMParser();\nlet xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n\n// After\nlet parser = new DOMParser();\nlet xmlDoc = parser.parseFromString(xmlString, \"text/xml\", {\n  forbidExternal: true,\n  allowAmpersand: false,\n  resolveExternalEntities: false\n});",
      "semgrep_rule": "rule = {\n  meta:\n    severity = \"medium\"\n    description = \"Detects improper restriction of XML external entity references\"\n    author = \"Security Team\"\n  strings:\n    $x1 = /<[\\s]*[Xx][Mm][Ll]/\n    $x2 = /[Ee][Nn][Tt][Ii][Tt][Yy]/\n    $x3 = /[Ss][Yy][Ss][Tt][Ee][Mm]/\n  condition:\n    $x1 and $x2 and $x3\n}",
      "codeql_rule": "import cwe\n\nclass VulnerableXmlExternalEntityReference(cwe.Vulnerability):\n\n  // Find XML documents which contain an external entity reference\n  // with an unrestricted system identifier\n  @Find(\"$x := /XmlDocument/ExternalEntityRef/@systemId\")\n  def vulnerable(x: Expr):\n    if $x.isUnrestricted():\n      return [cwe.CWE_611]"
    },
    "CWE-918: Server-Side Request Forgery (SSRF)": {
      "description": "Server-Side Request Forgery (SSRF) is a type of vulnerability which allows an attacker to send malicious requests from the vulnerable server to other internal or external systems. This vulnerability can allow the attacker to gain access to sensitive information and potentially compromise systems. The attacker can use the vulnerable server as a proxy to bypass authentication and authorization controls and attack other systems.",
      "vulnerable_code": "fetch('http://localhost:8080/?url=' + request.query.url)\n  .then(response => response.text())\n  .then(body => {\n    // Do something with body\n  });\n\nThis code is vulnerable to SSRF because it takes the value of the 'url' parameter from the request object and uses it in a fetch call. This means an attacker could craft a malicious request and cause the server to make a request to a site of their choosing.",
      "remediation": "//Before\nconst request = require('request');\n\n// user supplied url\nlet userURL = req.query.url;\n\nrequest(userURL, (err, resp, body) => {\n    if (err) {\n        // error handling\n    }\n    else {\n        // do something with the body\n    }\n});\n\n//After\nconst request = require('request');\n\n// user supplied url\nlet userURL = req.query.url;\n\n// whitelist only approved domains\nlet whitelist = [\n\t'https://example.com',\n\t'https://example2.com'\n];\n\n// check if the userURL is in the whitelist\nif (whitelist.includes(userURL)) {\n\trequest(userURL, (err, resp, body) => {\n\t\tif (err) {\n\t\t\t// error handling",
      "semgrep_rule": "rule = {\n  patterns: [\n    {\n      pattern: \"fetch('$URL$')\",\n      message: \"Possible Server-Side Request Forgery (SSRF) vulnerability detected\",\n      severity: \"CRITICAL\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe\nimport semmle.code.cpp.dataflow.TaintTracking\n\nclass ServerSideRequestForgeryVulnerability extends CweRule {\n    ServerSideRequestForgeryVulnerability() {\n        super(cwe.CWE_918_SSRF)\n    }\n\n    @Override\n    Boolean predicate(Trusted<Node> startNode) {\n        // Find all nodes that take user input\n        Trusted<Node> sourceNode := startNode.sourceNodes(TaintTracking.sources)\n\n        // Find all nodes that perform a request or open a connection\n        Trusted<Node> sinkNode := startNode.sinkNodes(TaintTracking.sinks)\n        (exists (Trusted<Node> n | n.hasDescendant(sinkNode)))\n    }\n}"
    },
    "CWE-077: Improper Neutralization of Special Elements used in a Command ('Command Injection')": {
      "description": "Command injection is a vulnerability that occurs when an attacker is able to execute arbitrary commands on a system by manipulating the inputs to an application. This is typically done by passing malicious input to an application that is then used to execute commands in the underlying operating system. These commands can be used to access sensitive data, delete files, or even manipulate the entire system. This vulnerability can be exploited in a wide range of contexts, including web applications, operating system commands, and even embedded systems.",
      "vulnerable_code": "let userInput = document.getElementById('input').value;\nlet command = `rm -rf ${userInput}`;\n\n// Execute the command\nexec(command);",
      "remediation": "//Before:\n\nconst userInput = req.body.query;\nconst query = `SELECT * FROM table_name WHERE column_name=${userInput}`;\n\n//After:\n\nconst userInput = req.body.query;\nconst query = `SELECT * FROM table_name WHERE column_name=?`;\nconst values = [userInput];\nconst sanitizedQuery = mysql.format(query, values);",
      "semgrep_rule": "rule = {\n  meta: \n    description = \"Detects potential command injection vulnerabilities\"\n    severity = \"CRITICAL\"\n  source: \n    patterns: \n    - pattern: 'exec(.+)'\n  detection:\n    condition: all\n}",
      "codeql_rule": "import cwe077\n\nclass CWE_077_Command_Injection extends Rule {\n  // Checks for command injection\n  getCallsTo: {\n    // Checks for any calls to exec or system\n    exec | system\n  }\n\n  // Report any matches\n  getMatches {\n    // Check for any call to exec or system\n    call, sym <- getCallsTo\n    if sym.name == \"exec\" or sym.name == \"system\"\n    report cwe077 call\n  }\n}"
    },
    "CWE-295: Improper Certificate Validation": {
      "description": "CWE-295 is a vulnerability that occurs when an application fails to properly validate X.509 certificates. This vulnerability can allow attackers to gain access to sensitive information by bypassing the authentication process, spoofing a user, or tampering with the communication between two systems. Additionally, attackers can use this vulnerability to execute malicious code on the target system. This vulnerability can be exploited by manipulating the certificate's contents, such as the domain name, public key, or digital signature.",
      "vulnerable_code": "//This code will fail to properly validate the server certificate\n//and may result in a man-in-the-middle attack.\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"https://example.com\");\nxhr.send();\n\n//This code should be modified to properly validate the server certificate\n//and reject the connection if the certificate is invalid.\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"https://example.com\");\nxhr.setRequestHeader(\"Authorization\", \"Basic \" + btoa(username + \":\" + password));\nxhr.sslVerifyPeer = true;\nxhr.sslVerifyHost = true;\nxhr.send();",
      "remediation": "//Before Remediation\nlet cert = fs.readFileSync('cert.pem');\n\n//After Remediation\nlet cert = fs.readFileSync('cert.pem');\nlet certData = crypto.certificate.parse(cert);\nlet valid = crypto.verifyCertificateChain(certData);\nif (!valid) {\n   throw new Error('Invalid Certificate');\n}",
      "semgrep_rule": "rule = {\n  id: \"detect-improper-certificate-validation-vulnerability\",\n  patterns: [\n    pattern: \"(request|fetch|axios).(cert|ca).(check|verify|validate)\",\n    message: \"Possible improper certificate validation vulnerability detected\",\n    severity: \"WARNING\"\n  ]\n}",
      "codeql_rule": "import os\nimport cwe\n\nclass ImproperCertificateValidation(cwe.Rule):\n  def __init__(self):\n    cwe.Rule.__init__(self, \"CWE-295\")\n\n  def check(self, qctx, obj):\n    if (obj.name == \"XMLHttpRequest\" and\n        \"open\" in obj.calls and\n        any(arg.value == \"https://\" for arg in obj.calls.open.args)):\n      qctx.report(obj.calls.open, \"Improper certificate validation may lead to a vulnerability (CWE-295)\")"
    },
    "CWE-094: Improper Control of Generation of Code ('Code Injection')": {
      "description": "CWE-094 is a type of code injection vulnerability which occurs when an application allows user-supplied input to be injected into a code template, or does not properly validate or sanitize the user-supplied data before it is used to generate code. This type of vulnerability can be exploited by attackers to inject malicious code into a program which can be used to gain access to sensitive information, or to cause the application to execute arbitrary or unintended code.",
      "vulnerable_code": "//User input stored as 'userInput'\nvar userInput = \"userInput\";\n\n//Vulnerable code\neval(userInput);",
      "remediation": "// Before\nconst userInput = req.query.name;\neval(userInput);\n\n// After\nconst userInput = req.query.name;\nconst sanitizedInput = sanitizeInput(userInput);\neval(sanitizedInput);",
      "semgrep_rule": "rule = {\n  id: \"CWE-094\",\n  patterns: [\n    {\n      pattern: \"{command}(${string}|${number})\",\n      message: \"Improper control of code generation detected. Possible code injection attack.\",\n      severity: \"error\"\n    }\n  ]\n}",
      "codeql_rule": "import cwe094\n\nclass CWE094_Improper_Control_of_Generation_of_Code_Injection:\n  //CWE-094: Improper Control of Generation of Code ('Code Injection')\n  //Vulnerability occurs when user input is injected into a code generation process.\n  //This can lead to arbitrary code execution.\n  //This rule looks for code that takes user input that is used to generate code in\n  //a way that is not properly validated.\n \n  boolean vulnerable(Function func) {\n    //Find all call expressions\n    Expr callExpr = func.allCallExprs()\n    //Find all functions that take user input\n    Callable userInputFunc = callExpr.calls(builtin.getUserInput())\n    //Find all functions that generate code\n    Callable codeGeneratorFunc = callExpr"
    },
    "CWE-269: Improper Privilege Management": {
      "description": "CWE-269 is a type of vulnerability related to privilege management. It occurs when an application or system fails to properly assign and manage privileges, resulting in granting users more access than they should have. This can allow users to access or manipulate data that they shouldn't be able to, which can lead to data breaches or other malicious activities.",
      "vulnerable_code": "// User input is taken without validating it first\nlet userRole = prompt('What is your role?');\n\n// User role is used for authorization without further checks\nif (userRole == 'admin') {\n    // Admin privileges\n    doAdminAction();\n} else {\n    // Normal privileges\n    doNormalAction();\n}",
      "remediation": "// Before\nfunction addUser(userInfo) {\n  let user = new User(userInfo);\n  user.save();\n}\n\n// After\nfunction addUser(userInfo) {\n  let user = new User(userInfo);\n  user.setRole('USER');  // Set the user's role to USER\n  user.save();\n}",
      "semgrep_rule": "rule = {\n        meta:\n          description = \"Detects improper privilege management\"\n          severity = \"MEDIUM\"\n        source:\n          languages = [\"JavaScript\"]\n        detection:\n          condition: any(\n            // All functions that call setuid\n            // or setgid should be inspected\n            m.name == \"setuid\"\n            m.name == \"setgid\"\n          )\n        }",
      "codeql_rule": "import cwe269\n\nclass ImproperPrivilegeManagement extends Rule {\n    // This rule searches for any statements that create or modify\n    // privileges without explicit authorization checks\n   \n    // Query to find any statements that create or modify privileges\n    // without explicit authorization check\n    query alwaysFails {\n        find assignPrivilege(_, _) \n    }\n   \n    // This is the main rule query\n    query cwe269_ImproperPrivilegeManagement {\n        // Find any assignment of privilege\n        assignPrivilege as var(func: <assignPrivilege>)\n       \n        // And check that there is no explicit authorization check\n        // before the privilege is assigned\n        not {\n            some func @requiresAuth(func)\n        }\n       \n        // Report the assignment of privilege as a vulnerability\n        vulnerability(func: uid(assignPrivilege)) {\n            c"
    },
    "CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')": {
      "description": "CWE-917 is a vulnerability that occurs when an application fails to properly neutralize special elements used in an expression language statement or expression. Expression language injection is a type of attack in which an attacker injects malicious code into an expression language statement or expression, allowing the attacker to gain access to sensitive information or execute malicious code on the system. This vulnerability can be exploited in multiple ways, such as manipulating the code to return true or false conditions, manipulating the application logic, and performing remote code execution.",
      "vulnerable_code": "let userInput = '${request.parameterMap[\"someParam\"]}';\nlet query = 'SELECT * FROM users WHERE username = ' + userInput;\ndb.query(query);\n\nIn this example, the code is vulnerable to expression language injection because user input is directly being appended to a query string without any validation or sanitization.",
      "remediation": "// Before\nlet query = \"SELECT * FROM users WHERE id = \" + req.params.id;\n\n// After\nlet query = \"SELECT * FROM users WHERE id = ?\";\nlet params = [req.params.id];\n\n// Run the query\ndb.query(query, params, (err, result) => {\n  // Handle the query results\n});",
      "semgrep_rule": "rule = {\n  id: \"CWE-917-expression-language-injection\",\n  pattern: {\n    regexp: \"(?<!\\\\w)(?:[^\\\\w]?)(?:[{])(?:[^\\\\w]?)(?:[#])(?:[^\\\\w]?)(?:[{])(?:.*)(?:[}])(?:[^\\\\w]?)(?:[}])(?!\\\\w)\",\n    message: \"Possible Expression Language Injection Vulnerability detected\"\n  }\n}",
      "codeql_rule": "import cwe917\n\nclass CWE917ExpressionLanguageInjection extends Rule {\n  // Query to detect potential Expression Language Injection\n  // vulnerabilities\n  Query potentialInjection() {\n    // Find EL statements\n    ExpressionStatement elStmt =\n      find pattern elStmt: ExpressionStatement \n      where elStmt.getExpression().isEL()\n    // Find uses of user input in EL statements\n    Expression inputExpr =\n      find pattern inputExpr: Expression\n      where inputExpr.usesUserInput()\n    // Find uses of user input in EL statements\n    select elStmt, inputExpr\n    such that elStmt.getExpression().contains(inputExpr)\n  }\n\n  // Test to detect actual Expression Language Injection\n  // vulnerabilities\n  Test cwe917Test() {\n    // Find EL statements\n    ExpressionStatement"
    },
    "CWE-059: Improper Link Resolution Before File Access ('Link Following')": {
      "description": "CWE-059 is a vulnerability where an application follows a link without properly verifying that the link is valid and secure. This can lead to an attacker being able to access sensitive files or data that the application is not authorized to view. For example, an attacker can provide a malicious link in a web page, which an application may follow, allowing the attacker to gain access to confidential data.",
      "vulnerable_code": "let filePath = \"../test/test.txt\"; \nlet file = fs.readFileSync(filePath); \n\nIn this example, the code is vulnerable to improper link resolution before file access. By using the relative path \"../test/test.txt\", the code can access files outside of the intended directory structure, which can lead to security vulnerabilities.",
      "remediation": "The following code example shows the use of the realpath function to ensure that any relative links used in the application are resolved correctly before any file operations take place.\n\nvar fs = require('fs');\n\n// Resolve relative links in path before opening the file\nvar path = fs.realpathSync(filename);\n\nfs.open(path, 'r', function(err, fd) {\n  // File operations\n});",
      "semgrep_rule": "rule = {\n  meta:\n    description = \"Detects improper link resolution before file access vulnerability\"\n    author = \"Security Team\"\n    date = \"2020-08-12\"\n  strings:\n    $file_var = /.*/\n  condition:\n    $file_var and not @resolve(@file($file_var))\n}",
      "codeql_rule": "import cwe_059\n\nclass CWE059 : Vulnerability {\n  /**\n   * Finds instances of improper link resolution before file access.\n   */\n  private predicate isImproperLinkResolution(Expr link, Expr file) {\n    // Check if the file argument is a string literal\n    not isStringLiteral(file)\n  }\n\n  /**\n   * Finds functions that are vulnerable to improper link resolution.\n   */\n  private static predicate isVulnerableFunction(Function func) {\n    // Check if the function is a file access function\n    isFileAccessFunction(func)\n  }\n\n  /**\n   * Checks if the given function is a file access function.\n   */\n  private static predicate isFileAccessFunction(Function func) {\n    // Checks if the given function is a file access function\n    func.hasName(\"open\") or func."
    },
    "CWE-319: Cleartext Transmission of Sensitive Information": {
      "description": "CWE-319 is a vulnerability that occurs when sensitive information is transmitted over a network in cleartext instead of being encrypted. This type of vulnerability can be exploited by attackers who can intercept the data in transit and gain access to the sensitive information. This can have serious consequences such as identity theft, financial loss, or other malicious activity. In order to fix this vulnerability, organizations should ensure that all sensitive information is encrypted before being sent over a network.",
      "vulnerable_code": "const http = require('http');\n\nhttp.createServer(function (req, res) {\n  let userInfo = {\n    username: req.body.username,\n    password: req.body.password\n  };\n\n  let data = JSON.stringify(userInfo);\n\n  // Vulnerable code\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.write(data);\n  res.end();\n\n}).listen(8080);",
      "remediation": "// Before\nconst apiUrl = 'http://example.com/api';\n\n// After\nconst apiUrl = 'https://example.com/api';",
      "semgrep_rule": "rule = [{\n  id: \"CWE-319-detection\",\n  patterns: [\"send(params.password=*)\"],\n  message: \"Sensitive information is being transmitted over a cleartext protocol.\",\n  severity: \"WARNING\"\n}]",
      "codeql_rule": "import cwe319\n\nclass CleartextTransmissionVulnerability implements Rule {\n  // Query to detect Cleartext Transmission of Sensitive Information\n  query CleartextTransmission() {\n    // Find constructor calls of classes that allow sending data over\n    // unencrypted connections\n    ClassType cls\n    where cls.derivesFrom(\"java.net.URLConnection\")\n    or cls.derivesFrom(\"java.net.HttpURLConnection\")\n    or cls.derivesFrom(\"java.net.HttpClient\")\n    or cls.derivesFrom(\"javax.net.ssl.HttpsURLConnection\")\n    or cls.derivesFrom(\"org.apache.http.impl.client.CloseableHttpClient\")\n    or cls.derivesFrom(\"org.apache.http.client.HttpClient\")\n    or cls.derivesFrom(\""
    },
    "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')": {
      "description": "CWE-601 is a vulnerability that occurs when an application redirects a user to an untrusted site. This type of vulnerability can be exploited by malicious actors to redirect users to malicious websites, which can result in the user's credentials being stolen or malicious code being injected onto the user's machine. This vulnerability is especially dangerous when the URL redirection is used to bypass authentication or authorization checks, as the malicious actor can access the target website without any authentication or authorization credentials.",
      "vulnerable_code": "// The following code will allow a malicious user to redirect the page to an untrusted website\nlet pageRedirect = window.location.href;\nlet redirectURL = getParameterByName('redirect');\nwindow.location.href = redirectURL;",
      "remediation": "// Before\nwindow.location.href = getURLParameter('redirect');\n\n// After\nif (isValidRedirectUrl(getURLParameter('redirect'))) {\n  window.location.href = getURLParameter('redirect');\n} else {\n  window.location.href = '/error';\n}\n\nfunction isValidRedirectUrl(url) {\n  // Perform validation here\n}",
      "semgrep_rule": "rules:\n  - id: open-redirect\n    message: \"Potential open redirect vulnerability detected.\"\n    severity: WARNING\n    patterns:\n    - pattern: |\n        window.location = $url\n        window.open($url)\n      filters:\n      - not:\n          any:\n            - pattern: \"//[A-Za-z0-9.-]*{{hostname}}\"\n            - pattern: \"//localhost\"\n            - pattern: \"//127.0.0.1\"\n            - pattern: \"//0.0.0.0\"\n            - pattern: \"//[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\"",
      "codeql_rule": "import cwe601\n\nclass UntrustedRedirection:\n  // Define the query in the form of a CodeQL predicate\n  predicate isUntrustedRedirection(CallExpr call) {\n  \t// Check if the call is an HTTP redirect\n  \texists(Method meth |\n  \t\tmeth.getName() == \"redirect\" and\n  \t\tmeth.getClass().getName() == \"HttpResponse\" and\n  \t\tmeth.getClass().getModule().matches(\".*http.*\") and\n      call.getTarget() == meth\n  \t)\n  }\n\n  // Check if the URL passed to the redirect is untrusted\n  @Cwe601\n  predicate vulnerableToCwe601(CallExpr call) {\n  \tisUntrustedRedirection(call) and\n  \texists(Expr arg |"
    },
    "CWE-532: Insertion of Sensitive Information into Log File": {
      "description": "CWE-532 is an issue where an application writes sensitive information, such as passwords, credit card numbers, or other confidential data, into a log file. This can lead to unintended disclosure of the information if an attacker is able to gain access to the log files. Furthermore, if log files are left in an unsecured location, or are not properly monitored, the sensitive data can be accessed by unauthorized personnel.",
      "vulnerable_code": "// Logging a user's password in plain text\nlet username = 'user123';\nlet password = 'password123';\n\nconsole.log('Username: ' + username + ' Password: ' + password);",
      "remediation": "// Remediation\n\n// Replace sensitive information with a generic string\nfunction sanitizeLogs(logData) {\n  return logData.replace(/[A-Za-z0-9]{10,20}/g, '*****');\n}\n\n// Write log data to a file\nfs.writeFile('logs.txt', sanitizeLogs(logData), (err) => {\n  if (err) {\n    console.log(\"Error writing to log file\");\n  }\n});",
      "semgrep_rule": "rule = {\n  id: \"CWE-532-detection\",\n  patterns: [\n    // detect log functions\n    { pattern: \"console.log(/sensitive_information/)\" },\n    { pattern: \"console.warn(/sensitive_information/)\" },\n    { pattern: \"console.error(/sensitive_information/)\" },\n    { pattern: \"console.info(/sensitive_information/)\" },\n    { pattern: \"console.debug(/sensitive_information/)\" },\n    { pattern: \"console.trace(/sensitive_information/)\" },\n\n    // detect other logging methods\n    { pattern: \"logger.log(/sensitive_information/)\" },\n    { pattern: \"logger.warn(/sensitive_information/)\" },\n    { pattern: \"logger.error(/sensitive_information/)\" },\n    { pattern: \"log",
      "codeql_rule": "import cwe532\n\nclass CWE532_LogFileInsertion extends Rule {\n  // Check for logging of sensitive information into log files\n  query insertSensitiveInfoLogFile() {\n    // Find all log statements\n    LogStatement[] logStatements =\n      // Find all logging statements\n      // (e.g. console.log, console.error, etc.)\n      find LogStatement(_);\n\n    // For each LogStatement\n    for (LogStatement logStmt : logStatements) {\n      // Find all sensitive information\n      SensitiveData[] sensitiveData =\n        // Find all sensitive information\n        find SensitiveData(_);\n\n      // Check if sensitive information is being logged\n      if (exists(logStmt.args, sensitiveData)) {\n        // Report as CWE-532 vulnerable\n        report cwe532.VulnerableLogging(logStmt"
    }
  }
}
